{"ast":null,"code":"'use strict';\n\nvar Janus = require('./janus.umd');\n\nvar Utils = require('../cubeInternalUtils');\n\nvar coreConfig = require('../cubeConfig');\n\nvar EventEmitter = require('fbemitter').EventEmitter;\n\nvar EVENT_PARTICIPANT_JOINED = \"participantjoined\";\nvar EVENT_PARTICIPANT_LEFT = \"participantleft\";\nvar EVENT_LOCAL_STREAM = \"localstream\";\nvar EVENT_REMOTE_STREAM = \"remotestream\";\n/**\n * @class\n * @param {Object} configParams - a set of configuration parameters. The\n *  following parameters are applied:<br>\n * @param {String} configParams.server - (<b>required</b>) the address of the\n *  gateway as a specific address (e.g., http://yourserver:8088 to use\n *  the plain HTTP API or ws://yourserver:8188 for WebSockets).\n * @param {Boolean} configParams.debug - (<i>optional</i>) whether debug should\n *  be enabled on the JavaScript console (true/false). Default is true.\n * @throws \"'server' parameter is mandatory\" error if 'server' parameter is null\n *  or undefined.\n * @throws \"missing adapter.js\" error if the 'adapter.js' is not connected.\n */\n\nfunction VideoConferencingClient(configParams) {\n  if (!adapter) {\n    throw \"Error: in order to use this library please connect adapter.js. More info https://github.com/webrtc/adapter\";\n  }\n\n  this.configs = configParams;\n\n  if (!this.configs.server) {\n    throw \"'server' parameter is mandatory.\";\n  } else {\n    if (this.configs.server.includes(\"http\")) {\n      this.configs.server = this.configs.server + \"/janus\";\n    }\n  }\n\n  if (!this.configs.debug) {\n    this.configs.debug = \"all\";\n  }\n\n  this.engine = null;\n  this.videoRoomPlugin = null;\n  this.isOnlyAudio = false; //\n\n  this.currentDialogId = null;\n  this.remoteFeeds = [];\n  this.remoteJseps = [];\n  this.remoteFeedsAttachingInProgress = []; //\n\n  this.currentMidiaDeviceId = null; //\n\n  this.bitrateTimers = []; //\n\n  this.emitter = new EventEmitter();\n}\n/**\n * Attach media stream to HTML 'video' element\n *\n * @static\n * @param {Object} element - HTML 'video' element\n * @param {Object} stream - WebRTC media stream\n */\n\n\nVideoConferencingClient.attachMediaStream = function (element, stream) {\n  Janus.attachMediaStream(element, stream);\n};\n/**\n *  Get plugged devices\n *\n * @static\n * @param {function} callback - a callback to be notified about result\n *  (with single argument - array of all devices).\n */\n\n\nVideoConferencingClient.listDevices = function (callback) {\n  navigator.mediaDevices.enumerateDevices().then(function (devices) {\n    console.debug(devices);\n    callback(devices);\n  }).catch(function (err) {\n    console.error(err);\n    callback([]);\n  });\n  ;\n};\n/**\n *  Get plugged video input devices only\n *\n * @static\n * @param {function} callback - a callback to be notified about result\n *  (with single argument - array of video input devices).\n */\n\n\nVideoConferencingClient.listVideoinputDevices = function (callback) {\n  VideoConferencingClient.listDevices(function (devices) {\n    var videoSelect = []; // code sample\n    // https://github.com/webrtc/samples/blob/gh-pages/src/content/devices/input-output/js/main.js#L27\n\n    for (var i = 0; i !== devices.length; ++i) {\n      var deviceInfo = devices[i];\n\n      if (deviceInfo.kind === 'videoinput') {\n        var videoinputDescription = deviceInfo.label || 'camera ' + (videoSelect.length + 1);\n        var videoinputId = deviceInfo.deviceId;\n        videoSelect.push({\n          \"label\": videoinputDescription,\n          \"deviceId\": videoinputId\n        });\n      }\n    }\n\n    callback(videoSelect);\n  });\n};\n\nVideoConferencingClient.prototype = {\n  /**\n   * Create video session\n   *\n   * @param {Object} callbacks - a set of callbacks to be notified about result,\n   *  namely:<br>\n   * @param {function} callbacks.success - the session was successfully created\n   *  and is ready to be used.\n   * @param {function} callbacks.error - the session was NOT successfully\n   *  created. This callback passes single argument - text description of error.\n   * @param {function} callbacks.destroyed - the session was destroyed and\n   *  can't be used any more.\n   */\n  createSession: function createSession(callbacks) {\n    var self = this;\n    Janus.init({\n      debug: this.configs.debug,\n      callback: function callback() {\n        if (!Janus.isWebrtcSupported()) {\n          if (typeof callbacks.error === 'function') {\n            callbacks.error(\"Your browser does not support WebRTC, so you can't use this functionality.\");\n          }\n\n          return;\n        }\n\n        self.engine = new Janus({\n          server: self.configs.server,\n          iceServers: coreConfig.videochat.iceServers,\n          success: function success() {\n            if (typeof callbacks.success === 'function') {\n              Utils.safeCallbackCall(callbacks.success);\n            }\n          },\n          error: function error(_error) {\n            if (typeof callbacks.error === 'function') {\n              Utils.safeCallbackCall(callbacks.error, _error);\n            }\n          },\n          destroyed: function destroyed() {\n            if (typeof callbacks.destroyed === 'function') {\n              Utils.safeCallbackCall(callbacks.destroyed);\n            }\n          },\n          timeoutSessionCallback: function timeoutSessionCallback() {\n            if (typeof callbacks.timeoutSessionCallback === 'function') {\n              Utils.safeCallbackCall(callbacks.timeoutSessionCallback);\n            }\n          }\n        });\n      }\n    });\n  },\n\n  /**\n   * Returns the unique session identifier\n   *\n   * @returns {String} unique session identifier or null.\n   */\n  getSessionId: function getSessionId() {\n    if (this.engine) {\n      return this.engine.getSessionId();\n    }\n\n    return null;\n  },\n\n  /**\n   * Destroy video session\n   *\n   * @param {Object} callbacks - a set of callbacks to be notified about\n   *  result, namely:<br>\n   * @param {function} callbacks.success - the session was successfully\n   *  destroyed and no longer available.\n   * @param {function} callbacks.error - the session was NOT successfully\n   *  destroyed. This callback passes single argument - text description\n   *  of error.\n   */\n  destroySession: function destroySession(callbacks) {\n    var self = this;\n    this.engine.destroy({});\n\n    if (typeof callbacks.success === 'function') {\n      Utils.safeCallbackCall(callbacks.success);\n    }\n  },\n\n  /**\n   * Ð¡reate a video conferencing plugin handle.\n   *\n   * @param  {Boolean} isRemote  To pass 'false' when you attach plugin to\n   *  current user and pass 'true' when attach to remote user.\n   * @param  {Number}  userId  To pass 'null' when you attach plugin to\n   *  current user and pass remote user id when attach to remote user.\n   * @param {Object} callbacks - a set of callbacks to be notified about\n   *  result, namely:<br>\n   * @param {function} callbacks.success - the handle was successfully\n   *  created and is ready to be used.\n   * @param {function} callbacks.error - the handle was NOT successfully\n   *  created or some error has occured. The format of error is the following:\n   *  {\"error_code\": \"some integer code\", \"error\": \"some text description\"}.\n   *  Possible values of 'error_code': <br>\n   * <ul>\n   * <li>428: No such feed - can happen when a user joins room and quickly\n   * leaves it so other user tries to subscribe to none existend feed.\n   * Usually, this error can be ignored.</li>\n   * <li>433: Unauthorized - do not have proper rights to join this room.</li>\n   * <li>436: User ID already exists in this room.</li>\n   * <li>400: Some not usual error occured, for example - no connection to\n   *  server. </li>\n   * </ul>\n   *\n   * @param {function} callbacks.consentDialog - this callback is triggered\n   *  just before <b>getUserMedia</b> is called (parameter=<b>true</b>) and\n   *  after it is completed (parameter=<b>false</b>); this means it can be\n   *  used to modify the UI accordingly, e.g., to prompt the user about the\n   *  need to accept the device access consent requests.\n   * @param {function} callbacks.mediaState - this callback is triggered\n   *  when server starts or stops receiving your media: for instance,\n   *  a <b>mediaState</b> with type=audio and on=true means server started\n   *  receiving your audio stream (or started getting them again after\n   *  a pause of more than a second); a mediaState with type=video\n   *  and on=false means server hasn't received any video from you in the\n   *  last second, after a start was detected before; useful to figure out\n   *  when server actually started handling your media, or to detect problems\n   *  on the media path (e.g., media never started, or stopped at some time).\n   * @param {function} callbacks.webrtcState - this callback is triggered\n   *  with a <b>true</b> value when the PeerConnection associated to a handle\n   *  becomes active (so ICE, DTLS and everything else succeeded) from\n   *  the library perspective, while <b>false</b> is triggered when\n   *  the PeerConnection goes down instead; useful to figure out when WebRTC\n   *  is actually up and running between you and server (e.g., to notify\n   *  a user they're actually now active in a conference).\n   * @param {function} callbacks.slowLink - this callback is triggered when\n   *  server reports trouble either sending or receiving media on the\n   *  specified PeerConnection, typically as a consequence of too many NACKs\n   *  received from/sent to the user in the last second: for instance,\n   *  a slowLink with uplink=true means you notified several missing packets\n   *  from server, while uplink=false means server is not receiving all your\n   *  packets; useful to figure out when there are problems on the media\n   *  path (e.g., excessive loss), in order to possibly react accordingly\n   *  (e.g., decrease the bitrate if most of our packets are getting lost).\n   * @param {function} callbacks.oncleanup - the WebRTC PeerConnection with\n   *  the plugin was closed.\n   */\n  attachVideoConferencingPlugin: function attachVideoConferencingPlugin(isRemote, userId, callbacks) {\n    var self = this;\n    var remoteFeed = null;\n    this.engine.attach({\n      plugin: \"janus.plugin.videoroom\",\n      success: function success(pluginHandle) {\n        if (isRemote) {\n          remoteFeed = pluginHandle;\n          remoteFeed.userId = userId;\n          self.remoteFeedsAttachingInProgress[userId] = remoteFeed; // join remote's feed (listen)\n\n          var listen = {\n            \"request\": \"join\",\n            \"room\": self.currentDialogId,\n            \"ptype\": \"listener\",\n            \"feed\": userId\n          }; // If the publisher is VP8 and this is Safari, let's avoid video\n\n          if (adapter.browserDetails.browser === \"safari\") {\n            listen[\"offer_video\"] = false;\n          }\n\n          remoteFeed.send({\n            \"message\": listen\n          });\n        } else {\n          self.videoRoomPlugin = pluginHandle;\n        }\n\n        if (typeof callbacks.success === 'function') {\n          Utils.safeCallbackCall(callbacks.success);\n        }\n      },\n      error: function error(_error2) {\n        if (typeof callbacks.error === 'function') {\n          Utils.safeCallbackCall(callbacks.error, Utils.wrapError(_error2));\n        }\n      },\n      consentDialog: function consentDialog(on) {\n        if (typeof callbacks.consentDialog === 'function') {\n          Utils.safeCallbackCall(callbacks.consentDialog, on);\n        }\n      },\n      mediaState: function mediaState(medium, on) {\n        if (typeof callbacks.mediaState === 'function') {\n          Utils.safeCallbackCall(callbacks.mediaState, medium, on);\n        }\n      },\n      webrtcState: function webrtcState(on) {\n        if (typeof callbacks.webrtcState === 'function') {\n          Utils.safeCallbackCall(callbacks.webrtcState, on);\n        }\n      },\n      slowLink: function slowLink(uplink, nacks) {\n        if (typeof callbacks.slowLink === 'function') {\n          Utils.safeCallbackCall(callbacks.slowLink, uplink, nacks);\n        }\n      },\n      iceState: function iceState(iceConnectionState) {\n        if (typeof callbacks.iceState === 'function') {\n          Utils.safeCallbackCall(callbacks.iceState, iceConnectionState);\n        }\n      },\n      onmessage: function onmessage(msg, jsep) {\n        var event = msg[\"videoroom\"]; // remote feed\n\n        if (isRemote) {\n          if (event) {\n            // Remote feed attached\n            if (event === \"attached\") {\n              var feedId = msg[\"id\"];\n              self.remoteFeeds[feedId] = self.remoteFeedsAttachingInProgress[feedId];\n              self.remoteFeedsAttachingInProgress[feedId] = null;\n            } else if (msg[\"error\"]) {\n              // #define VIDEOROOM_ERROR_NO_SUCH_FEED\t\t428\n              //\n              if (typeof callbacks.error === 'function') {\n                Utils.safeCallbackCall(callbacks.error, Utils.wrapError(msg[\"error\"]));\n              }\n            }\n          }\n\n          if (jsep) {\n            var feedId = msg[\"id\"]; // ICE restart case\n\n            if (!feedId) {}\n\n            self.remoteJseps[feedId] = jsep;\n            self.createAnswer(self.remoteFeeds[feedId], jsep, {\n              success: function success() {},\n              error: function error(_error3) {\n                if (typeof callbacks.error === 'function') {\n                  Utils.safeCallbackCall(callbacks.error, Utils.wrapError(_error3));\n                }\n              }\n            });\n          } // local feed\n\n        } else {\n          if (event) {\n            // We JOINED\n            if (event === \"joined\") {\n              self.createOffer({\n                useAudio: true,\n                useVideo: !self.isOnlyAudio\n              }, {\n                success: function success() {\n                  // Any new feed to attach to?\n                  if (msg[\"publishers\"]) {\n                    var publishers = msg[\"publishers\"];\n\n                    for (var f in publishers) {\n                      var userId = publishers[f][\"id\"];\n                      var userDisplayName = publishers[f][\"display\"];\n                      self.emitter.emit(EVENT_PARTICIPANT_JOINED, userId, userDisplayName);\n                    }\n                  }\n                },\n                error: function error(_error4) {\n                  if (typeof callbacks.error === 'function') {\n                    Utils.safeCallbackCall(callbacks.error, Utils.wrapError(_error4));\n                  }\n                }\n              }); // We JOINED and now receiving who is online\n            } else if (event === \"event\") {\n              // Any new feed to attach to?\n              if (msg[\"publishers\"]) {\n                var publishers = msg[\"publishers\"];\n\n                for (var f in publishers) {\n                  var userId = publishers[f][\"id\"];\n                  var userDisplayName = publishers[f][\"display\"];\n                  self.emitter.emit(EVENT_PARTICIPANT_JOINED, userId, userDisplayName);\n                } // Someone is LEAVING\n\n              } else if (msg[\"leaving\"]) {\n                // One of the publishers has gone away?\n                var feedId = msg[\"leaving\"];\n                var success = self.detachRemoteFeed(feedId);\n\n                if (success) {\n                  self.emitter.emit(EVENT_PARTICIPANT_LEFT, feedId, null);\n                }\n              } else if (msg[\"unpublished\"]) {\n                // One of the publishers has gone away?\n                var feedId = msg[\"unpublished\"];\n\n                if (feedId != 'ok') {\n                  var success = self.detachRemoteFeed(feedId);\n\n                  if (success) {\n                    self.emitter.emit(EVENT_PARTICIPANT_LEFT, feedId, null);\n                  }\n                }\n              } else if (msg[\"error\"]) {\n                // #define VIDEOROOM_ERROR_ID_EXISTS\t\t\t436\n                // #define VIDEOROOM_ERROR_UNAUTHORIZED\t\t433\n                //\n                if (typeof callbacks.error === 'function') {\n                  Utils.safeCallbackCall(callbacks.error, Utils.wrapError(msg[\"error\"]));\n                }\n              }\n            }\n          }\n\n          if (jsep) {\n            self.videoRoomPlugin.handleRemoteJsep({\n              jsep: jsep\n            }); // TODO:\n            // handle wrong or unsupported codecs here...\n            // var video = msg[\"video_codec\"];\n            // if(mystream && mystream.getVideoTracks() && mystream.getVideoTracks().length > 0 && !video) {\n            // \t\t\"Our video stream has been rejected, viewers won't see us\";\n            // }\n          }\n        }\n      },\n      onlocalstream: function onlocalstream(stream) {\n        self.emitter.emit(EVENT_LOCAL_STREAM, stream);\n      },\n      onremotestream: function onremotestream(stream) {\n        remoteFeed.stream = stream;\n        self.emitter.emit(EVENT_REMOTE_STREAM, stream, remoteFeed.userId);\n      },\n      oncleanup: function oncleanup() {\n        console.info(\"ON CLEANUP\");\n\n        if (typeof callbacks.oncleanup === 'function') {\n          Utils.safeCallbackCall(callbacks.oncleanup);\n        }\n      },\n      detached: function detached() {}\n    });\n  },\n\n  /**\n   * Returns the unique plugin identifier\n   *\n   * @returns {String} unique plugin identifier or null.\n   */\n  getPluginId: function getPluginId() {\n    if (this.videoRoomPlugin) {\n      return this.videoRoomPlugin.getId();\n    }\n\n    return null;\n  },\n\n  /**\n   * Detach a video conferencing plugin handle.\n   *\n   * @param {Object} callbacks - a set of callbacks to be notified about\n   *  result, namely:<br>\n   * @param {function} callbacks.success - the handle was successfully\n   *  destroyed.\n   * @param {function} callbacks.error - the handle was NOT successfully\n   *  destroyed. This callback passes single argument - text description\n   *  of error.\n   */\n  detachVideoConferencingPlugin: function detachVideoConferencingPlugin(callbacks) {\n    var self = this;\n\n    var clean = function clean() {\n      self.videoRoomPlugin = null; // detach all remote feeds\n\n      Object.keys(self.remoteFeeds).forEach(function (userId) {\n        self.detachRemoteFeed(userId);\n      });\n      self.remoteFeeds = [];\n      self.remoteJseps = [];\n      self.currentMidiaDeviceId = null;\n    };\n\n    this.videoRoomPlugin.detach({\n      success: function success() {\n        clean();\n\n        if (typeof callbacks.success === 'function') {\n          Utils.safeCallbackCall(callbacks.success);\n        }\n      },\n      error: function error(_error5) {\n        clean();\n\n        if (typeof callbacks.error === 'function') {\n          Utils.safeCallbackCall(callbacks.error, _error5);\n        }\n      }\n    });\n  },\n\n  /**\n   * Join video conference room\n   *\n   * @param {String} chatDialogId - a chat dialog ID to join\n   * @param {Number} userId - an id of current user.\n   * @param {Boolean} isOnlyAudio - to join current room as audio-only.\n   * @param {Object} callbacks - a set of callbacks to be notified about\n   *  result, namely:<br>\n   * @param {function} callbacks.success - the chat dialog was successfully\n   *  joined.\n   * @param {function} callbacks.error - the chat dialog was NOT successfully\n   *  joined. This callback passes single argument - text description\n   *  of error.\n   */\n  join: function join(chatDialogId, userId, isOnlyAudio, callbacks) {\n    var self = this;\n\n    if (typeof isOnlyAudio !== \"boolean\") {\n      throw \"'isOnlyAudio' parameter can be of type 'boolean' only.\";\n    }\n\n    self.isOnlyAudio = isOnlyAudio;\n\n    if (adapter.browserDetails.browser === \"safari\") {\n      self.isOnlyAudio = true;\n    }\n\n    console.info(\"isOnlyAudio: \" + self.isOnlyAudio);\n    var joinEvent = {\n      \"request\": \"join\",\n      \"room\": chatDialogId,\n      \"ptype\": \"publisher\",\n      \"id\": userId\n    }; //\"display\": null\n\n    this.videoRoomPlugin.send({\n      \"message\": joinEvent,\n      success: function success(resp) {\n        self.currentDialogId = chatDialogId;\n        self.currentUserId = userId;\n\n        if (typeof callbacks.success === 'function') {\n          Utils.safeCallbackCall(callbacks.success);\n        }\n      },\n      error: function error(_error6) {\n        if (typeof callbacks.error === 'function') {\n          Utils.safeCallbackCall(callbacks.error, _error6);\n        }\n      }\n    });\n  },\n\n  /**\n   * Leave video conference room\n   *\n   * @param {Object} callbacks - a set of callbacks to be notified about\n   *  result, namely:<br>\n   * @param {function} callbacks.success - the chat dialog was successfully\n   *  left.\n   * @param {function} callbacks.error - the chat dialog was NOT successfully\n   *  left. This callback passes single argument - text description of error.\n   */\n  leave: function leave(callbacks) {\n    var self = this;\n    console.warn(\"leave\");\n\n    if (!self.engine.isConnected()) {\n      if (typeof callbacks.success === 'function') {\n        Utils.safeCallbackCall(callbacks.success);\n      }\n\n      return;\n    }\n\n    var leaveEvent = {\n      \"request\": \"leave\",\n      \"room\": this.currentDialogId,\n      \"id\": this.currentUserId\n    };\n\n    if (this.videoRoomPlugin) {\n      this.videoRoomPlugin.send({\n        \"message\": leaveEvent\n      });\n    }\n\n    this.currentDialogId = null;\n    this.currentUserId = null;\n    console.warn(\"resp\");\n\n    if (typeof callbacks.success === 'function') {\n      Utils.safeCallbackCall(callbacks.success);\n    }\n  },\n\n  /**\n   * List online participants\n   *\n   * @param {String} chatDialogId - a chat dialog ID to list online\n   *  participants in.\n   * @param {Object} callbacks - a set of callbacks to be notified about\n   *  result, namely:<br>\n   * @param {function} callbacks.success - when everything is ok and you will\n   *  receive one argument - array of online participants.\n   * @param {function} callbacks.error - when an error occured. This callback\n   *  passes single argument - text description of error.\n   */\n  listOnlineParticipants: function listOnlineParticipants(chatDialogId, callbacks) {\n    var listRequest = {\n      \"request\": \"listparticipants\",\n      \"room\": chatDialogId\n    }; //\n\n    this.videoRoomPlugin.send({\n      \"message\": listRequest,\n      success: function success(data) {\n        var participants = [];\n\n        if (data) {\n          participants = data.participants;\n        }\n\n        if (typeof callbacks.success === 'function') {\n          Utils.safeCallbackCall(callbacks.success, participants);\n        }\n      },\n      error: function error(_error7) {\n        if (typeof callbacks.error === 'function') {\n          Utils.safeCallbackCall(callbacks.error, _error7);\n        }\n      }\n    });\n  },\n\n  /**\n   * Toggle audio mute.\n   *\n   * @returns {Boolean} true if audio is muted, otherwise - false.\n   */\n  toggleAudioMute: function toggleAudioMute() {\n    var muted = this.videoRoomPlugin.isAudioMuted();\n\n    if (muted) {\n      this.videoRoomPlugin.unmuteAudio();\n    } else {\n      this.videoRoomPlugin.muteAudio();\n    }\n\n    return this.videoRoomPlugin.isAudioMuted();\n  },\n\n  /**\n   * Is audio muted.\n   *\n   * @returns {Boolean} true if audio is muted, otherwise - false.\n   */\n  isAudioMuted: function isAudioMuted() {\n    return this.videoRoomPlugin.isAudioMuted();\n  },\n\n  /**\n   * Toggle remote user audio mute.\n   *\n   * @param {Number} userId - an id of user to mute audio.\n   *\n   * @returns {Boolean} true if audio is muted, otherwise - false.\n   */\n  toggleRemoteAudioMute: function toggleRemoteAudioMute(userId) {\n    var remoteFeed = this.remoteFeeds[userId];\n\n    if (!remoteFeed) {\n      return false;\n    }\n\n    var audioTracks = remoteFeed.stream.getAudioTracks();\n\n    if (audioTracks && audioTracks.length > 0) {\n      for (var i = 0; i < audioTracks.length; ++i) {\n        audioTracks[i].enabled = !audioTracks[i].enabled;\n      }\n\n      return !audioTracks[0].enabled;\n    }\n\n    return false;\n  },\n\n  /**\n   * Is remote audio muted.\n   *\n   * @param {Number} userId - an id of user to check audio mute\n   *  state.\n   *\n   * @returns {Boolean} true if audio is muted, otherwise - false.\n   */\n  isRemoteAudioMuted: function isRemoteAudioMuted(userId) {\n    var remoteFeed = this.remoteFeeds[userId];\n\n    if (!remoteFeed) {\n      return false;\n    }\n\n    var audioTracks = remoteFeed.stream.getAudioTracks();\n\n    if (audioTracks && audioTracks.length > 0) {\n      return !audioTracks[0].enabled;\n    }\n\n    return false;\n  },\n\n  /**\n   * Toggle video mute.\n   *\n   * @returns {Boolean} true if video is muted, otherwise - false.\n   */\n  toggleVideoMute: function toggleVideoMute() {\n    var muted = this.videoRoomPlugin.isVideoMuted();\n\n    if (muted) {\n      this.videoRoomPlugin.unmuteVideo();\n    } else {\n      this.videoRoomPlugin.muteVideo();\n    }\n\n    return this.videoRoomPlugin.isVideoMuted();\n  },\n\n  /**\n   * Is video muted.\n   *\n   * @returns {Boolean} true if video is muted, otherwise - false.\n   */\n  isVideoMuted: function isVideoMuted() {\n    return this.videoRoomPlugin.isVideoMuted();\n  },\n\n  /**\n   * Toggle remote user video mute.\n   *\n   * @param {Number} userId - an id of user to mute video.\n   *\n   * @returns {Boolean} true if video is muted, otherwise - false.\n   */\n  toggleRemoteVideoMute: function toggleRemoteVideoMute(userId) {\n    var remoteFeed = this.remoteFeeds[userId];\n\n    if (!remoteFeed) {\n      return false;\n    }\n\n    var videoTracks = remoteFeed.stream.getVideoTracks();\n\n    if (videoTracks && videoTracks.length > 0) {\n      for (var i = 0; i < videoTracks.length; ++i) {\n        videoTracks[i].enabled = !videoTracks[i].enabled;\n      }\n\n      return !videoTracks[0].enabled;\n    }\n\n    return false;\n  },\n\n  /**\n   * Is remote video muted.\n   *\n   * @param {Number} userId - an id of user to check video mute\n   *  state.\n   *\n   * @returns {Boolean} true if video is muted, otherwise - false.\n   */\n  isRemoteVideoMuted: function isRemoteVideoMuted(userId) {\n    var remoteFeed = this.remoteFeeds[userId];\n\n    if (!remoteFeed) {\n      return false;\n    }\n\n    var videoTracks = remoteFeed.stream.getVideoTracks();\n\n    if (videoTracks && videoTracks.length > 0) {\n      return !videoTracks[0].enabled;\n    }\n\n    return false;\n  },\n\n  /**\n   * Switch video input source.\n   *\n   * @param {String} mediaDeviceId - an id of media device (camera) to switch to.\n   *  Can be obtained via 'VideoConferencingClient.listVideoinputDevices'.\n   * @param {Object} callbacks - a set of callbacks to be notified about\n   *  result, namely:<br>\n   * @param {function} callbacks.success - when everything is ok.\n   * @param {function} callbacks.error - when an error occured. This callback\n   *  passes single argument - text description of error.\n   */\n  switchVideoinput: function switchVideoinput(mediaDeviceId, callbacks) {\n    if (!this.videoRoomPlugin) {\n      if (typeof callbacks.error === 'function') {\n        Utils.safeCallbackCall(callbacks.error, \"No active stream\");\n      }\n\n      return;\n    }\n\n    if (this.isOnlyAudio) {\n      throw \"Can't switch video input in audio only call.\";\n    }\n\n    this.currentMidiaDeviceId = null;\n    var self = this;\n    this.createOffer({\n      video: {\n        deviceId: mediaDeviceId\n      },\n      replaceVideo: true\n    }, {\n      success: function success() {\n        console.info(\"switchVideoinput: success\");\n        self.currentMidiaDeviceId = mediaDeviceId;\n\n        if (typeof callbacks.success === 'function') {\n          Utils.safeCallbackCall(callbacks.success);\n        }\n      },\n      error: function error(_error8) {\n        console.info(\"switchVideoinput: error\", _error8);\n\n        if (typeof callbacks.error === 'function') {\n          Utils.safeCallbackCall(callbacks.error, _error8);\n        }\n      }\n    });\n  },\n\n  /**\n   * Initiate ICE restart for remote peer.\n   * These are typically needed whenever something in your network changes\n   * (e.g., you move from WiFi to mobile or a different WiFi) but want to\n   * keep the conversation going: in this case, an ICE restart needs to take\n   * place, as the peers need to exchange the new candidates they can be\n   * reached on.\n   *\n   * @param {Number} userIdOrCallbacks - an id of user to initiate ICE restart with or callbacks if it's a local peer.\n   * @param {function} callbacks.success - when everything is ok.\n   * @param {function} callbacks.error - when an error occured. This callback\n   *  passes single argument - text description of error.\n   */\n  iceRestart: function iceRestart(userIdOrCallbacks, callbacks) {\n    // remote ICE restart\n    if (callbacks) {\n      console.info(\"Performing remote ICE restart for user: \", userIdOrCallbacks);\n      var remoteFeed = this.remoteFeeds[userIdOrCallbacks];\n\n      if (!remoteFeed) {\n        if (typeof callbacks.error === 'function') {\n          Utils.safeCallbackCall(callbacks.error, \"No such user feed\");\n        }\n\n        return;\n      }\n\n      var req = {\n        \"request\": \"configure\",\n        \"restart\": true\n      };\n      remoteFeed.send({\n        \"message\": req\n      });\n\n      if (typeof callbacks.success === 'function') {\n        Utils.safeCallbackCall(callbacks.success);\n      } // local ICE restart\n\n    } else {\n      console.info(\"Performing local ICE restart\");\n      this.createOffer({\n        iceRestart: true\n      }, {\n        success: function success() {\n          if (typeof userIdOrCallbacks.success === 'function') {\n            Utils.safeCallbackCall(userIdOrCallbacks.success);\n          }\n        },\n        error: function error(_error9) {\n          if (typeof userIdOrCallbacks.error === 'function') {\n            Utils.safeCallbackCall(userIdOrCallbacks.error, _error9);\n          }\n        }\n      });\n    }\n  },\n\n  /**\n   * @private\n   */\n  createOffer: function createOffer(inputParams, callbacks) {\n    console.log(\"createOffer, inputParams: \", inputParams);\n    var self = this;\n    var useAudio = inputParams.useAudio;\n    var useVideo = inputParams.useVideo;\n    var stream = inputParams.stream;\n    var replaceVideo = inputParams.replaceVideo;\n    var iceRestart = inputParams.iceRestart;\n    var videoQuality = self.configs.video ? self.configs.video.quality : null;\n    var videoFrameRate = self.configs.video ? self.configs.video.frameRate : null;\n    var params;\n\n    if (stream) {\n      params = {\n        stream: stream\n      };\n    } else if (replaceVideo) {\n      params = {\n        media: inputParams\n      };\n\n      if (videoQuality) {\n        params[\"media\"][\"video\"] = videoQuality;\n      }\n\n      if (videoFrameRate) {\n        params[\"media\"][\"videoFrameRate\"] = {\n          min: videoFrameRate,\n          max: videoFrameRate\n        };\n      }\n    } else if (iceRestart) {\n      params = inputParams;\n    } else {\n      params = {\n        media: {\n          audioRecv: false,\n          videoRecv: false,\n          audioSend: useAudio,\n          videoSend: useVideo\n        }\n      }; // Publishers are sendonly\n\n      if (videoQuality) {\n        params[\"media\"][\"video\"] = videoQuality;\n      }\n\n      if (videoFrameRate) {\n        params[\"media\"][\"videoFrameRate\"] = {\n          min: videoFrameRate,\n          ideal: videoFrameRate\n        };\n      }\n    }\n\n    console.info(\"createOffer params: \", params);\n\n    params.success = function (jsep) {\n      var publish = {\n        \"request\": \"configure\"\n      };\n\n      if (replaceVideo || iceRestart) {// publish[\"update\"] = true;\n      } else {\n        publish[\"audio\"] = useAudio;\n        publish[\"video\"] = useVideo;\n      }\n\n      console.info(\"createOffer publish: \", publish);\n      self.videoRoomPlugin.send({\n        \"message\": publish,\n        \"jsep\": jsep\n      });\n\n      if (typeof callbacks.success === 'function') {\n        callbacks.success();\n      }\n    };\n\n    params.error = function (error) {\n      console.error(\"Error in createOffer: \", error);\n\n      if (useAudio) {\n        self.createOffer({\n          useAudio: false,\n          useVideo: false\n        }, callbacks);\n      } else {\n        if (typeof callbacks.error === 'function') {\n          callbacks.error(error);\n        }\n      }\n    };\n\n    this.videoRoomPlugin.createOffer(params);\n  },\n\n  /**\n   * @private\n   */\n  createAnswer: function createAnswer(remoteFeed, jsep, callbacks) {\n    var self = this;\n    remoteFeed.createAnswer({\n      jsep: jsep,\n      media: {\n        audioSend: false,\n        videoSend: false\n      },\n      // We want recvonly audio/video\n      success: function success(jsep) {\n        var body = {\n          \"request\": \"start\",\n          \"room\": self.currentDialogId\n        };\n        remoteFeed.send({\n          \"message\": body,\n          \"jsep\": jsep\n        });\n\n        if (typeof callbacks.success === 'function') {\n          Utils.safeCallbackCall(callbacks.success);\n        }\n      },\n      error: function error(_error10) {\n        console.error(\"createAnswer error: \", _error10);\n\n        if (typeof callbacks.error === 'function') {\n          Utils.safeCallbackCall(callbacks.error, _error10);\n        }\n      }\n    });\n  },\n\n  /**\n   * @private\n   */\n  detachRemoteFeed: function detachRemoteFeed(userId) {\n    var remoteFeed = this.remoteFeeds[userId];\n\n    if (remoteFeed) {\n      remoteFeed.detach();\n      this.remoteFeeds[userId] = null;\n      this.remoteJseps[userId] = null;\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * Start show a verbose description of the user's stream bitrate.\n   * Refresh it every 1 second.\n   *\n   * @param {Number} userId - an id of user to gets stream bitrate.\n   * @param {Object} element - DOM element to display bitrate on.\n   */\n  showBitrate: function showBitrate(userId, element) {\n    var remoteFeed = this.remoteFeeds[userId];\n\n    if (adapter.browserDetails.browser === \"chrome\" || adapter.browserDetails.browser === \"firefox\") {\n      this.bitrateTimers[userId] = setInterval(function () {\n        var bitrate = remoteFeed.getBitrate();\n        element.text(bitrate);\n      }, 1000);\n    }\n  },\n\n  /**\n   * Stop show a verbose description of the user's stream bitrate.\n   *\n   * @param {Number} userId - an id of user to stop show stream\n   * bitrate.\n   * @param {Object} element - DOM element to stop display bitrate on.\n   */\n  hideBitrate: function hideBitrate(userId, element) {\n    if (this.bitrateTimers[userId]) {\n      clearInterval(this.bitrateTimers[userId]);\n    }\n\n    this.bitrateTimers[userId] = null;\n    element.text = null;\n  },\n\n  /**\n   * Adds a listener to be invoked when events of the specified type are\n   * emitted. The data arguments emitted will be passed to the listener\n   * function. <br>\n   * Possible events:\n   * <ul>\n   * <li>'participantjoined': (userId, userDisplayName)</li>\n   * <li>'participantleft': (userId, userDisplayName)</li>\n   * <li>'localstream': (stream)</li>\n   * <li>'remotestream': (stream, userId)</li>\n   * </ul>\n   *\n   * @param {String} eventType - Name of the event to listen to\n   * @param {function} listener - Function to invoke when the specified\n   *  event is emitted\n   */\n  on: function on(eventType, listener) {\n    var token = this.emitter.addListener(eventType, listener);\n  },\n\n  /**\n   * Removes all of the registered listeners.\n   *\n   * @param {?String} eventType - Optional name of the event whose registered\n   *   listeners to remove.\n   */\n  removeAllListeners: function removeAllListeners(eventType) {\n    if (eventType) {\n      this.emitter.removeAllListeners(eventType);\n    } else {\n      this.emitter.removeAllListeners();\n    }\n  }\n};\nmodule.exports = {\n  Client: VideoConferencingClient\n};","map":null,"metadata":{},"sourceType":"script"}