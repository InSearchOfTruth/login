{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.Janus = factory();\n})(this, function () {\n  /* eslint-disable */\n\n  /*\n   * Module shim for rollup.js to work with.\n   * Simply re-export Janus from janus.js, the real 'magic' is in the rollup config.\n   *\n   * Since this counts as 'autogenerated' code, ESLint is instructed to ignore the contents of this file when linting your project.\n   */\n\n  /*\n  \tThe MIT License (MIT)\n  \n  \tCopyright (c) 2016 Meetecho\n  \n  \tPermission is hereby granted, free of charge, to any person obtaining\n  \ta copy of this software and associated documentation files (the \"Software\"),\n  \tto deal in the Software without restriction, including without limitation\n  \tthe rights to use, copy, modify, merge, publish, distribute, sublicense,\n  \tand/or sell copies of the Software, and to permit persons to whom the\n  \tSoftware is furnished to do so, subject to the following conditions:\n  \n  \tThe above copyright notice and this permission notice shall be included\n  \tin all copies or substantial portions of the Software.\n  \n  \tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  \tOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  \tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  \tTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n  \tOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n  \tARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n  \tOTHER DEALINGS IN THE SOFTWARE.\n   */\n  // List of sessions\n  Janus.sessions = {}; // Screensharing Chrome Extension ID\n\n  Janus.extensionId = \"hapfgfdkleiggjjpfpenajgdnfckjpaj\";\n\n  Janus.isExtensionEnabled = function () {\n    if (window.navigator.userAgent.match('Chrome')) {\n      var chromever = parseInt(window.navigator.userAgent.match(/Chrome\\/(.*) /)[1], 10);\n      var maxver = 33;\n      if (window.navigator.userAgent.match('Linux')) maxver = 35; // \"known\" crash in chrome 34 and 35 on linux\n\n      if (chromever >= 26 && chromever <= maxver) {\n        // Older versions of Chrome don't support this extension-based approach, so lie\n        return true;\n      }\n\n      return Janus.checkJanusExtension();\n    } else {\n      // Firefox of others, no need for the extension (but this doesn't mean it will work)\n      return true;\n    }\n  };\n\n  Janus.useDefaultDependencies = function (deps) {\n    var f = deps && deps.fetch || fetch;\n    var p = deps && deps.Promise || Promise;\n    var socketCls = deps && deps.WebSocket || WebSocket;\n    return {\n      newWebSocket: function newWebSocket(server, proto) {\n        return new socketCls(server, proto);\n      },\n      isArray: function isArray(arr) {\n        return Array.isArray(arr);\n      },\n      checkJanusExtension: function checkJanusExtension() {\n        return document.querySelector('#janus-extension-installed') !== null;\n      },\n      webRTCAdapter: deps && deps.adapter || adapter,\n      httpAPICall: function httpAPICall(url, options) {\n        var fetchOptions = {\n          method: options.verb,\n          cache: 'no-cache'\n        };\n\n        if (options.withCredentials !== undefined) {\n          fetchOptions.credentials = options.withCredentials === true ? 'include' : options.withCredentials ? options.withCredentials : 'omit';\n        }\n\n        if (options.body !== undefined) {\n          fetchOptions.body = JSON.stringify(options.body);\n        }\n\n        var fetching = f(url, fetchOptions).catch(function (error) {\n          return p.reject({\n            message: 'Probably a network error, is the gateway down?',\n            error: error\n          });\n        });\n        /*\n         * fetch() does not natively support timeouts.\n         * Work around this by starting a timeout manually, and racing it agains the fetch() to see which thing resolves first.\n         */\n\n        if (options.timeout !== undefined) {\n          var timeout = new p(function (resolve, reject) {\n            var timerId = setTimeout(function () {\n              clearTimeout(timerId);\n              return reject({\n                message: 'Request timed out',\n                timeout: options.timeout\n              });\n            }, options.timeout);\n          });\n          fetching = p.race([fetching, timeout]);\n        }\n\n        fetching.then(function (response) {\n          if (response.ok) {\n            if (typeof options.success === typeof Janus.noop) {\n              return response.json().then(function (parsed) {\n                options.success(parsed);\n              }).catch(function (error) {\n                return p.reject({\n                  message: 'Failed to parse response body',\n                  error: error,\n                  response: response\n                });\n              });\n            }\n          } else {\n            return p.reject({\n              message: 'API call failed',\n              response: response\n            });\n          }\n        }).catch(function (error) {\n          if (typeof options.error === typeof Janus.noop) {\n            options.error(error.message || '<< internal error >>', error);\n          }\n        });\n        return fetching;\n      }\n    };\n  };\n\n  Janus.useOldDependencies = function (deps) {\n    var jq = deps && deps.jQuery || jQuery;\n    var socketCls = deps && deps.WebSocket || WebSocket;\n    return {\n      newWebSocket: function newWebSocket(server, proto) {\n        return new socketCls(server, proto);\n      },\n      isArray: function isArray(arr) {\n        return jq.isArray(arr);\n      },\n      checkJanusExtension: function checkJanusExtension() {\n        return jq('#janus-extension-installed').length > 0;\n      },\n      webRTCAdapter: deps && deps.adapter || adapter,\n      httpAPICall: function httpAPICall(url, options) {\n        var payload = options.body !== undefined ? {\n          contentType: 'application/json',\n          data: JSON.stringify(options.body)\n        } : {};\n        var credentials = options.withCredentials !== undefined ? {\n          xhrFields: {\n            withCredentials: options.withCredentials\n          }\n        } : {};\n        return jq.ajax(jq.extend(payload, credentials, {\n          url: url,\n          type: options.verb,\n          cache: false,\n          dataType: 'json',\n          async: options.async,\n          timeout: options.timeout,\n          success: function success(result) {\n            if (typeof options.success === typeof Janus.noop) {\n              options.success(result);\n            }\n          },\n          error: function error(xhr, status, err) {\n            if (typeof options.error === typeof Janus.noop) {\n              options.error(status, err);\n            }\n          }\n        }));\n      }\n    };\n  };\n\n  Janus.noop = function () {}; // Initialization\n\n\n  Janus.init = function (options) {\n    options = options || {};\n    options.callback = typeof options.callback == \"function\" ? options.callback : Janus.noop;\n\n    if (Janus.initDone === true) {\n      // Already initialized\n      options.callback();\n    } else {\n      if (typeof console == \"undefined\" || typeof console.log == \"undefined\") console = {\n        log: function log() {}\n      }; // Console logging (all debugging disabled by default)\n\n      Janus.trace = Janus.noop;\n      Janus.debug = Janus.noop;\n      Janus.vdebug = Janus.noop;\n      Janus.log = Janus.noop;\n      Janus.warn = Janus.noop;\n      Janus.error = Janus.noop;\n\n      if (options.debug === true || options.debug === \"all\") {\n        // Enable all debugging levels\n        Janus.trace = console.trace.bind(console);\n        Janus.debug = console.debug.bind(console);\n        Janus.vdebug = console.debug.bind(console);\n        Janus.log = console.log.bind(console);\n        Janus.warn = console.warn.bind(console);\n        Janus.error = console.error.bind(console);\n      } else if (Array.isArray(options.debug)) {\n        for (var i in options.debug) {\n          var d = options.debug[i];\n\n          switch (d) {\n            case \"trace\":\n              Janus.trace = console.trace.bind(console);\n              break;\n\n            case \"debug\":\n              Janus.debug = console.debug.bind(console);\n              break;\n\n            case \"vdebug\":\n              Janus.vdebug = console.debug.bind(console);\n              break;\n\n            case \"log\":\n              Janus.log = console.log.bind(console);\n              break;\n\n            case \"warn\":\n              Janus.warn = console.warn.bind(console);\n              break;\n\n            case \"error\":\n              Janus.error = console.error.bind(console);\n              break;\n\n            default:\n              console.error(\"Unknown debugging option '\" + d + \"' (supported: 'trace', 'debug', 'vdebug', 'log', warn', 'error')\");\n              break;\n          }\n        }\n      }\n\n      Janus.log(\"Initializing library\");\n      var usedDependencies = options.dependencies || Janus.useDefaultDependencies();\n      Janus.isArray = usedDependencies.isArray;\n      Janus.webRTCAdapter = usedDependencies.webRTCAdapter;\n      Janus.httpAPICall = usedDependencies.httpAPICall;\n      Janus.checkJanusExtension = usedDependencies.checkJanusExtension;\n      Janus.newWebSocket = usedDependencies.newWebSocket; // Helper method to enumerate devices\n\n      Janus.listDevices = function (callback, config) {\n        callback = typeof callback == \"function\" ? callback : Janus.noop;\n        if (config == null) config = {\n          audio: true,\n          video: true\n        };\n\n        if (navigator.mediaDevices) {\n          navigator.mediaDevices.getUserMedia(config).then(function (stream) {\n            navigator.mediaDevices.enumerateDevices().then(function (devices) {\n              Janus.debug(devices);\n              callback(devices); // Get rid of the now useless stream\n\n              try {\n                var tracks = stream.getTracks();\n\n                for (var i in tracks) {\n                  var mst = tracks[i];\n                  if (mst !== null && mst !== undefined) mst.stop();\n                }\n              } catch (e) {}\n            });\n          }).catch(function (err) {\n            Janus.error(err);\n            callback([]);\n          });\n        } else {\n          Janus.warn(\"navigator.mediaDevices unavailable\");\n          callback([]);\n        }\n      }; // Helper methods to attach/reattach a stream to a video element (previously part of adapter.js)\n\n\n      Janus.attachMediaStream = function (element, stream) {\n        if (Janus.webRTCAdapter.browserDetails.browser === 'chrome') {\n          var chromever = Janus.webRTCAdapter.browserDetails.version;\n\n          if (chromever >= 43) {\n            element.srcObject = stream;\n          } else if (typeof element.src !== 'undefined') {\n            element.src = URL.createObjectURL(stream);\n          } else {\n            Janus.error(\"Error attaching stream to element\");\n          }\n        } else {\n          element.srcObject = stream;\n        }\n      };\n\n      Janus.reattachMediaStream = function (to, from) {\n        if (Janus.webRTCAdapter.browserDetails.browser === 'chrome') {\n          var chromever = Janus.webRTCAdapter.browserDetails.version;\n\n          if (chromever >= 43) {\n            to.srcObject = from.srcObject;\n          } else if (typeof to.src !== 'undefined') {\n            to.src = from.src;\n          } else {\n            Janus.error(\"Error reattaching stream to element\");\n          }\n        } else {\n          to.srcObject = from.srcObject;\n        }\n      }; // Detect tab close: make sure we don't loose existing onbeforeunload handlers\n\n\n      var oldOBF = window.onbeforeunload;\n\n      window.onbeforeunload = function () {\n        Janus.log(\"Closing window\");\n\n        for (var s in Janus.sessions) {\n          if (Janus.sessions[s] !== null && Janus.sessions[s] !== undefined && Janus.sessions[s].destroyOnUnload) {\n            Janus.log(\"Destroying session \" + s);\n            Janus.sessions[s].destroy({\n              asyncRequest: false\n            });\n          }\n        }\n\n        if (oldOBF && typeof oldOBF == \"function\") oldOBF();\n      };\n\n      Janus.initDone = true;\n      options.callback();\n    }\n  }; // Helper method to check whether WebRTC is supported by this browser\n\n\n  Janus.isWebrtcSupported = function () {\n    return window.RTCPeerConnection !== undefined && window.RTCPeerConnection !== null && navigator.getUserMedia !== undefined && navigator.getUserMedia !== null;\n  }; // Helper method to create random identifiers (e.g., transaction)\n\n\n  Janus.randomString = function (len) {\n    var charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    var randomString = '';\n\n    for (var i = 0; i < len; i++) {\n      var randomPoz = Math.floor(Math.random() * charSet.length);\n      randomString += charSet.substring(randomPoz, randomPoz + 1);\n    }\n\n    return randomString;\n  };\n\n  function Janus(gatewayCallbacks) {\n    if (Janus.initDone === undefined) {\n      gatewayCallbacks.error(\"Library not initialized\");\n      return {};\n    }\n\n    if (!Janus.isWebrtcSupported()) {\n      gatewayCallbacks.error(\"WebRTC not supported by this browser\");\n      return {};\n    }\n\n    Janus.log(\"Library initialized: \" + Janus.initDone);\n    gatewayCallbacks = gatewayCallbacks || {};\n    gatewayCallbacks.success = typeof gatewayCallbacks.success == \"function\" ? gatewayCallbacks.success : Janus.noop;\n    gatewayCallbacks.error = typeof gatewayCallbacks.error == \"function\" ? gatewayCallbacks.error : Janus.noop;\n    gatewayCallbacks.destroyed = typeof gatewayCallbacks.destroyed == \"function\" ? gatewayCallbacks.destroyed : Janus.noop;\n\n    if (gatewayCallbacks.server === null || gatewayCallbacks.server === undefined) {\n      gatewayCallbacks.error(\"Invalid gateway url\");\n      return {};\n    }\n\n    var websockets = false;\n    var ws = null;\n    var wsHandlers = {};\n    var wsKeepaliveTimeoutId = null;\n    var servers = null,\n        serversIndex = 0;\n    var server = gatewayCallbacks.server;\n\n    if (Janus.isArray(server)) {\n      Janus.log(\"Multiple servers provided (\" + server.length + \"), will use the first that works\");\n      server = null;\n      servers = gatewayCallbacks.server;\n      Janus.debug(servers);\n    } else {\n      if (server.indexOf(\"ws\") === 0) {\n        websockets = true;\n        Janus.log(\"Using WebSockets to contact Janus: \" + server);\n      } else {\n        websockets = false;\n        Janus.log(\"Using REST API to contact Janus: \" + server);\n      }\n    }\n\n    var iceServers = gatewayCallbacks.iceServers;\n    if (iceServers === undefined || iceServers === null) iceServers = [{\n      urls: \"stun:stun.l.google.com:19302\"\n    }];\n    var iceTransportPolicy = gatewayCallbacks.iceTransportPolicy;\n    var bundlePolicy = gatewayCallbacks.bundlePolicy; // Whether IPv6 candidates should be gathered\n\n    var ipv6Support = gatewayCallbacks.ipv6;\n    if (ipv6Support === undefined || ipv6Support === null) ipv6Support = false; // Whether we should enable the withCredentials flag for XHR requests\n\n    var withCredentials = false;\n    if (gatewayCallbacks.withCredentials !== undefined && gatewayCallbacks.withCredentials !== null) withCredentials = gatewayCallbacks.withCredentials === true; // Optional max events\n\n    var maxev = null;\n    if (gatewayCallbacks.max_poll_events !== undefined && gatewayCallbacks.max_poll_events !== null) maxev = gatewayCallbacks.max_poll_events;\n    if (maxev < 1) maxev = 1; // Token to use (only if the token based authentication mechanism is enabled)\n\n    var token = null;\n    if (gatewayCallbacks.token !== undefined && gatewayCallbacks.token !== null) token = gatewayCallbacks.token; // API secret to use (only if the shared API secret is enabled)\n\n    var apisecret = null;\n    if (gatewayCallbacks.apisecret !== undefined && gatewayCallbacks.apisecret !== null) apisecret = gatewayCallbacks.apisecret; // Whether we should destroy this session when onbeforeunload is called\n\n    this.destroyOnUnload = true;\n    if (gatewayCallbacks.destroyOnUnload !== undefined && gatewayCallbacks.destroyOnUnload !== null) this.destroyOnUnload = gatewayCallbacks.destroyOnUnload === true;\n    var connected = false; // var reconnected = false;\n    // var reconnecting = false;\n\n    var sessionId = null;\n    var pluginHandles = {};\n    var that = this;\n    var retries = 0;\n    var transactions = {};\n    createSession(gatewayCallbacks); // Public methods\n\n    this.getServer = function () {\n      return server;\n    };\n\n    this.isConnected = function () {\n      return connected;\n    };\n\n    this.getSessionId = function () {\n      return sessionId;\n    };\n\n    this.destroy = function (callbacks) {\n      destroySession(callbacks);\n    };\n\n    this.attach = function (callbacks) {\n      createHandle(callbacks);\n    };\n\n    this.timeoutSessionCallback = typeof gatewayCallbacks.timeoutSessionCallback == \"function\" ? gatewayCallbacks.timeoutSessionCallback : Janus.noop;\n\n    function eventHandler() {\n      if (sessionId == null) return;\n      Janus.debug('Long poll...');\n\n      if (!connected) {\n        Janus.warn(\"Is the gateway down? (connected=false)\");\n        return;\n      }\n\n      var longpoll = server + \"/\" + sessionId + \"?rid=\" + new Date().getTime();\n      if (maxev !== undefined && maxev !== null) longpoll = longpoll + \"&maxev=\" + maxev;\n      if (token !== null && token !== undefined) longpoll = longpoll + \"&token=\" + token;\n      if (apisecret !== null && apisecret !== undefined) longpoll = longpoll + \"&apisecret=\" + apisecret;\n      Janus.httpAPICall(longpoll, {\n        verb: 'GET',\n        withCredentials: withCredentials,\n        success: handleEvent,\n        timeout: 60000,\n        // FIXME\n        error: function error(textStatus, errorThrown) {\n          Janus.error(textStatus + \": \" + errorThrown);\n          retries++;\n\n          if (retries > 3) {\n            // Did we just lose the gateway? :-(\n            connected = false;\n            gatewayCallbacks.error(\"Lost connection to the gateway (is it down?)\");\n            return;\n          }\n\n          eventHandler();\n        }\n      });\n    } // Private event handler: this will trigger plugin callbacks, if set\n\n\n    function handleEvent(json, skipTimeout) {\n      retries = 0;\n      if (!websockets && sessionId !== undefined && sessionId !== null && skipTimeout !== true) setTimeout(eventHandler, 200);\n\n      if (!websockets && Janus.isArray(json)) {\n        // We got an array: it means we passed a maxev > 1, iterate on all objects\n        for (var i = 0; i < json.length; i++) {\n          handleEvent(json[i], true);\n        }\n\n        return;\n      }\n\n      if (json[\"janus\"] === \"keepalive\") {\n        // Nothing happened\n        Janus.vdebug(\"Got a keepalive on session \" + sessionId);\n        return;\n      } else if (json[\"janus\"] === \"ack\") {\n        // Just an ack, we can probably ignore\n        Janus.debug(\"Got an ack on session \" + sessionId);\n        Janus.debug(json);\n        var transaction = json[\"transaction\"];\n\n        if (transaction !== null && transaction !== undefined) {\n          var reportSuccess = transactions[transaction];\n\n          if (reportSuccess !== null && reportSuccess !== undefined) {\n            reportSuccess(json);\n          }\n\n          delete transactions[transaction];\n        }\n\n        return;\n      } else if (json[\"janus\"] === \"success\") {\n        // Success!\n        Janus.debug(\"Got a success on session \" + sessionId);\n        Janus.debug(json);\n        var transaction = json[\"transaction\"];\n\n        if (transaction !== null && transaction !== undefined) {\n          var reportSuccess = transactions[transaction];\n\n          if (reportSuccess !== null && reportSuccess !== undefined) {\n            reportSuccess(json);\n          }\n\n          delete transactions[transaction];\n        }\n\n        return;\n      } else if (json[\"janus\"] === \"webrtcup\") {\n        // The PeerConnection with the gateway is up! Notify this\n        Janus.debug(\"Got a webrtcup event on session \" + sessionId);\n        Janus.debug(json);\n        var sender = json[\"sender\"];\n\n        if (sender === undefined || sender === null) {\n          Janus.warn(\"Missing sender...\");\n          return;\n        }\n\n        var pluginHandle = pluginHandles[sender];\n\n        if (pluginHandle === undefined || pluginHandle === null) {\n          Janus.debug(\"This handle is not attached to this session\");\n          return;\n        }\n\n        pluginHandle.webrtcState(true);\n        return;\n      } else if (json[\"janus\"] === \"hangup\") {\n        // A plugin asked the core to hangup a PeerConnection on one of our handles\n        Janus.debug(\"Got a hangup event on session \" + sessionId);\n        Janus.debug(json);\n        var sender = json[\"sender\"];\n\n        if (sender === undefined || sender === null) {\n          Janus.warn(\"Missing sender...\");\n          return;\n        }\n\n        var pluginHandle = pluginHandles[sender];\n\n        if (pluginHandle === undefined || pluginHandle === null) {\n          Janus.debug(\"This handle is not attached to this session\");\n          return;\n        }\n\n        pluginHandle.webrtcState(false, json[\"reason\"]);\n        pluginHandle.hangup();\n      } else if (json[\"janus\"] === \"detached\") {\n        // A plugin asked the core to detach one of our handles\n        Janus.debug(\"Got a detached event on session \" + sessionId);\n        Janus.debug(json);\n        var sender = json[\"sender\"];\n\n        if (sender === undefined || sender === null) {\n          Janus.warn(\"Missing sender...\");\n          return;\n        }\n\n        var pluginHandle = pluginHandles[sender];\n\n        if (pluginHandle === undefined || pluginHandle === null) {\n          // Don't warn here because destroyHandle causes this situation.\n          return;\n        }\n\n        pluginHandle.detached = true;\n        pluginHandle.ondetached();\n        pluginHandle.detach();\n      } else if (json[\"janus\"] === \"media\") {\n        // Media started/stopped flowing\n        Janus.debug(\"Got a media event on session \" + sessionId);\n        Janus.debug(json);\n        var sender = json[\"sender\"];\n\n        if (sender === undefined || sender === null) {\n          Janus.warn(\"Missing sender...\");\n          return;\n        }\n\n        var pluginHandle = pluginHandles[sender];\n\n        if (pluginHandle === undefined || pluginHandle === null) {\n          Janus.debug(\"This handle is not attached to this session\");\n          return;\n        }\n\n        pluginHandle.mediaState(json[\"type\"], json[\"receiving\"]);\n      } else if (json[\"janus\"] === \"slowlink\") {\n        Janus.debug(\"Got a slowlink event on session \" + sessionId);\n        Janus.debug(json); // Trouble uplink or downlink\n\n        var sender = json[\"sender\"];\n\n        if (sender === undefined || sender === null) {\n          Janus.warn(\"Missing sender...\");\n          return;\n        }\n\n        var pluginHandle = pluginHandles[sender];\n\n        if (pluginHandle === undefined || pluginHandle === null) {\n          Janus.debug(\"This handle is not attached to this session\");\n          return;\n        }\n\n        pluginHandle.slowLink(json[\"uplink\"], json[\"nacks\"]);\n      } else if (json[\"janus\"] === \"error\") {\n        // Oops, something wrong happened\n        Janus.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason); // FIXME\n\n        Janus.debug(json);\n        var transaction = json[\"transaction\"];\n\n        if (transaction !== null && transaction !== undefined) {\n          var reportSuccess = transactions[transaction];\n\n          if (reportSuccess !== null && reportSuccess !== undefined) {\n            reportSuccess(json);\n          }\n\n          delete transactions[transaction];\n        }\n\n        return;\n      } else if (json[\"janus\"] === \"event\") {\n        Janus.debug(\"Got a plugin event on session \" + sessionId);\n        Janus.debug(json);\n        var sender = json[\"sender\"];\n\n        if (sender === undefined || sender === null) {\n          Janus.warn(\"Missing sender...\");\n          return;\n        }\n\n        var plugindata = json[\"plugindata\"];\n\n        if (plugindata === undefined || plugindata === null) {\n          Janus.warn(\"Missing plugindata...\");\n          return;\n        }\n\n        Janus.debug(\"  -- Event is coming from \" + sender + \" (\" + plugindata[\"plugin\"] + \")\");\n        var data = plugindata[\"data\"];\n        Janus.debug(data);\n        var pluginHandle = pluginHandles[sender];\n\n        if (pluginHandle === undefined || pluginHandle === null) {\n          Janus.warn(\"This handle is not attached to this session\");\n          return;\n        }\n\n        var jsep = json[\"jsep\"];\n\n        if (jsep !== undefined && jsep !== null) {\n          Janus.debug(\"Handling SDP as well...\");\n          Janus.debug(jsep);\n        }\n\n        var callback = pluginHandle.onmessage;\n\n        if (callback !== null && callback !== undefined) {\n          Janus.debug(\"Notifying application...\"); // Send to callback specified when attaching plugin handle\n\n          callback(data, jsep);\n        } else {\n          // Send to generic callback (?)\n          Janus.debug(\"No provided notification callback\");\n        }\n      } else if (json[\"janus\"] === \"timeout\") {\n        var sessionId = json[\"session_id\"];\n        var session = Janus.sessions[sessionId];\n\n        if (session) {\n          session.timeoutSessionCallback();\n        }\n      } else {\n        Janus.warn(\"Unkown message/event  '\" + json[\"janus\"] + \"' on session \" + sessionId);\n        Janus.debug(json);\n      }\n    } // Private helper to send keep-alive messages on WebSockets\n\n\n    function keepAlive() {\n      if (server === null || !websockets || !connected) return;\n      wsKeepaliveTimeoutId = setTimeout(keepAlive, 30000);\n      var request = {\n        \"janus\": \"keepalive\",\n        \"session_id\": sessionId,\n        \"transaction\": Janus.randomString(12)\n      };\n      if (token !== null && token !== undefined) request[\"token\"] = token;\n      if (apisecret !== null && apisecret !== undefined) request[\"apisecret\"] = apisecret;\n      ws.send(JSON.stringify(request));\n    } // Private method to create a session\n\n\n    function createSession(callbacks) {\n      var transaction = Janus.randomString(12);\n      var request = {\n        \"janus\": \"create\",\n        \"transaction\": transaction\n      };\n      if (token !== null && token !== undefined) request[\"token\"] = token;\n      if (apisecret !== null && apisecret !== undefined) request[\"apisecret\"] = apisecret;\n\n      if (server === null && Janus.isArray(servers)) {\n        // We still need to find a working server from the list we were given\n        server = servers[serversIndex];\n\n        if (server.indexOf(\"ws\") === 0) {\n          websockets = true;\n          Janus.log(\"Server #\" + (serversIndex + 1) + \": trying WebSockets to contact Janus (\" + server + \")\");\n        } else {\n          websockets = false;\n          Janus.log(\"Server #\" + (serversIndex + 1) + \": trying REST API to contact Janus (\" + server + \")\");\n        }\n      }\n\n      if (websockets) {\n        ws = Janus.newWebSocket(server, 'janus-protocol');\n        wsHandlers = {\n          'error': function error() {\n            console.warn(\"WS error\");\n            Janus.error(\"Error connecting to the Janus WebSockets server... \" + server);\n\n            if (Janus.isArray(servers)) {\n              serversIndex++;\n\n              if (serversIndex == servers.length) {\n                // We tried all the servers the user gave us and they all failed\n                callbacks.error(\"Error connecting to any of the provided Janus servers: Is the gateway down?\");\n                return;\n              } // Let's try the next server\n\n\n              server = null;\n              setTimeout(function () {\n                createSession(callbacks);\n              }, 200);\n              return;\n            }\n\n            callbacks.error(\"Error connecting to the Janus WebSockets server: Is the gateway down?\");\n          },\n          'open': function open() {\n            console.warn(\"WS connected\"); // if(reconnecting){\n            // \treconnecting = false;\n            // \treconnected = true;\n            // \tconsole.warn(\"WS reconnected\");\n            // }\n            // if(!reconnected){\n            // We need to be notified about the success\n\n            transactions[transaction] = function (json) {\n              Janus.debug(json);\n\n              if (json[\"janus\"] !== \"success\") {\n                Janus.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason); // FIXME\n\n                callbacks.error(json[\"error\"].reason);\n                return;\n              }\n\n              wsKeepaliveTimeoutId = setTimeout(keepAlive, 30000);\n              connected = true;\n              sessionId = json.data[\"id\"];\n              Janus.log(\"Created session: \" + sessionId);\n              Janus.sessions[sessionId] = that;\n              callbacks.success();\n            };\n\n            ws.send(JSON.stringify(request)); // }else{\n            // \tconnected = true;\n            // }\n          },\n          'message': function message(event) {\n            handleEvent(JSON.parse(event.data));\n          },\n          'close': function close() {\n            if (server === null || !connected) {\n              return;\n            } // if(connected){\n            // \treconnecting = false;\n            // }\n\n\n            connected = false; // reconnected = false;\n\n            console.warn(\"WS close\"); // // reconnection\n            // //\n            // // Try to reconnect in 5 seconds\n            // setTimeout(function(){\n            // \treconnecting = true;\n            // \tconsole.warn(\"WS reconnection\");\n            // \tcreateSession(callbacks);\n            // }, 2000);\n            // FIXME What if this is called when the page is closed?\n\n            gatewayCallbacks.error(\"Lost connection to the gateway (is it down?)\");\n          }\n        };\n\n        for (var eventName in wsHandlers) {\n          ws.addEventListener(eventName, wsHandlers[eventName]);\n        }\n\n        return;\n      }\n\n      Janus.httpAPICall(server, {\n        verb: 'POST',\n        withCredentials: withCredentials,\n        body: request,\n        success: function success(json) {\n          Janus.debug(json);\n\n          if (json[\"janus\"] !== \"success\") {\n            Janus.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason); // FIXME\n\n            callbacks.error(json[\"error\"].reason);\n            return;\n          }\n\n          connected = true;\n          sessionId = json.data[\"id\"];\n          Janus.log(\"Created session: \" + sessionId);\n          Janus.sessions[sessionId] = that;\n          eventHandler();\n          callbacks.success();\n        },\n        error: function error(textStatus, errorThrown) {\n          Janus.error(textStatus + \": \" + errorThrown); // FIXME\n\n          if (Janus.isArray(servers)) {\n            serversIndex++;\n\n            if (serversIndex == servers.length) {\n              // We tried all the servers the user gave us and they all failed\n              callbacks.error(\"Error connecting to any of the provided Janus servers: Is the gateway down?\");\n              return;\n            } // Let's try the next server\n\n\n            server = null;\n            setTimeout(function () {\n              createSession(callbacks);\n            }, 200);\n            return;\n          }\n\n          if (errorThrown === \"\") callbacks.error(textStatus + \": Is the gateway down?\");else callbacks.error(textStatus + \": \" + errorThrown);\n        }\n      });\n    } // Private method to destroy a session\n\n\n    function destroySession(callbacks) {\n      callbacks = callbacks || {}; // FIXME This method triggers a success even when we fail\n\n      callbacks.success = typeof callbacks.success == \"function\" ? callbacks.success : Janus.noop;\n      var asyncRequest = true;\n      if (callbacks.asyncRequest !== undefined && callbacks.asyncRequest !== null) asyncRequest = callbacks.asyncRequest === true;\n      Janus.log(\"Destroying session \" + sessionId + \" (async=\" + asyncRequest + \")\");\n\n      if (!connected) {\n        Janus.warn(\"Is the gateway down? (connected=false)\");\n        callbacks.success();\n        return;\n      }\n\n      if (sessionId === undefined || sessionId === null) {\n        Janus.warn(\"No session to destroy\");\n        callbacks.success();\n        gatewayCallbacks.destroyed();\n        return;\n      }\n\n      delete Janus.sessions[sessionId]; // No need to destroy all handles first, Janus will do that itself\n\n      var request = {\n        \"janus\": \"destroy\",\n        \"transaction\": Janus.randomString(12)\n      };\n      if (token !== null && token !== undefined) request[\"token\"] = token;\n      if (apisecret !== null && apisecret !== undefined) request[\"apisecret\"] = apisecret;\n\n      if (websockets) {\n        request[\"session_id\"] = sessionId;\n\n        var unbindWebSocket = function unbindWebSocket() {\n          for (var eventName in wsHandlers) {\n            ws.removeEventListener(eventName, wsHandlers[eventName]);\n          }\n\n          ws.removeEventListener('message', onUnbindMessage);\n          ws.removeEventListener('error', onUnbindError);\n\n          if (wsKeepaliveTimeoutId) {\n            clearTimeout(wsKeepaliveTimeoutId);\n          }\n\n          ws.close();\n        };\n\n        var onUnbindMessage = function onUnbindMessage(event) {\n          var data = JSON.parse(event.data);\n\n          if (data.session_id == request.session_id && data.transaction == request.transaction) {\n            unbindWebSocket();\n            callbacks.success();\n            gatewayCallbacks.destroyed();\n          }\n        };\n\n        var onUnbindError = function onUnbindError(event) {\n          unbindWebSocket();\n          callbacks.error(\"Failed to destroy the gateway: Is the gateway down?\");\n          gatewayCallbacks.destroyed();\n        };\n\n        ws.addEventListener('message', onUnbindMessage);\n        ws.addEventListener('error', onUnbindError);\n        ws.send(JSON.stringify(request));\n        return;\n      }\n\n      Janus.httpAPICall(server + \"/\" + sessionId, {\n        verb: 'POST',\n        async: asyncRequest,\n        // Sometimes we need false here, or destroying in onbeforeunload won't work\n        withCredentials: withCredentials,\n        body: request,\n        success: function success(json) {\n          Janus.log(\"Destroyed session:\");\n          Janus.debug(json);\n          sessionId = null;\n          connected = false;\n\n          if (json[\"janus\"] !== \"success\") {\n            Janus.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason); // FIXME\n          }\n\n          callbacks.success();\n          gatewayCallbacks.destroyed();\n        },\n        error: function error(textStatus, errorThrown) {\n          Janus.error(textStatus + \": \" + errorThrown); // FIXME\n          // Reset everything anyway\n\n          sessionId = null;\n          connected = false;\n          callbacks.success();\n          gatewayCallbacks.destroyed();\n        }\n      });\n    } // Private method to create a plugin handle\n\n\n    function createHandle(callbacks) {\n      callbacks = callbacks || {};\n      callbacks.success = typeof callbacks.success == \"function\" ? callbacks.success : Janus.noop;\n      callbacks.error = typeof callbacks.error == \"function\" ? callbacks.error : Janus.noop;\n      callbacks.consentDialog = typeof callbacks.consentDialog == \"function\" ? callbacks.consentDialog : Janus.noop;\n      callbacks.iceState = typeof callbacks.iceState == \"function\" ? callbacks.iceState : Janus.noop;\n      callbacks.mediaState = typeof callbacks.mediaState == \"function\" ? callbacks.mediaState : Janus.noop;\n      callbacks.webrtcState = typeof callbacks.webrtcState == \"function\" ? callbacks.webrtcState : Janus.noop;\n      callbacks.slowLink = typeof callbacks.slowLink == \"function\" ? callbacks.slowLink : Janus.noop;\n      callbacks.onmessage = typeof callbacks.onmessage == \"function\" ? callbacks.onmessage : Janus.noop;\n      callbacks.onlocalstream = typeof callbacks.onlocalstream == \"function\" ? callbacks.onlocalstream : Janus.noop;\n      callbacks.onremotestream = typeof callbacks.onremotestream == \"function\" ? callbacks.onremotestream : Janus.noop;\n      callbacks.ondata = typeof callbacks.ondata == \"function\" ? callbacks.ondata : Janus.noop;\n      callbacks.ondataopen = typeof callbacks.ondataopen == \"function\" ? callbacks.ondataopen : Janus.noop;\n      callbacks.oncleanup = typeof callbacks.oncleanup == \"function\" ? callbacks.oncleanup : Janus.noop;\n      callbacks.ondetached = typeof callbacks.ondetached == \"function\" ? callbacks.ondetached : Janus.noop;\n\n      if (!connected) {\n        Janus.warn(\"Is the gateway down? (connected=false)\");\n        callbacks.error(\"Is the gateway down? (connected=false)\");\n        return;\n      }\n\n      var plugin = callbacks.plugin;\n\n      if (plugin === undefined || plugin === null) {\n        Janus.error(\"Invalid plugin\");\n        callbacks.error(\"Invalid plugin\");\n        return;\n      }\n\n      var opaqueId = callbacks.opaqueId;\n      var transaction = Janus.randomString(12);\n      var request = {\n        \"janus\": \"attach\",\n        \"plugin\": plugin,\n        \"opaque_id\": opaqueId,\n        \"transaction\": transaction\n      };\n      if (token !== null && token !== undefined) request[\"token\"] = token;\n      if (apisecret !== null && apisecret !== undefined) request[\"apisecret\"] = apisecret; // If we know the browser supports BUNDLE and/or rtcp-mux, let's advertise those right away\n\n      if (Janus.webRTCAdapter.browserDetails.browser == \"chrome\" || Janus.webRTCAdapter.browserDetails.browser == \"firefox\" || Janus.webRTCAdapter.browserDetails.browser == \"safari\") {\n        request[\"force-bundle\"] = true;\n        request[\"force-rtcp-mux\"] = true;\n      }\n\n      if (websockets) {\n        transactions[transaction] = function (json) {\n          Janus.debug(json);\n\n          if (json[\"janus\"] !== \"success\") {\n            Janus.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason); // FIXME\n\n            callbacks.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason);\n            return;\n          }\n\n          var handleId = json.data[\"id\"];\n          Janus.log(\"Created handle: \" + handleId);\n          var pluginHandle = {\n            session: that,\n            plugin: plugin,\n            id: handleId,\n            detached: false,\n            webrtcStuff: {\n              started: false,\n              myStream: null,\n              streamExternal: false,\n              remoteStream: null,\n              mySdp: null,\n              mediaConstraints: null,\n              pc: null,\n              dataChannel: null,\n              dtmfSender: null,\n              trickle: true,\n              iceDone: false,\n              volume: {\n                value: null,\n                timer: null\n              },\n              bitrate: {\n                value: null,\n                bsnow: null,\n                bsbefore: null,\n                tsnow: null,\n                tsbefore: null,\n                timer: null\n              }\n            },\n            getId: function getId() {\n              return handleId;\n            },\n            getPlugin: function getPlugin() {\n              return plugin;\n            },\n            getVolume: function getVolume() {\n              return _getVolume(handleId);\n            },\n            isAudioMuted: function isAudioMuted() {\n              return isMuted(handleId, false);\n            },\n            muteAudio: function muteAudio() {\n              return mute(handleId, false, true);\n            },\n            unmuteAudio: function unmuteAudio() {\n              return mute(handleId, false, false);\n            },\n            isVideoMuted: function isVideoMuted() {\n              return isMuted(handleId, true);\n            },\n            muteVideo: function muteVideo() {\n              return mute(handleId, true, true);\n            },\n            unmuteVideo: function unmuteVideo() {\n              return mute(handleId, true, false);\n            },\n            getBitrate: function getBitrate() {\n              return _getBitrate(handleId);\n            },\n            send: function send(callbacks) {\n              sendMessage(handleId, callbacks);\n            },\n            data: function data(callbacks) {\n              sendData(handleId, callbacks);\n            },\n            dtmf: function dtmf(callbacks) {\n              sendDtmf(handleId, callbacks);\n            },\n            consentDialog: callbacks.consentDialog,\n            iceState: callbacks.iceState,\n            mediaState: callbacks.mediaState,\n            webrtcState: callbacks.webrtcState,\n            slowLink: callbacks.slowLink,\n            onmessage: callbacks.onmessage,\n            createOffer: function createOffer(callbacks) {\n              prepareWebrtc(handleId, callbacks);\n            },\n            createAnswer: function createAnswer(callbacks) {\n              prepareWebrtc(handleId, callbacks);\n            },\n            handleRemoteJsep: function handleRemoteJsep(callbacks) {\n              prepareWebrtcPeer(handleId, callbacks);\n            },\n            onlocalstream: callbacks.onlocalstream,\n            onremotestream: callbacks.onremotestream,\n            ondata: callbacks.ondata,\n            ondataopen: callbacks.ondataopen,\n            oncleanup: callbacks.oncleanup,\n            ondetached: callbacks.ondetached,\n            hangup: function hangup(sendRequest) {\n              cleanupWebrtc(handleId, sendRequest === true);\n            },\n            detach: function detach(callbacks) {\n              destroyHandle(handleId, callbacks);\n            }\n          };\n          pluginHandles[handleId] = pluginHandle;\n          callbacks.success(pluginHandle);\n        };\n\n        request[\"session_id\"] = sessionId;\n        ws.send(JSON.stringify(request));\n        return;\n      }\n\n      Janus.httpAPICall(server + \"/\" + sessionId, {\n        verb: 'POST',\n        withCredentials: withCredentials,\n        body: request,\n        success: function success(json) {\n          Janus.debug(json);\n\n          if (json[\"janus\"] !== \"success\") {\n            Janus.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason); // FIXME\n\n            callbacks.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason);\n            return;\n          }\n\n          var handleId = json.data[\"id\"];\n          Janus.log(\"Created handle: \" + handleId);\n          var pluginHandle = {\n            session: that,\n            plugin: plugin,\n            id: handleId,\n            detached: false,\n            webrtcStuff: {\n              started: false,\n              myStream: null,\n              streamExternal: false,\n              remoteStream: null,\n              mySdp: null,\n              mediaConstraints: null,\n              pc: null,\n              dataChannel: null,\n              dtmfSender: null,\n              trickle: true,\n              iceDone: false,\n              volume: {\n                value: null,\n                timer: null\n              },\n              bitrate: {\n                value: null,\n                bsnow: null,\n                bsbefore: null,\n                tsnow: null,\n                tsbefore: null,\n                timer: null\n              }\n            },\n            getId: function getId() {\n              return handleId;\n            },\n            getPlugin: function getPlugin() {\n              return plugin;\n            },\n            getVolume: function getVolume() {\n              return _getVolume(handleId);\n            },\n            isAudioMuted: function isAudioMuted() {\n              return isMuted(handleId, false);\n            },\n            muteAudio: function muteAudio() {\n              return mute(handleId, false, true);\n            },\n            unmuteAudio: function unmuteAudio() {\n              return mute(handleId, false, false);\n            },\n            isVideoMuted: function isVideoMuted() {\n              return isMuted(handleId, true);\n            },\n            muteVideo: function muteVideo() {\n              return mute(handleId, true, true);\n            },\n            unmuteVideo: function unmuteVideo() {\n              return mute(handleId, true, false);\n            },\n            getBitrate: function getBitrate() {\n              return _getBitrate(handleId);\n            },\n            send: function send(callbacks) {\n              sendMessage(handleId, callbacks);\n            },\n            data: function data(callbacks) {\n              sendData(handleId, callbacks);\n            },\n            dtmf: function dtmf(callbacks) {\n              sendDtmf(handleId, callbacks);\n            },\n            consentDialog: callbacks.consentDialog,\n            iceState: callbacks.iceState,\n            mediaState: callbacks.mediaState,\n            webrtcState: callbacks.webrtcState,\n            slowLink: callbacks.slowLink,\n            onmessage: callbacks.onmessage,\n            createOffer: function createOffer(callbacks) {\n              prepareWebrtc(handleId, callbacks);\n            },\n            createAnswer: function createAnswer(callbacks) {\n              prepareWebrtc(handleId, callbacks);\n            },\n            handleRemoteJsep: function handleRemoteJsep(callbacks) {\n              prepareWebrtcPeer(handleId, callbacks);\n            },\n            onlocalstream: callbacks.onlocalstream,\n            onremotestream: callbacks.onremotestream,\n            ondata: callbacks.ondata,\n            ondataopen: callbacks.ondataopen,\n            oncleanup: callbacks.oncleanup,\n            ondetached: callbacks.ondetached,\n            hangup: function hangup(sendRequest) {\n              cleanupWebrtc(handleId, sendRequest === true);\n            },\n            detach: function detach(callbacks) {\n              destroyHandle(handleId, callbacks);\n            }\n          };\n          pluginHandles[handleId] = pluginHandle;\n          callbacks.success(pluginHandle);\n        },\n        error: function error(textStatus, errorThrown) {\n          Janus.error(textStatus + \": \" + errorThrown); // FIXME\n        }\n      });\n    } // Private method to send a message\n\n\n    function sendMessage(handleId, callbacks) {\n      callbacks = callbacks || {};\n      callbacks.success = typeof callbacks.success == \"function\" ? callbacks.success : Janus.noop;\n      callbacks.error = typeof callbacks.error == \"function\" ? callbacks.error : Janus.noop;\n\n      if (!connected) {\n        Janus.warn(\"Is the gateway down? (connected=false)\");\n        callbacks.error(\"Is the gateway down? (connected=false)\");\n        return;\n      }\n\n      var message = callbacks.message;\n      var jsep = callbacks.jsep;\n      var transaction = Janus.randomString(12);\n      var request = {\n        \"janus\": \"message\",\n        \"body\": message,\n        \"transaction\": transaction\n      };\n      if (token !== null && token !== undefined) request[\"token\"] = token;\n      if (apisecret !== null && apisecret !== undefined) request[\"apisecret\"] = apisecret;\n      if (jsep !== null && jsep !== undefined) request.jsep = jsep;\n      Janus.debug(\"Sending message to plugin (handle=\" + handleId + \"):\");\n      Janus.debug(request);\n\n      if (websockets) {\n        request[\"session_id\"] = sessionId;\n        request[\"handle_id\"] = handleId;\n\n        transactions[transaction] = function (json) {\n          Janus.debug(\"Message sent!\");\n          Janus.debug(json);\n\n          if (json[\"janus\"] === \"success\") {\n            // We got a success, must have been a synchronous transaction\n            var plugindata = json[\"plugindata\"];\n\n            if (plugindata === undefined || plugindata === null) {\n              Janus.warn(\"Request succeeded, but missing plugindata...\");\n              callbacks.success();\n              return;\n            }\n\n            Janus.log(\"Synchronous transaction successful (\" + plugindata[\"plugin\"] + \")\");\n            var data = plugindata[\"data\"];\n            Janus.debug(data);\n            callbacks.success(data);\n            return;\n          } else if (json[\"janus\"] !== \"ack\") {\n            // Not a success and not an ack, must be an error\n            if (json[\"error\"] !== undefined && json[\"error\"] !== null) {\n              Janus.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason); // FIXME\n\n              callbacks.error(json[\"error\"].code + \" \" + json[\"error\"].reason);\n            } else {\n              Janus.error(\"Unknown error\"); // FIXME\n\n              callbacks.error(\"Unknown error\");\n            }\n\n            return;\n          } // If we got here, the plugin decided to handle the request asynchronously\n\n\n          callbacks.success();\n        };\n\n        ws.send(JSON.stringify(request));\n        return;\n      }\n\n      Janus.httpAPICall(server + \"/\" + sessionId + \"/\" + handleId, {\n        verb: 'POST',\n        withCredentials: withCredentials,\n        body: request,\n        success: function success(json) {\n          Janus.debug(\"Message sent!\");\n          Janus.debug(json);\n\n          if (json[\"janus\"] === \"success\") {\n            // We got a success, must have been a synchronous transaction\n            var plugindata = json[\"plugindata\"];\n\n            if (plugindata === undefined || plugindata === null) {\n              Janus.warn(\"Request succeeded, but missing plugindata...\");\n              callbacks.success();\n              return;\n            }\n\n            Janus.log(\"Synchronous transaction successful (\" + plugindata[\"plugin\"] + \")\");\n            var data = plugindata[\"data\"];\n            Janus.debug(data);\n            callbacks.success(data);\n            return;\n          } else if (json[\"janus\"] !== \"ack\") {\n            // Not a success and not an ack, must be an error\n            if (json[\"error\"] !== undefined && json[\"error\"] !== null) {\n              Janus.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason); // FIXME\n\n              callbacks.error(json[\"error\"].code + \" \" + json[\"error\"].reason);\n            } else {\n              Janus.error(\"Unknown error\"); // FIXME\n\n              callbacks.error(\"Unknown error\");\n            }\n\n            return;\n          } // If we got here, the plugin decided to handle the request asynchronously\n\n\n          callbacks.success();\n        },\n        error: function error(textStatus, errorThrown) {\n          Janus.error(textStatus + \": \" + errorThrown); // FIXME\n\n          callbacks.error(textStatus + \": \" + errorThrown);\n        }\n      });\n    } // Private method to send a trickle candidate\n\n\n    function sendTrickleCandidate(handleId, candidate) {\n      if (!connected) {\n        Janus.warn(\"Is the gateway down? (connected=false)\");\n        return;\n      }\n\n      var request = {\n        \"janus\": \"trickle\",\n        \"candidate\": candidate,\n        \"transaction\": Janus.randomString(12)\n      };\n      if (token !== null && token !== undefined) request[\"token\"] = token;\n      if (apisecret !== null && apisecret !== undefined) request[\"apisecret\"] = apisecret;\n      Janus.vdebug(\"Sending trickle candidate (handle=\" + handleId + \"):\");\n      Janus.vdebug(request);\n\n      if (websockets) {\n        request[\"session_id\"] = sessionId;\n        request[\"handle_id\"] = handleId;\n        ws.send(JSON.stringify(request));\n        return;\n      }\n\n      Janus.httpAPICall(server + \"/\" + sessionId + \"/\" + handleId, {\n        verb: 'POST',\n        withCredentials: withCredentials,\n        body: request,\n        success: function success(json) {\n          Janus.vdebug(\"Candidate sent!\");\n          Janus.vdebug(json);\n\n          if (json[\"janus\"] !== \"ack\") {\n            Janus.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason); // FIXME\n\n            return;\n          }\n        },\n        error: function error(textStatus, errorThrown) {\n          Janus.error(textStatus + \": \" + errorThrown); // FIXME\n        }\n      });\n    } // Private method to send a data channel message\n\n\n    function sendData(handleId, callbacks) {\n      callbacks = callbacks || {};\n      callbacks.success = typeof callbacks.success == \"function\" ? callbacks.success : Janus.noop;\n      callbacks.error = typeof callbacks.error == \"function\" ? callbacks.error : Janus.noop;\n      var pluginHandle = pluginHandles[handleId];\n\n      if (pluginHandle === null || pluginHandle === undefined || pluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n        Janus.warn(\"Invalid handle\");\n        callbacks.error(\"Invalid handle\");\n        return;\n      }\n\n      var config = pluginHandle.webrtcStuff;\n      var text = callbacks.text;\n\n      if (text === null || text === undefined) {\n        Janus.warn(\"Invalid text\");\n        callbacks.error(\"Invalid text\");\n        return;\n      }\n\n      Janus.log(\"Sending string on data channel: \" + text);\n      config.dataChannel.send(text);\n      callbacks.success();\n    } // Private method to send a DTMF tone\n\n\n    function sendDtmf(handleId, callbacks) {\n      callbacks = callbacks || {};\n      callbacks.success = typeof callbacks.success == \"function\" ? callbacks.success : Janus.noop;\n      callbacks.error = typeof callbacks.error == \"function\" ? callbacks.error : Janus.noop;\n      var pluginHandle = pluginHandles[handleId];\n\n      if (pluginHandle === null || pluginHandle === undefined || pluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n        Janus.warn(\"Invalid handle\");\n        callbacks.error(\"Invalid handle\");\n        return;\n      }\n\n      var config = pluginHandle.webrtcStuff;\n\n      if (config.dtmfSender === null || config.dtmfSender === undefined) {\n        // Create the DTMF sender, if possible\n        if (config.myStream !== undefined && config.myStream !== null) {\n          var tracks = config.myStream.getAudioTracks();\n\n          if (tracks !== null && tracks !== undefined && tracks.length > 0) {\n            var local_audio_track = tracks[0];\n            config.dtmfSender = config.pc.createDTMFSender(local_audio_track);\n            Janus.log(\"Created DTMF Sender\");\n\n            config.dtmfSender.ontonechange = function (tone) {\n              Janus.debug(\"Sent DTMF tone: \" + tone.tone);\n            };\n          }\n        }\n\n        if (config.dtmfSender === null || config.dtmfSender === undefined) {\n          Janus.warn(\"Invalid DTMF configuration\");\n          callbacks.error(\"Invalid DTMF configuration\");\n          return;\n        }\n      }\n\n      var dtmf = callbacks.dtmf;\n\n      if (dtmf === null || dtmf === undefined) {\n        Janus.warn(\"Invalid DTMF parameters\");\n        callbacks.error(\"Invalid DTMF parameters\");\n        return;\n      }\n\n      var tones = dtmf.tones;\n\n      if (tones === null || tones === undefined) {\n        Janus.warn(\"Invalid DTMF string\");\n        callbacks.error(\"Invalid DTMF string\");\n        return;\n      }\n\n      var duration = dtmf.duration;\n      if (duration === null || duration === undefined) duration = 500; // We choose 500ms as the default duration for a tone\n\n      var gap = dtmf.gap;\n      if (gap === null || gap === undefined) gap = 50; // We choose 50ms as the default gap between tones\n\n      Janus.debug(\"Sending DTMF string \" + tones + \" (duration \" + duration + \"ms, gap \" + gap + \"ms)\");\n      config.dtmfSender.insertDTMF(tones, duration, gap);\n    } // Private method to destroy a plugin handle\n\n\n    function destroyHandle(handleId, callbacks) {\n      callbacks = callbacks || {};\n      callbacks.success = typeof callbacks.success == \"function\" ? callbacks.success : Janus.noop;\n      callbacks.error = typeof callbacks.error == \"function\" ? callbacks.error : Janus.noop;\n      var asyncRequest = true;\n      if (callbacks.asyncRequest !== undefined && callbacks.asyncRequest !== null) asyncRequest = callbacks.asyncRequest === true;\n      Janus.log(\"Destroying handle \" + handleId + \" (async=\" + asyncRequest + \")\");\n      cleanupWebrtc(handleId);\n\n      if (pluginHandles[handleId].detached) {\n        // Plugin was already detached by Janus, calling detach again will return a handle not found error, so just exit here\n        delete pluginHandles[handleId];\n        callbacks.success();\n        return;\n      }\n\n      if (!connected) {\n        Janus.warn(\"Is the gateway down? (connected=false)\");\n        callbacks.error(\"Is the gateway down? (connected=false)\");\n        return;\n      }\n\n      var request = {\n        \"janus\": \"detach\",\n        \"transaction\": Janus.randomString(12)\n      };\n      if (token !== null && token !== undefined) request[\"token\"] = token;\n      if (apisecret !== null && apisecret !== undefined) request[\"apisecret\"] = apisecret;\n\n      if (websockets) {\n        request[\"session_id\"] = sessionId;\n        request[\"handle_id\"] = handleId;\n        ws.send(JSON.stringify(request));\n        delete pluginHandles[handleId];\n        callbacks.success();\n        return;\n      }\n\n      Janus.httpAPICall(server + \"/\" + sessionId + \"/\" + handleId, {\n        verb: 'POST',\n        async: asyncRequest,\n        // Sometimes we need false here, or destroying in onbeforeunload won't work\n        withCredentials: withCredentials,\n        body: request,\n        success: function success(json) {\n          Janus.log(\"Destroyed handle:\");\n          Janus.debug(json);\n\n          if (json[\"janus\"] !== \"success\") {\n            Janus.error(\"Ooops: \" + json[\"error\"].code + \" \" + json[\"error\"].reason); // FIXME\n          }\n\n          delete pluginHandles[handleId];\n          callbacks.success();\n        },\n        error: function error(textStatus, errorThrown) {\n          Janus.error(textStatus + \": \" + errorThrown); // FIXME\n          // We cleanup anyway\n\n          delete pluginHandles[handleId];\n          callbacks.success();\n        }\n      });\n    } // WebRTC stuff\n\n\n    function streamsDone(handleId, jsep, media, callbacks, stream) {\n      console.warn(\"streamsDone\", media);\n      var pluginHandle = pluginHandles[handleId];\n\n      if (pluginHandle === null || pluginHandle === undefined || pluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n        Janus.warn(\"Invalid handle\");\n        callbacks.error(\"Invalid handle\");\n        return;\n      }\n\n      var config = pluginHandle.webrtcStuff;\n      Janus.debug(\"streamsDone:\", stream);\n\n      if (stream) {\n        Janus.debug(\"  -- Audio tracks:\", stream.getAudioTracks());\n        Janus.debug(\"  -- Video tracks:\", stream.getVideoTracks());\n      } // If we're updating, check if we need to remove/replace one of the tracks\n\n\n      if (media.update && !config.streamExternal) {\n        if (media.removeAudio || media.replaceAudio) {\n          if (config.myStream && config.myStream.getAudioTracks() && config.myStream.getAudioTracks().length) {\n            Janus.log(\"Removing audio track:\", config.myStream.getAudioTracks()[0]);\n            config.myStream.removeTrack(config.myStream.getAudioTracks()[0]);\n          }\n\n          if (config.pc.getSenders() && config.pc.getSenders().length) {\n            for (var index in config.pc.getSenders()) {\n              var s = config.pc.getSenders()[index];\n\n              if (s && s.track && s.track.kind === \"audio\") {\n                Janus.log(\"Removing audio sender:\", s);\n                config.pc.removeTrack(s);\n              }\n            }\n          }\n        }\n\n        if (media.removeVideo || media.replaceVideo) {\n          if (config.myStream && config.myStream.getVideoTracks() && config.myStream.getVideoTracks().length) {\n            Janus.log(\"Removing video track:\", config.myStream.getVideoTracks()[0]);\n            config.myStream.removeTrack(config.myStream.getVideoTracks()[0]);\n          }\n\n          if (config.pc.getSenders() && config.pc.getSenders().length) {\n            for (var index in config.pc.getSenders()) {\n              var s = config.pc.getSenders()[index];\n\n              if (s && s.track && s.track.kind === \"video\") {\n                Janus.log(\"Removing video sender:\", s);\n                config.pc.removeTrack(s);\n              }\n            }\n          }\n        }\n      } // We're now capturing the new stream: check if we're updating or if it's a new thing\n\n\n      var addTracks = false;\n\n      if (!config.myStream || !media.update || config.streamExternal) {\n        config.myStream = stream;\n        addTracks = true;\n      } else {\n        // We only need to update the existing stream\n        if ((!media.update && isAudioSendEnabled(media) || media.update && (media.addAudio || media.replaceAudio)) && stream.getAudioTracks() && stream.getAudioTracks().length) {\n          Janus.log(\"Adding audio track:\", stream.getAudioTracks()[0]);\n          config.myStream.addTrack(stream.getAudioTracks()[0]);\n          config.pc.addTrack(stream.getAudioTracks()[0], stream);\n        }\n\n        if ((!media.update && isVideoSendEnabled(media) || media.update && (media.addVideo || media.replaceVideo)) && stream.getVideoTracks() && stream.getVideoTracks().length) {\n          Janus.log(\"Adding video track:\", stream.getVideoTracks()[0]);\n          config.myStream.addTrack(stream.getVideoTracks()[0]);\n          config.pc.addTrack(stream.getVideoTracks()[0], stream);\n        }\n      } // If we still need to create a PeerConnection, let's do that\n\n\n      if (!config.pc) {\n        var pc_config = {\n          \"iceServers\": iceServers,\n          \"iceTransportPolicy\": iceTransportPolicy,\n          \"bundlePolicy\": bundlePolicy\n        }; //~ var pc_constraints = {'mandatory': {'MozDontOfferDataChannel':true}};\n\n        var pc_constraints = {\n          \"optional\": [{\n            \"DtlsSrtpKeyAgreement\": true\n          }]\n        };\n\n        if (ipv6Support === true) {\n          // FIXME This is only supported in Chrome right now\n          // For support in Firefox track this: https://bugzilla.mozilla.org/show_bug.cgi?id=797262\n          pc_constraints.optional.push({\n            \"googIPv6\": true\n          });\n        } // Any custom constraint to add?\n\n\n        if (callbacks.rtcConstraints && typeof callbacks.rtcConstraints === 'object') {\n          Janus.debug(\"Adding custom PeerConnection constraints:\", callbacks.rtcConstraints);\n\n          for (var i in callbacks.rtcConstraints) {\n            pc_constraints.optional.push(callbacks.rtcConstraints[i]);\n          }\n        }\n\n        if (Janus.webRTCAdapter.browserDetails.browser === \"edge\") {\n          // This is Edge, enable BUNDLE explicitly\n          pc_config.bundlePolicy = \"max-bundle\";\n        }\n\n        Janus.log(\"Creating PeerConnection\");\n        Janus.debug(pc_constraints);\n        config.pc = new RTCPeerConnection(pc_config, pc_constraints);\n        Janus.debug(config.pc);\n\n        if (config.pc.getStats) {\n          // FIXME\n          config.volume.value = 0;\n          config.bitrate.value = \"0 kbits/sec\";\n        }\n\n        Janus.log(\"Preparing local SDP and gathering candidates (trickle=\" + config.trickle + \")\");\n\n        config.pc.oniceconnectionstatechange = function (e) {\n          if (config.pc) pluginHandle.iceState(config.pc.iceConnectionState);\n        };\n\n        config.pc.onicecandidate = function (event) {\n          if (event.candidate == null || Janus.webRTCAdapter.browserDetails.browser === 'edge' && event.candidate.candidate.indexOf('endOfCandidates') > 0) {\n            Janus.log(\"End of candidates.\");\n            config.iceDone = true;\n\n            if (config.trickle === true) {\n              // Notify end of candidates\n              sendTrickleCandidate(handleId, {\n                \"completed\": true\n              });\n            } else {\n              // No trickle, time to send the complete SDP (including all candidates)\n              sendSDP(handleId, callbacks);\n            }\n          } else {\n            // JSON.stringify doesn't work on some WebRTC objects anymore\n            // See https://code.google.com/p/chromium/issues/detail?id=467366\n            var candidate = {\n              \"candidate\": event.candidate.candidate,\n              \"sdpMid\": event.candidate.sdpMid,\n              \"sdpMLineIndex\": event.candidate.sdpMLineIndex\n            };\n\n            if (config.trickle === true) {\n              // Send candidate\n              sendTrickleCandidate(handleId, candidate);\n            }\n          }\n        };\n\n        config.pc.ontrack = function (event) {\n          Janus.log(\"Handling Remote Track\");\n          Janus.debug(event);\n          if (!event.streams) return;\n          config.remoteStream = event.streams[0];\n          pluginHandle.onremotestream(config.remoteStream);\n\n          if (event.track && !event.track.onended) {\n            Janus.log(\"Adding onended callback to track:\", event.track);\n\n            event.track.onended = function (ev) {\n              Janus.log(\"Remote track removed:\", ev);\n\n              if (config.remoteStream) {\n                config.remoteStream.removeTrack(ev.target);\n                pluginHandle.onremotestream(config.remoteStream);\n              }\n            };\n          }\n        };\n      }\n\n      if (addTracks && stream !== null && stream !== undefined) {\n        Janus.log('Adding local stream');\n        stream.getTracks().forEach(function (track) {\n          config.pc.addTrack(track, stream);\n        });\n      } // Any data channel to create?\n\n\n      if (isDataEnabled(media) && !config.dataChannel) {\n        Janus.log(\"Creating data channel\");\n\n        var onDataChannelMessage = function onDataChannelMessage(event) {\n          Janus.log('Received message on data channel: ' + event.data);\n          pluginHandle.ondata(event.data); // FIXME\n        };\n\n        var onDataChannelStateChange = function onDataChannelStateChange() {\n          var dcState = config.dataChannel !== null ? config.dataChannel.readyState : \"null\";\n          Janus.log('State change on data channel: ' + dcState);\n\n          if (dcState === 'open') {\n            pluginHandle.ondataopen(); // FIXME\n          }\n        };\n\n        var onDataChannelError = function onDataChannelError(error) {\n          Janus.error('Got error on data channel:', error); // TODO\n        }; // Until we implement the proxying of open requests within the Janus core, we open a channel ourselves whatever the case\n\n\n        config.dataChannel = config.pc.createDataChannel(\"JanusDataChannel\", {\n          ordered: false\n        }); // FIXME Add options (ordered, maxRetransmits, etc.)\n\n        config.dataChannel.onmessage = onDataChannelMessage;\n        config.dataChannel.onopen = onDataChannelStateChange;\n        config.dataChannel.onclose = onDataChannelStateChange;\n        config.dataChannel.onerror = onDataChannelError;\n      } // If there's a new local stream, let's notify the application\n\n\n      if (config.myStream) pluginHandle.onlocalstream(config.myStream); // Create offer/answer now\n\n      if (jsep === null || jsep === undefined) {\n        createOffer(handleId, media, callbacks);\n      } else {\n        config.pc.setRemoteDescription(new RTCSessionDescription(jsep), function () {\n          Janus.log(\"Remote description accepted!\");\n          createAnswer(handleId, media, callbacks);\n        }, callbacks.error);\n      }\n    }\n\n    function prepareWebrtc(handleId, callbacks) {\n      callbacks = callbacks || {};\n      callbacks.success = typeof callbacks.success == \"function\" ? callbacks.success : Janus.noop;\n      callbacks.error = typeof callbacks.error == \"function\" ? callbacks.error : webrtcError;\n      var jsep = callbacks.jsep;\n      callbacks.media = callbacks.media || {\n        audio: true,\n        video: true\n      };\n      var media = callbacks.media;\n      var pluginHandle = pluginHandles[handleId];\n\n      if (pluginHandle === null || pluginHandle === undefined || pluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n        Janus.warn(\"Invalid handle\");\n        callbacks.error(\"Invalid handle\");\n        return;\n      }\n\n      var config = pluginHandle.webrtcStuff; // Are we updating a session?\n\n      if (config.pc === undefined || config.pc === null) {\n        // Nope, new PeerConnection\n        media.update = false;\n      } else if (config.pc !== undefined && config.pc !== null) {\n        Janus.log(\"Updating existing media session\");\n        media.update = true; // Check if there's anything do add/remove/replace, or if we\n        // can go directly to preparing the new SDP offer or answer\n\n        if (callbacks.stream !== null && callbacks.stream !== undefined) {\n          // External stream: is this the same as the one we were using before?\n          if (callbacks.stream !== config.myStream) {\n            Janus.log(\"Renegotiation involves a new external stream\");\n          }\n        } else {\n          // Check if there are changes on audio\n          if (media.addAudio) {\n            media.replaceAudio = false;\n            media.removeAudio = false;\n            media.audioSend = true;\n\n            if (config.myStream && config.myStream.getAudioTracks() && config.myStream.getAudioTracks().length) {\n              Janus.error(\"Can't add audio stream, there already is one\");\n              callbacks.error(\"Can't add audio stream, there already is one\");\n              return;\n            }\n          } else if (media.removeAudio) {\n            media.replaceAudio = false;\n            media.addAudio = false;\n            media.audioSend = false;\n          } else if (media.replaceAudio) {\n            media.addAudio = false;\n            media.removeAudio = false;\n            media.audioSend = true;\n          }\n\n          if (config.myStream === null || config.myStream === undefined) {\n            // No media stream: if we were asked to replace, it's actually an \"add\"\n            if (media.replaceAudio) {\n              media.replaceAudio = false;\n              media.addAudio = true;\n              media.audioSend = true;\n            }\n\n            if (isAudioSendEnabled(media)) media.addAudio = true;\n          } else {\n            if (config.myStream.getAudioTracks() === null || config.myStream.getAudioTracks() === undefined || config.myStream.getAudioTracks().length === 0) {\n              // No audio track: if we were asked to replace, it's actually an \"add\"\n              if (media.replaceAudio) {\n                media.replaceAudio = false;\n                media.addAudio = true;\n                media.audioSend = true;\n              }\n\n              if (isAudioSendEnabled(media)) media.addAudio = true;\n            }\n          } // Check if there are changes on video\n\n\n          if (media.addVideo) {\n            media.replaceVideo = false;\n            media.removeVideo = false;\n            media.videoSend = true;\n\n            if (config.myStream && config.myStream.getVideoTracks() && config.myStream.getVideoTracks().length) {\n              Janus.error(\"Can't add video stream, there already is one\");\n              callbacks.error(\"Can't add video stream, there already is one\");\n              return;\n            }\n          } else if (media.removeVideo) {\n            media.replaceVideo = false;\n            media.addVideo = false;\n            media.videoSend = false;\n          } else if (media.replaceVideo) {\n            media.addVideo = false;\n            media.removeVideo = false;\n            media.videoSend = true;\n          }\n\n          if (config.myStream === null || config.myStream === undefined) {\n            // No media stream: if we were asked to replace, it's actually an \"add\"\n            if (media.replaceVideo) {\n              media.replaceVideo = false;\n              media.addVideo = true;\n              media.videoSend = true;\n            }\n\n            if (isVideoSendEnabled(media)) media.addVideo = true;\n          } else {\n            if (config.myStream.getVideoTracks() === null || config.myStream.getVideoTracks() === undefined || config.myStream.getVideoTracks().length === 0) {\n              // No video track: if we were asked to replace, it's actually an \"add\"\n              if (media.replaceVideo) {\n                media.replaceVideo = false;\n                media.addVideo = true;\n                media.videoSend = true;\n              }\n\n              if (isVideoSendEnabled(media)) media.addVideo = true;\n            }\n          } // Data channels can only be added\n\n\n          if (media.addData) media.data = true;\n        }\n      }\n\n      config.trickle = isTrickleEnabled(callbacks.trickle); // Was a MediaStream object passed, or do we need to take care of that?\n\n      if (callbacks.stream !== null && callbacks.stream !== undefined) {\n        var stream = callbacks.stream;\n        Janus.log(\"MediaStream provided by the application\");\n        Janus.debug(stream); // If this is an update, let's check if we need to release the previous stream\n\n        if (media.update) {\n          if (config.myStream && config.myStream !== callbacks.stream && !config.streamExternal) {\n            // We're replacing a stream we captured ourselves with an external one\n            try {\n              // Try a MediaStreamTrack.stop() for each track\n              var tracks = config.myStream.getTracks();\n\n              for (var i in tracks) {\n                var mst = tracks[i];\n                Janus.log(mst);\n                if (mst !== null && mst !== undefined) mst.stop();\n              }\n            } catch (e) {// Do nothing if this fails\n            }\n\n            config.myStream = null;\n          }\n        } // Skip the getUserMedia part\n\n\n        config.streamExternal = true;\n        streamsDone(handleId, jsep, media, callbacks, stream);\n        return;\n      }\n\n      if (isAudioSendEnabled(media) || isVideoSendEnabled(media)) {\n        var constraints = {\n          mandatory: {},\n          optional: []\n        };\n        pluginHandle.consentDialog(true);\n        var audioSupport = isAudioSendEnabled(media);\n\n        if (audioSupport === true && media != undefined && media != null) {\n          if (typeof media.audio === 'object') {\n            audioSupport = media.audio;\n          }\n        }\n\n        var videoSupport = isVideoSendEnabled(media);\n\n        if (videoSupport === true && media != undefined && media != null) {\n          var simulcast = callbacks.simulcast === true ? true : false;\n          if (simulcast && !jsep && (media.video === undefined || media.video === false)) media.video = \"hires\";\n\n          if (media.video && media.video != 'screen' && media.video != 'window') {\n            if (typeof media.video === 'object') {\n              videoSupport = media.video;\n            } else {\n              var width = 0;\n              var height = 0,\n                  maxHeight = 0;\n\n              if (media.video === 'lowres') {\n                // Small resolution, 4:3\n                height = 240;\n                maxHeight = 240;\n                width = 320;\n              } else if (media.video === 'lowres-16:9') {\n                // Small resolution, 16:9\n                height = 180;\n                maxHeight = 180;\n                width = 320;\n              } else if (media.video === 'hires' || media.video === 'hires-16:9' || media.video === 'hdres') {\n                // High(HD) resolution is only 16:9\n                height = 720;\n                maxHeight = 720;\n                width = 1280;\n              } else if (media.video === 'fhdres') {\n                // Full HD resolution is only 16:9\n                height = 1080;\n                maxHeight = 1080;\n                width = 1920;\n              } else if (media.video === '4kres') {\n                // 4K resolution is only 16:9\n                height = 2160;\n                maxHeight = 2160;\n                width = 3840;\n              } else if (media.video === 'stdres') {\n                // Normal resolution, 4:3\n                height = 480;\n                maxHeight = 480;\n                width = 640;\n              } else if (media.video === 'stdres-16:9') {\n                // Normal resolution, 16:9\n                height = 360;\n                maxHeight = 360;\n                width = 640;\n              } else {\n                Janus.log(\"Default video setting is stdres 4:3\");\n                height = 480;\n                maxHeight = 480;\n                width = 640;\n              }\n\n              Janus.log(\"Adding media constraint:\", media.video);\n              videoSupport = {\n                'height': {\n                  'ideal': height\n                },\n                'width': {\n                  'ideal': width\n                }\n              };\n\n              if (media.videoFrameRate) {\n                videoSupport[\"frameRate\"] = media.videoFrameRate;\n              }\n\n              Janus.debug(\"Adding video constraint:\", videoSupport);\n            }\n          } else if (media.video === 'screen' || media.video === 'window') {\n            var callbackUserMedia = function callbackUserMedia(error, stream) {\n              pluginHandle.consentDialog(false);\n\n              if (error) {\n                callbacks.error({\n                  code: error.code,\n                  name: error.name,\n                  message: error.message\n                });\n              } else {\n                streamsDone(handleId, jsep, media, callbacks, stream);\n              }\n            };\n\n            var getScreenMedia = function getScreenMedia(constraints, gsmCallback, useAudio) {\n              Janus.log(\"Adding media constraint (screen capture)\");\n              Janus.debug(constraints);\n              navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {\n                if (useAudio) {\n                  navigator.mediaDevices.getUserMedia({\n                    audio: true,\n                    video: false\n                  }).then(function (audioStream) {\n                    stream.addTrack(audioStream.getAudioTracks()[0]);\n                    gsmCallback(null, stream);\n                  });\n                } else {\n                  gsmCallback(null, stream);\n                }\n              }).catch(function (error) {\n                pluginHandle.consentDialog(false);\n                gsmCallback(error);\n              });\n            };\n\n            if (!media.screenshareFrameRate) {\n              media.screenshareFrameRate = 3;\n            } // Not a webcam, but screen capture\n\n\n            if (window.location.protocol !== 'https:') {\n              // Screen sharing mandates HTTPS\n              Janus.warn(\"Screen sharing only works on HTTPS, try the https:// version of this page\");\n              pluginHandle.consentDialog(false);\n              callbacks.error(\"Screen sharing only works on HTTPS, try the https:// version of this page\");\n              return;\n            } // We're going to try and use the extension for Chrome 34+, the old approach\n            // for older versions of Chrome, or the experimental support in Firefox 33+\n\n\n            var cache = {};\n\n            if (Janus.webRTCAdapter.browserDetails.browser === 'chrome') {\n              var chromever = Janus.webRTCAdapter.browserDetails.version;\n              var maxver = 33;\n              if (window.navigator.userAgent.match('Linux')) maxver = 35; // \"known\" crash in chrome 34 and 35 on linux\n\n              if (chromever >= 26 && chromever <= maxver) {\n                // Chrome 26->33 requires some awkward chrome://flags manipulation\n                constraints = {\n                  video: {\n                    mandatory: {\n                      googLeakyBucket: true,\n                      maxWidth: window.screen.width,\n                      maxHeight: window.screen.height,\n                      minFrameRate: media.screenshareFrameRate,\n                      maxFrameRate: media.screenshareFrameRate,\n                      chromeMediaSource: 'screen'\n                    }\n                  },\n                  audio: isAudioSendEnabled(media)\n                };\n                getScreenMedia(constraints, callbackUserMedia);\n              } else {\n                // Chrome 34+ requires an extension\n                var pending = window.setTimeout(function () {\n                  error = new Error('NavigatorUserMediaError');\n                  error.name = 'The required Chrome extension is not installed: click <a href=\"#\">here</a> to install it. (NOTE: this will need you to refresh the page)';\n                  pluginHandle.consentDialog(false);\n                  return callbacks.error(error);\n                }, 1000);\n                cache[pending] = [callbackUserMedia, null];\n                window.postMessage({\n                  type: 'janusGetScreen',\n                  id: pending\n                }, '*');\n              }\n            } else if (window.navigator.userAgent.match('Firefox')) {\n              var ffver = parseInt(window.navigator.userAgent.match(/Firefox\\/(.*)/)[1], 10);\n\n              if (ffver >= 33) {\n                // Firefox 33+ has experimental support for screen sharing\n                constraints = {\n                  video: {\n                    mozMediaSource: media.video,\n                    mediaSource: media.video\n                  },\n                  audio: isAudioSendEnabled(media)\n                };\n                getScreenMedia(constraints, function (err, stream) {\n                  callbackUserMedia(err, stream); // Workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=1045810\n\n                  if (!err) {\n                    var lastTime = stream.currentTime;\n                    var polly = window.setInterval(function () {\n                      if (!stream) window.clearInterval(polly);\n\n                      if (stream.currentTime == lastTime) {\n                        window.clearInterval(polly);\n\n                        if (stream.onended) {\n                          stream.onended();\n                        }\n                      }\n\n                      lastTime = stream.currentTime;\n                    }, 500);\n                  }\n                });\n              } else {\n                var error = new Error('NavigatorUserMediaError');\n                error.name = 'Your version of Firefox does not support screen sharing, please install Firefox 33 (or more recent versions)';\n                pluginHandle.consentDialog(false);\n                callbacks.error(error);\n                return;\n              }\n            } // Wait for events from the Chrome Extension\n\n\n            window.addEventListener('message', function (event) {\n              if (event.origin != window.location.origin) return;\n\n              if (event.data.type == 'janusGotScreen' && cache[event.data.id]) {\n                var data = cache[event.data.id];\n                var callback = data[0];\n                delete cache[event.data.id];\n\n                if (event.data.sourceId === '') {\n                  // user canceled\n                  var error = new Error('NavigatorUserMediaError');\n                  error.name = 'You cancelled the request for permission, giving up...';\n                  pluginHandle.consentDialog(false);\n                  callbacks.error(error);\n                } else {\n                  constraints = {\n                    audio: false,\n                    video: {\n                      mandatory: {\n                        chromeMediaSource: 'desktop',\n                        maxWidth: window.screen.width,\n                        maxHeight: window.screen.height,\n                        minFrameRate: media.screenshareFrameRate,\n                        maxFrameRate: media.screenshareFrameRate\n                      },\n                      optional: [{\n                        googLeakyBucket: true\n                      }, {\n                        googTemporalLayeredScreencast: true\n                      }]\n                    }\n                  };\n                  constraints.video.mandatory.chromeMediaSourceId = event.data.sourceId;\n                  getScreenMedia(constraints, callback, isAudioSendEnabled(media));\n                }\n              } else if (event.data.type == 'janusGetScreenPending') {\n                window.clearTimeout(event.data.id);\n              }\n            });\n            return;\n          }\n        } // If we got here, we're not screensharing\n\n\n        if (media === null || media === undefined || media.video !== 'screen') {\n          // Check whether all media sources are actually available or not\n          navigator.mediaDevices.enumerateDevices().then(function (devices) {\n            var audioExist = devices.some(function (device) {\n              return device.kind === 'audioinput';\n            }),\n                videoExist = devices.some(function (device) {\n              return device.kind === 'videoinput';\n            }); // Check whether a missing device is really a problem\n\n            var audioSend = isAudioSendEnabled(media);\n            var videoSend = isVideoSendEnabled(media);\n            var needAudioDevice = isAudioSendRequired(media);\n            var needVideoDevice = isVideoSendRequired(media);\n\n            if (audioSend || videoSend || needAudioDevice || needVideoDevice) {\n              // We need to send either audio or video\n              var haveAudioDevice = audioSend ? audioExist : false;\n              var haveVideoDevice = videoSend ? videoExist : false;\n\n              if (!haveAudioDevice && !haveVideoDevice) {\n                // FIXME Should we really give up, or just assume recvonly for both?\n                pluginHandle.consentDialog(false);\n                callbacks.error('No capture device found');\n                return false;\n              } else if (!haveAudioDevice && needAudioDevice) {\n                pluginHandle.consentDialog(false);\n                callbacks.error('Audio capture is required, but no capture device found');\n                return false;\n              } else if (!haveVideoDevice && needVideoDevice) {\n                pluginHandle.consentDialog(false);\n                callbacks.error('Video capture is required, but no capture device found');\n                return false;\n              }\n            }\n\n            navigator.mediaDevices.getUserMedia({\n              audio: audioExist ? audioSupport : false,\n              video: videoExist ? videoSupport : false\n            }).then(function (stream) {\n              var videoTrack = stream.getVideoTracks()[0];\n\n              if (videoTrack) {\n                Janus.debug(\"Video height: \" + videoTrack.getSettings().height);\n                Janus.debug(\"Video width: \" + videoTrack.getSettings().width);\n                Janus.debug(\"Video framerate: \" + videoTrack.getSettings().frameRate);\n              }\n\n              pluginHandle.consentDialog(false);\n              streamsDone(handleId, jsep, media, callbacks, stream);\n            }).catch(function (error) {\n              pluginHandle.consentDialog(false);\n              callbacks.error({\n                code: error.code,\n                name: error.name,\n                message: error.message\n              });\n            });\n          }).catch(function (error) {\n            pluginHandle.consentDialog(false);\n            callbacks.error('enumerateDevices error', error);\n          });\n        }\n      } else {\n        // No need to do a getUserMedia, create offer/answer right away\n        streamsDone(handleId, jsep, media, callbacks);\n      }\n    }\n\n    function prepareWebrtcPeer(handleId, callbacks) {\n      callbacks = callbacks || {};\n      callbacks.success = typeof callbacks.success == \"function\" ? callbacks.success : Janus.noop;\n      callbacks.error = typeof callbacks.error == \"function\" ? callbacks.error : webrtcError;\n      var jsep = callbacks.jsep;\n      var pluginHandle = pluginHandles[handleId];\n\n      if (pluginHandle === null || pluginHandle === undefined || pluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n        Janus.warn(\"Invalid handle\");\n        callbacks.error(\"Invalid handle\");\n        return;\n      }\n\n      var config = pluginHandle.webrtcStuff;\n\n      if (jsep !== undefined && jsep !== null) {\n        if (config.pc === null) {\n          Janus.warn(\"Wait, no PeerConnection?? if this is an answer, use createAnswer and not handleRemoteJsep\");\n          callbacks.error(\"No PeerConnection: if this is an answer, use createAnswer and not handleRemoteJsep\");\n          return;\n        }\n\n        config.pc.setRemoteDescription(new RTCSessionDescription(jsep), function () {\n          Janus.log(\"Remote description accepted!\");\n          callbacks.success();\n        }, callbacks.error);\n      } else {\n        callbacks.error(\"Invalid JSEP\");\n      }\n    }\n\n    function createOffer(handleId, media, callbacks) {\n      console.warn(\"createOffer:\", media);\n      callbacks = callbacks || {};\n      callbacks.success = typeof callbacks.success == \"function\" ? callbacks.success : Janus.noop;\n      callbacks.error = typeof callbacks.error == \"function\" ? callbacks.error : Janus.noop;\n      var pluginHandle = pluginHandles[handleId];\n\n      if (pluginHandle === null || pluginHandle === undefined || pluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n        Janus.warn(\"Invalid handle\");\n        callbacks.error(\"Invalid handle\");\n        return;\n      }\n\n      var config = pluginHandle.webrtcStuff;\n      var simulcast = callbacks.simulcast === true ? true : false;\n\n      if (!simulcast) {\n        Janus.log(\"Creating offer (iceDone=\" + config.iceDone + \")\");\n      } else {\n        Janus.log(\"Creating offer (iceDone=\" + config.iceDone + \", simulcast=\" + simulcast + \")\");\n      } // https://code.google.com/p/webrtc/issues/detail?id=3508\n\n\n      var mediaConstraints = {\n        'offerToReceiveAudio': isAudioRecvEnabled(media),\n        'offerToReceiveVideo': isVideoRecvEnabled(media)\n      };\n      var iceRestart = callbacks.iceRestart === true ? true : false;\n\n      if (iceRestart) {\n        mediaConstraints[\"iceRestart\"] = true;\n      }\n\n      Janus.debug(mediaConstraints); // Check if this is Firefox and we've been asked to do simulcasting\n\n      var sendVideo = isVideoSendEnabled(media);\n\n      if (sendVideo && simulcast && Janus.webRTCAdapter.browserDetails.browser === \"firefox\") {\n        // FIXME Based on https://gist.github.com/voluntas/088bc3cc62094730647b\n        Janus.log(\"Enabling Simulcasting for Firefox (RID)\");\n        var sender = config.pc.getSenders()[1];\n        Janus.log(sender);\n        var parameters = sender.getParameters();\n        Janus.log(parameters);\n        sender.setParameters({\n          encodings: [{\n            rid: \"high\",\n            active: true,\n            priority: \"high\",\n            maxBitrate: 1000000\n          }, {\n            rid: \"medium\",\n            active: true,\n            priority: \"medium\",\n            maxBitrate: 300000\n          }, {\n            rid: \"low\",\n            active: true,\n            priority: \"low\",\n            maxBitrate: 100000\n          }]\n        });\n      }\n\n      config.pc.createOffer(function (offer) {\n        Janus.debug(offer);\n        Janus.log(\"Setting local description\");\n\n        if (sendVideo && simulcast) {\n          // This SDP munging only works with Chrome\n          if (Janus.webRTCAdapter.browserDetails.browser === \"chrome\") {\n            Janus.log(\"Enabling Simulcasting for Chrome (SDP munging)\");\n            offer.sdp = mungeSdpForSimulcasting(offer.sdp);\n          } else if (Janus.webRTCAdapter.browserDetails.browser !== \"firefox\") {\n            Janus.warn(\"simulcast=true, but this is not Chrome nor Firefox, ignoring\");\n          }\n        }\n\n        config.mySdp = offer.sdp;\n        config.pc.setLocalDescription(offer);\n        config.mediaConstraints = mediaConstraints;\n\n        if (!config.iceDone && !config.trickle) {\n          // Don't do anything until we have all candidates\n          Janus.log(\"Waiting for all candidates...\");\n          return;\n        }\n\n        Janus.log(\"Offer ready\");\n        Janus.debug(callbacks); // JSON.stringify doesn't work on some WebRTC objects anymore\n        // See https://code.google.com/p/chromium/issues/detail?id=467366\n\n        var jsep = {\n          \"type\": offer.type,\n          \"sdp\": offer.sdp\n        };\n        callbacks.success(jsep);\n      }, callbacks.error, mediaConstraints);\n    }\n\n    function createAnswer(handleId, media, callbacks) {\n      callbacks = callbacks || {};\n      callbacks.success = typeof callbacks.success == \"function\" ? callbacks.success : Janus.noop;\n      callbacks.error = typeof callbacks.error == \"function\" ? callbacks.error : Janus.noop;\n      var pluginHandle = pluginHandles[handleId];\n\n      if (pluginHandle === null || pluginHandle === undefined || pluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n        Janus.warn(\"Invalid handle\");\n        callbacks.error(\"Invalid handle\");\n        return;\n      }\n\n      var config = pluginHandle.webrtcStuff;\n      var simulcast = callbacks.simulcast === true ? true : false;\n\n      if (!simulcast) {\n        Janus.log(\"Creating answer (iceDone=\" + config.iceDone + \")\");\n      } else {\n        Janus.log(\"Creating answer (iceDone=\" + config.iceDone + \", simulcast=\" + simulcast + \")\");\n      }\n\n      var mediaConstraints = null;\n\n      if (Janus.webRTCAdapter.browserDetails.browser == \"firefox\" || Janus.webRTCAdapter.browserDetails.browser == \"edge\") {\n        mediaConstraints = {\n          'offerToReceiveAudio': isAudioRecvEnabled(media),\n          'offerToReceiveVideo': isVideoRecvEnabled(media)\n        };\n      } else {\n        mediaConstraints = {\n          'mandatory': {\n            'OfferToReceiveAudio': isAudioRecvEnabled(media),\n            'OfferToReceiveVideo': isVideoRecvEnabled(media)\n          }\n        };\n      }\n\n      Janus.debug(mediaConstraints); // Check if this is Firefox and we've been asked to do simulcasting\n\n      var sendVideo = isVideoSendEnabled(media);\n\n      if (sendVideo && simulcast && Janus.webRTCAdapter.browserDetails.browser === \"firefox\") {\n        // FIXME Based on https://gist.github.com/voluntas/088bc3cc62094730647b\n        Janus.log(\"Enabling Simulcasting for Firefox (RID)\");\n        var sender = config.pc.getSenders()[1];\n        Janus.log(sender);\n        var parameters = sender.getParameters();\n        Janus.log(parameters);\n        sender.setParameters({\n          encodings: [{\n            rid: \"high\",\n            active: true,\n            priority: \"high\",\n            maxBitrate: 1000000\n          }, {\n            rid: \"medium\",\n            active: true,\n            priority: \"medium\",\n            maxBitrate: 300000\n          }, {\n            rid: \"low\",\n            active: true,\n            priority: \"low\",\n            maxBitrate: 100000\n          }]\n        });\n      }\n\n      config.pc.createAnswer(function (answer) {\n        Janus.debug(answer);\n        Janus.log(\"Setting local description\");\n\n        if (sendVideo && simulcast) {\n          // This SDP munging only works with Chrome\n          if (Janus.webRTCAdapter.browserDetails.browser === \"chrome\") {\n            // FIXME Apparently trying to simulcast when answering breaks video in Chrome...\n            //~ Janus.log(\"Enabling Simulcasting for Chrome (SDP munging)\");\n            //~ answer.sdp = mungeSdpForSimulcasting(answer.sdp);\n            Janus.warn(\"simulcast=true, but this is an answer, and video breaks in Chrome if we enable it\");\n          } else if (Janus.webRTCAdapter.browserDetails.browser !== \"firefox\") {\n            Janus.warn(\"simulcast=true, but this is not Chrome nor Firefox, ignoring\");\n          }\n        }\n\n        config.mySdp = answer.sdp;\n        config.pc.setLocalDescription(answer);\n        config.mediaConstraints = mediaConstraints;\n\n        if (!config.iceDone && !config.trickle) {\n          // Don't do anything until we have all candidates\n          Janus.log(\"Waiting for all candidates...\");\n          return;\n        } // JSON.stringify doesn't work on some WebRTC objects anymore\n        // See https://code.google.com/p/chromium/issues/detail?id=467366\n\n\n        var jsep = {\n          \"type\": answer.type,\n          \"sdp\": answer.sdp\n        };\n        callbacks.success(jsep);\n      }, callbacks.error, mediaConstraints);\n    }\n\n    function sendSDP(handleId, callbacks) {\n      callbacks = callbacks || {};\n      callbacks.success = typeof callbacks.success == \"function\" ? callbacks.success : Janus.noop;\n      callbacks.error = typeof callbacks.error == \"function\" ? callbacks.error : Janus.noop;\n      var pluginHandle = pluginHandles[handleId];\n\n      if (pluginHandle === null || pluginHandle === undefined || pluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n        Janus.warn(\"Invalid handle, not sending anything\");\n        return;\n      }\n\n      var config = pluginHandle.webrtcStuff;\n      Janus.log(\"Sending offer/answer SDP...\");\n\n      if (config.mySdp === null || config.mySdp === undefined) {\n        Janus.warn(\"Local SDP instance is invalid, not sending anything...\");\n        return;\n      }\n\n      config.mySdp = {\n        \"type\": config.pc.localDescription.type,\n        \"sdp\": config.pc.localDescription.sdp\n      };\n      if (config.trickle === false) config.mySdp[\"trickle\"] = false;\n      Janus.debug(callbacks);\n      config.sdpSent = true;\n      callbacks.success(config.mySdp);\n    }\n\n    function _getVolume(handleId) {\n      var pluginHandle = pluginHandles[handleId];\n\n      if (pluginHandle === null || pluginHandle === undefined || pluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n        Janus.warn(\"Invalid handle\");\n        return 0;\n      }\n\n      var config = pluginHandle.webrtcStuff; // Start getting the volume, if getStats is supported\n\n      if (config.pc.getStats && Janus.webRTCAdapter.browserDetails.browser == \"chrome\") {\n        // FIXME\n        if (config.remoteStream === null || config.remoteStream === undefined) {\n          Janus.warn(\"Remote stream unavailable\");\n          return 0;\n        } // http://webrtc.googlecode.com/svn/trunk/samples/js/demos/html/constraints-and-stats.html\n\n\n        if (config.volume.timer === null || config.volume.timer === undefined) {\n          Janus.log(\"Starting volume monitor\");\n          config.volume.timer = setInterval(function () {\n            config.pc.getStats(function (stats) {\n              var results = stats.result();\n\n              for (var i = 0; i < results.length; i++) {\n                var res = results[i];\n\n                if (res.type == 'ssrc' && res.stat('audioOutputLevel')) {\n                  config.volume.value = res.stat('audioOutputLevel');\n                }\n              }\n            });\n          }, 200);\n          return 0; // We don't have a volume to return yet\n        }\n\n        return config.volume.value;\n      } else {\n        Janus.log(\"Getting the remote volume unsupported by browser\");\n        return 0;\n      }\n    }\n\n    function isMuted(handleId, video) {\n      var pluginHandle = pluginHandles[handleId];\n\n      if (pluginHandle === null || pluginHandle === undefined || pluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n        Janus.warn(\"Invalid handle\");\n        return true;\n      }\n\n      var config = pluginHandle.webrtcStuff;\n\n      if (config.pc === null || config.pc === undefined) {\n        Janus.warn(\"Invalid PeerConnection\");\n        return true;\n      }\n\n      if (config.myStream === undefined || config.myStream === null) {\n        Janus.warn(\"Invalid local MediaStream\");\n        return true;\n      }\n\n      if (video) {\n        // Check video track\n        if (config.myStream.getVideoTracks() === null || config.myStream.getVideoTracks() === undefined || config.myStream.getVideoTracks().length === 0) {\n          Janus.warn(\"No video track\");\n          return true;\n        }\n\n        return !config.myStream.getVideoTracks()[0].enabled;\n      } else {\n        // Check audio track\n        if (config.myStream.getAudioTracks() === null || config.myStream.getAudioTracks() === undefined || config.myStream.getAudioTracks().length === 0) {\n          Janus.warn(\"No audio track\");\n          return true;\n        }\n\n        return !config.myStream.getAudioTracks()[0].enabled;\n      }\n    }\n\n    function mute(handleId, video, mute) {\n      var pluginHandle = pluginHandles[handleId];\n\n      if (pluginHandle === null || pluginHandle === undefined || pluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n        Janus.warn(\"Invalid handle\");\n        return false;\n      }\n\n      var config = pluginHandle.webrtcStuff;\n\n      if (config.pc === null || config.pc === undefined) {\n        Janus.warn(\"Invalid PeerConnection\");\n        return false;\n      }\n\n      if (config.myStream === undefined || config.myStream === null) {\n        Janus.warn(\"Invalid local MediaStream\");\n        return false;\n      }\n\n      if (video) {\n        // Mute/unmute video track\n        if (config.myStream.getVideoTracks() === null || config.myStream.getVideoTracks() === undefined || config.myStream.getVideoTracks().length === 0) {\n          Janus.warn(\"No video track\");\n          return false;\n        }\n\n        config.myStream.getVideoTracks()[0].enabled = mute ? false : true;\n        return true;\n      } else {\n        // Mute/unmute audio track\n        if (config.myStream.getAudioTracks() === null || config.myStream.getAudioTracks() === undefined || config.myStream.getAudioTracks().length === 0) {\n          Janus.warn(\"No audio track\");\n          return false;\n        }\n\n        config.myStream.getAudioTracks()[0].enabled = mute ? false : true;\n        return true;\n      }\n    }\n\n    function _getBitrate(handleId) {\n      var pluginHandle = pluginHandles[handleId];\n\n      if (pluginHandle === null || pluginHandle === undefined || pluginHandle.webrtcStuff === null || pluginHandle.webrtcStuff === undefined) {\n        Janus.warn(\"Invalid handle\");\n        return \"Invalid handle\";\n      }\n\n      var config = pluginHandle.webrtcStuff;\n      if (config.pc === null || config.pc === undefined) return \"Invalid PeerConnection\"; // Start getting the bitrate, if getStats is supported\n\n      if (config.pc.getStats) {\n        if (config.bitrate.timer === null || config.bitrate.timer === undefined) {\n          Janus.log(\"Starting bitrate timer (via getStats)\");\n          config.bitrate.timer = setInterval(function () {\n            config.pc.getStats().then(function (stats) {\n              stats.forEach(function (res) {\n                if (!res) return;\n                var inStats = false; // Check if these are statistics on incoming media\n\n                if ((res.mediaType === \"video\" || res.id.toLowerCase().indexOf(\"video\") > -1) && res.type === \"inbound-rtp\" && res.id.indexOf(\"rtcp\") < 0) {\n                  // New stats\n                  inStats = true;\n                } else if (res.type == 'ssrc' && res.bytesReceived && (res.googCodecName === \"VP8\" || res.googCodecName === \"\")) {\n                  // Older Chromer versions\n                  inStats = true;\n                } // Parse stats now\n\n\n                if (inStats) {\n                  config.bitrate.bsnow = res.bytesReceived;\n                  config.bitrate.tsnow = res.timestamp;\n\n                  if (config.bitrate.bsbefore === null || config.bitrate.tsbefore === null) {\n                    // Skip this round\n                    config.bitrate.bsbefore = config.bitrate.bsnow;\n                    config.bitrate.tsbefore = config.bitrate.tsnow;\n                  } else {\n                    // Calculate bitrate\n                    var timePassed = config.bitrate.tsnow - config.bitrate.tsbefore;\n                    if (Janus.webRTCAdapter.browserDetails.browser == \"safari\") timePassed = timePassed / 1000; // Apparently the timestamp is in microseconds, in Safari\n\n                    var bitRate = Math.round((config.bitrate.bsnow - config.bitrate.bsbefore) * 8 / timePassed);\n                    config.bitrate.value = bitRate + ' kbits/sec'; //~ Janus.log(\"Estimated bitrate is \" + config.bitrate.value);\n\n                    config.bitrate.bsbefore = config.bitrate.bsnow;\n                    config.bitrate.tsbefore = config.bitrate.tsnow;\n                  }\n                }\n              });\n            });\n          }, 1000);\n          return \"0 kbits/sec\"; // We don't have a bitrate value yet\n        }\n\n        return config.bitrate.value;\n      } else {\n        Janus.warn(\"Getting the video bitrate unsupported by browser\");\n        return \"Feature unsupported by browser\";\n      }\n    }\n\n    function webrtcError(error) {\n      Janus.error(\"WebRTC error:\", error);\n    }\n\n    function cleanupWebrtc(handleId, hangupRequest) {\n      Janus.log(\"Cleaning WebRTC stuff\");\n      var pluginHandle = pluginHandles[handleId];\n\n      if (pluginHandle === null || pluginHandle === undefined) {\n        // Nothing to clean\n        return;\n      }\n\n      var config = pluginHandle.webrtcStuff;\n\n      if (config !== null && config !== undefined) {\n        if (hangupRequest === true) {\n          // Send a hangup request (we don't really care about the response)\n          var request = {\n            \"janus\": \"hangup\",\n            \"transaction\": Janus.randomString(12)\n          };\n          if (token !== null && token !== undefined) request[\"token\"] = token;\n          if (apisecret !== null && apisecret !== undefined) request[\"apisecret\"] = apisecret;\n          Janus.debug(\"Sending hangup request (handle=\" + handleId + \"):\");\n          Janus.debug(request);\n\n          if (websockets) {\n            request[\"session_id\"] = sessionId;\n            request[\"handle_id\"] = handleId;\n            ws.send(JSON.stringify(request));\n          } else {\n            Janus.httpAPICall(server + \"/\" + sessionId + \"/\" + handleId, {\n              verb: 'POST',\n              withCredentials: withCredentials,\n              data: request\n            });\n          }\n        } // Cleanup stack\n\n\n        config.remoteStream = null;\n        if (config.volume.timer) clearInterval(config.volume.timer);\n        config.volume.value = null;\n        if (config.bitrate.timer) clearInterval(config.bitrate.timer);\n        config.bitrate.timer = null;\n        config.bitrate.bsnow = null;\n        config.bitrate.bsbefore = null;\n        config.bitrate.tsnow = null;\n        config.bitrate.tsbefore = null;\n        config.bitrate.value = null;\n\n        try {\n          // Try a MediaStreamTrack.stop() for each track\n          if (!config.streamExternal && config.myStream !== null && config.myStream !== undefined) {\n            Janus.log(\"Stopping local stream tracks\");\n            var tracks = config.myStream.getTracks();\n\n            for (var i in tracks) {\n              var mst = tracks[i];\n              Janus.log(mst);\n              if (mst !== null && mst !== undefined) mst.stop();\n            }\n          }\n        } catch (e) {// Do nothing if this fails\n        }\n\n        config.streamExternal = false;\n        config.myStream = null; // Close PeerConnection\n\n        try {\n          config.pc.close();\n        } catch (e) {// Do nothing\n        }\n\n        config.pc = null;\n        config.mySdp = null;\n        config.iceDone = false;\n        config.dataChannel = null;\n        config.dtmfSender = null;\n      }\n\n      pluginHandle.oncleanup();\n    } // Helper method to munge an SDP to enable simulcasting (Chrome only)\n\n\n    function mungeSdpForSimulcasting(sdp) {\n      // Let's munge the SDP to add the attributes for enabling simulcasting\n      // (based on https://gist.github.com/ggarber/a19b4c33510028b9c657)\n      var lines = sdp.split(\"\\r\\n\");\n      var video = false;\n      var ssrc = [-1],\n          ssrc_fid = -1;\n      var cname = null,\n          msid = null,\n          mslabel = null,\n          label = null;\n      var insertAt = -1;\n\n      for (var i = 0; i < lines.length; i++) {\n        var mline = lines[i].match(/m=(\\w+) */);\n\n        if (mline) {\n          var medium = mline[1];\n\n          if (medium === \"video\") {\n            // New video m-line: make sure it's the first one\n            if (ssrc[0] < 0) {\n              video = true;\n            } else {\n              // We're done, let's add the new attributes here\n              insertAt = i;\n              break;\n            }\n          } else {\n            // New non-video m-line: do we have what we were looking for?\n            if (ssrc[0] > -1) {\n              // We're done, let's add the new attributes here\n              insertAt = i;\n              break;\n            }\n          }\n\n          continue;\n        }\n\n        if (!video) continue;\n        var fid = lines[i].match(/a=ssrc-group:FID (\\d+) (\\d+)/);\n\n        if (fid) {\n          ssrc[0] = fid[1];\n          ssrc_fid = fid[2];\n          lines.splice(i, 1);\n          i--;\n          continue;\n        }\n\n        if (ssrc[0]) {\n          var match = lines[i].match('a=ssrc:' + ssrc[0] + ' cname:(.+)');\n\n          if (match) {\n            cname = match[1];\n          }\n\n          match = lines[i].match('a=ssrc:' + ssrc[0] + ' msid:(.+)');\n\n          if (match) {\n            msid = match[1];\n          }\n\n          match = lines[i].match('a=ssrc:' + ssrc[0] + ' mslabel:(.+)');\n\n          if (match) {\n            mslabel = match[1];\n          }\n\n          match = lines[i].match('a=ssrc:' + ssrc + ' label:(.+)');\n\n          if (match) {\n            label = match[1];\n          }\n\n          if (lines[i].indexOf('a=ssrc:' + ssrc_fid) === 0) {\n            lines.splice(i, 1);\n            i--;\n            continue;\n          }\n\n          if (lines[i].indexOf('a=ssrc:' + ssrc[0]) === 0) {\n            lines.splice(i, 1);\n            i--;\n            continue;\n          }\n        }\n\n        if (lines[i].length == 0) {\n          lines.splice(i, 1);\n          i--;\n          continue;\n        }\n      }\n\n      if (ssrc[0] < 0) {\n        // Couldn't find a FID attribute, let's just take the first video SSRC we find\n        insertAt = -1;\n        video = false;\n\n        for (var i = 0; i < lines.length; i++) {\n          var mline = lines[i].match(/m=(\\w+) */);\n\n          if (mline) {\n            var medium = mline[1];\n\n            if (medium === \"video\") {\n              // New video m-line: make sure it's the first one\n              if (ssrc[0] < 0) {\n                video = true;\n              } else {\n                // We're done, let's add the new attributes here\n                insertAt = i;\n                break;\n              }\n            } else {\n              // New non-video m-line: do we have what we were looking for?\n              if (ssrc[0] > -1) {\n                // We're done, let's add the new attributes here\n                insertAt = i;\n                break;\n              }\n            }\n\n            continue;\n          }\n\n          if (!video) continue;\n\n          if (ssrc[0] < 0) {\n            var value = lines[i].match(/a=ssrc:(\\d+)/);\n\n            if (value) {\n              ssrc[0] = value[1];\n              lines.splice(i, 1);\n              i--;\n              continue;\n            }\n          } else {\n            var match = lines[i].match('a=ssrc:' + ssrc[0] + ' cname:(.+)');\n\n            if (match) {\n              cname = match[1];\n            }\n\n            match = lines[i].match('a=ssrc:' + ssrc[0] + ' msid:(.+)');\n\n            if (match) {\n              msid = match[1];\n            }\n\n            match = lines[i].match('a=ssrc:' + ssrc[0] + ' mslabel:(.+)');\n\n            if (match) {\n              mslabel = match[1];\n            }\n\n            match = lines[i].match('a=ssrc:' + ssrc + ' label:(.+)');\n\n            if (match) {\n              label = match[1];\n            }\n\n            if (lines[i].indexOf('a=ssrc:' + ssrc_fid) === 0) {\n              lines.splice(i, 1);\n              i--;\n              continue;\n            }\n\n            if (lines[i].indexOf('a=ssrc:' + ssrc[0]) === 0) {\n              lines.splice(i, 1);\n              i--;\n              continue;\n            }\n          }\n\n          if (lines[i].length == 0) {\n            lines.splice(i, 1);\n            i--;\n            continue;\n          }\n        }\n      }\n\n      if (ssrc[0] < 0) {\n        // Still nothing, let's just return the SDP we were asked to munge\n        Janus.warn(\"Couldn't find the video SSRC, simulcasting NOT enabled\");\n        return sdp;\n      }\n\n      if (insertAt < 0) {\n        // Append at the end\n        insertAt = lines.length;\n      } // Generate a couple of SSRCs\n\n\n      ssrc[1] = Math.floor(Math.random() * 0xFFFFFFFF);\n      ssrc[2] = Math.floor(Math.random() * 0xFFFFFFFF); // Add attributes to the SDP\n\n      for (var i = 0; i < ssrc.length; i++) {\n        if (cname) {\n          lines.splice(insertAt, 0, 'a=ssrc:' + ssrc[i] + ' cname:' + cname);\n          insertAt++;\n        }\n\n        if (msid) {\n          lines.splice(insertAt, 0, 'a=ssrc:' + ssrc[i] + ' msid:' + msid);\n          insertAt++;\n        }\n\n        if (mslabel) {\n          lines.splice(insertAt, 0, 'a=ssrc:' + ssrc[i] + ' mslabel:' + msid);\n          insertAt++;\n        }\n\n        if (label) {\n          lines.splice(insertAt, 0, 'a=ssrc:' + ssrc[i] + ' label:' + msid);\n          insertAt++;\n        }\n      }\n\n      lines.splice(insertAt, 0, 'a=ssrc-group:SIM ' + ssrc[0] + ' ' + ssrc[1] + ' ' + ssrc[2]);\n      sdp = lines.join(\"\\r\\n\");\n      if (!sdp.endsWith(\"\\r\\n\")) sdp += \"\\r\\n\";\n      return sdp;\n    } // Helper methods to parse a media object\n\n\n    function isAudioSendEnabled(media) {\n      Janus.debug(\"isAudioSendEnabled:\", media);\n      if (media === undefined || media === null) return true; // Default\n\n      if (media.audio === false) return false; // Generic audio has precedence\n\n      if (media.audioSend === undefined || media.audioSend === null) return true; // Default\n\n      return media.audioSend === true;\n    }\n\n    function isAudioSendRequired(media) {\n      Janus.debug(\"isAudioSendRequired:\", media);\n      if (media === undefined || media === null) return false; // Default\n\n      if (media.audio === false || media.audioSend === false) return false; // If we're not asking to capture audio, it's not required\n\n      if (media.failIfNoAudio === undefined || media.failIfNoAudio === null) return false; // Default\n\n      return media.failIfNoAudio === true;\n    }\n\n    function isAudioRecvEnabled(media) {\n      Janus.debug(\"isAudioRecvEnabled:\", media);\n      if (media === undefined || media === null) return true; // Default\n\n      if (media.audio === false) return false; // Generic audio has precedence\n\n      if (media.audioRecv === undefined || media.audioRecv === null) return true; // Default\n\n      return media.audioRecv === true;\n    }\n\n    function isVideoSendEnabled(media) {\n      Janus.debug(\"isVideoSendEnabled:\", media);\n      if (media === undefined || media === null) return true; // Default\n\n      if (media.video === false) return false; // Generic video has precedence\n\n      if (media.videoSend === undefined || media.videoSend === null) return true; // Default\n\n      return media.videoSend === true;\n    }\n\n    function isVideoSendRequired(media) {\n      Janus.debug(\"isVideoSendRequired:\", media);\n      if (media === undefined || media === null) return false; // Default\n\n      if (media.video === false || media.videoSend === false) return false; // If we're not asking to capture video, it's not required\n\n      if (media.failIfNoVideo === undefined || media.failIfNoVideo === null) return false; // Default\n\n      return media.failIfNoVideo === true;\n    }\n\n    function isVideoRecvEnabled(media) {\n      Janus.debug(\"isVideoRecvEnabled:\", media);\n      if (media === undefined || media === null) return true; // Default\n\n      if (media.video === false) return false; // Generic video has precedence\n\n      if (media.videoRecv === undefined || media.videoRecv === null) return true; // Default\n\n      return media.videoRecv === true;\n    }\n\n    function isDataEnabled(media) {\n      Janus.debug(\"isDataEnabled:\", media);\n\n      if (Janus.webRTCAdapter.browserDetails.browser == \"edge\") {\n        Janus.warn(\"Edge doesn't support data channels yet\");\n        return false;\n      }\n\n      if (media === undefined || media === null) return false; // Default\n\n      return media.data === true;\n    }\n\n    function isTrickleEnabled(trickle) {\n      Janus.debug(\"isTrickleEnabled:\", trickle);\n      if (trickle === undefined || trickle === null) return true; // Default is true\n\n      return trickle === true;\n    }\n  }\n\n  return Janus;\n});","map":null,"metadata":{},"sourceType":"script"}