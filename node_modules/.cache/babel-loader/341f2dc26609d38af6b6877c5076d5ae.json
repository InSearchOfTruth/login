{"ast":null,"code":"'use strict';\n\nvar Config = require('../cubeConfig'),\n    Utils = require('../cubeInternalUtils'),\n    ChatUtils = require('./cubeChatInternalUtils'),\n    ChatHelpers = require('./cubeChatHelpers'),\n    StreamManagement = require('./cubeStreamManagement'),\n    ContactListProxy = require('./cubeContactList'),\n    PrivacyListProxy = require('./cubePrivacyList'),\n    MucProxy = require('./cubeMultiUserChat'),\n    XMPPClient = require('../cubeDependencies').XMPPClient;\n\nif (Utils.getEnv().browser) {\n  Strophe.addNamespace('CARBONS', ChatUtils.MARKERS.CARBONS);\n  Strophe.addNamespace('CHAT_MARKERS', ChatUtils.MARKERS.CHAT);\n  Strophe.addNamespace('PRIVACY_LIST', ChatUtils.MARKERS.PRIVACY);\n  Strophe.addNamespace('CHAT_STATES', ChatUtils.MARKERS.STATES);\n}\n\nfunction ChatProxy(service) {\n  var self = this;\n  self.webrtcSignalingProcessor = null;\n  /**\n   * Browser env.\n   * Uses by Strophe\n   */\n\n  if (Utils.getEnv().browser) {\n    self.xmppClient = new XMPPClient();\n    /** Add extension methods to track handlers for removal on reconnect */\n\n    self.xmppClient.XHandlerReferences = [];\n\n    self.xmppClient.XAddTrackedHandler = function (handler, ns, name, type, id, from, options) {\n      self.xmppClient.XHandlerReferences.push(self.xmppClient.addHandler(handler, ns, name, type, id, from, options));\n    };\n\n    self.xmppClient.XDeleteHandlers = function () {\n      while (self.xmppClient.XHandlerReferences.length) {\n        self.xmppClient.deleteHandler(self.xmppClient.XHandlerReferences.pop());\n      }\n    };\n  } else {\n    // nativescript-xmpp-client\n    if (Utils.getEnv().nativescript) {\n      self.xmppClient = new XMPPClient.Client({\n        websocket: {\n          url: Config.chatProtocol.websocket\n        },\n        autostart: false\n      }); // node-xmpp-client\n    } else if (Utils.getEnv().node) {\n      self.xmppClient = new XMPPClient({\n        autostart: false\n      });\n    } else if (Utils.getEnv().reactnative) {\n      self.xmppClient = XMPPClient.client({\n        service: Config.chatProtocol.websocket,\n        credentials: function authenticate(auth, mechanism) {\n          var crds = {\n            username: self.xmppClient.cbUserName,\n            password: self.xmppClient.cbUserPassword\n          };\n          return auth(crds);\n        }\n      });\n    } // override 'send' function to add 'SENT' logs\n\n\n    if (Utils.getEnv().node || Utils.getEnv().nativescript) {\n      var originSendFunction = self.xmppClient.send;\n\n      self.xmppClient.send = function (stanza) {\n        Utils.DLog('[Chat]', 'SENT:', stanza.toString());\n        originSendFunction.call(self.xmppClient, stanza);\n      };\n    }\n\n    self.nodeStanzasCallbacks = {};\n  }\n\n  this.service = service; // Check the chat connection (return true/false)\n\n  this.isConnected = false; // Check the chat connecting state (return true/false)\n\n  this._isConnecting = false;\n  this._isLogout = false;\n  this._checkConnectionTimer = undefined;\n  this.helpers = new ChatHelpers();\n  this.xmppClientListeners = []; // Chat additional modules\n\n  var options = {\n    xmppClient: self.xmppClient,\n    helpers: self.helpers,\n    nodeStanzasCallbacks: self.nodeStanzasCallbacks\n  };\n  this.contactList = new ContactListProxy(options);\n  this.privacylist = new PrivacyListProxy(options);\n  this.muc = new MucProxy(options);\n\n  if (Config.chat.streamManagement.enable) {\n    if (Config.chatProtocol.active === 2) {\n      this.streamManagement = new StreamManagement();\n\n      self._sentMessageCallback = function (messageLost, messageSent) {\n        if (typeof self.onSentMessageCallback === 'function') {\n          if (messageSent) {\n            self.onSentMessageCallback(null, messageSent);\n          } else {\n            self.onSentMessageCallback(messageLost);\n          }\n        }\n      };\n    } else {\n      Utils.DLog('[Chat] StreamManagement:', 'BOSH protocol doesn\\'t support stream management. Set WebSocket as the \"chatProtocol\" parameter to use this functionality.');\n    }\n  }\n  /**\n   * User's callbacks (listener-functions):\n   * - onMessageListener (userId, message)\n   * - onMessageErrorListener (messageId, error)\n   * - onSentMessageCallback (messageLost, messageSent)\n   * - onMessageTypingListener (isTyping, userId, dialogId)\n   * - onDeliveredStatusListener (messageId, dialogId, userId);\n   * - onReadStatusListener (messageId, dialogId, userId);\n   * - onSystemMessageListener (message)\n   * - onKickOccupant(dialogId, initiatorUserId)\n   * - onJoinOccupant(dialogId, userId)\n   * - onLeaveOccupant(dialogId, userId)\n   * - onContactListListener (userId, type)\n   * - onSubscribeListener (userId)\n   * - onConfirmSubscribeListener (userId)\n   * - onRejectSubscribeListener (userId)\n   * - onLastUserActivityListener (userId, seconds)\n   * - onDisconnectedListener\n   * - onReconnectListener\n   */\n\n  /**\n   * You need to set onMessageListener function, to get messages.\n   * @function onMessageListener\n   * @memberOf CB.chat\n   * @param {Number} userId - Sender id\n   * @param {Object} message - The message model object\n   **/\n\n  /**\n   * Blocked entities receive an error when try to chat with a user in a 1-1 chat and receivie nothing in a group chat.\n   * @function onMessageErrorListener\n   * @memberOf CB.chat\n   * @param {Number} messageId - The message id\n   * @param {Object} error - The error object\n   **/\n\n  /**\n   * This feature defines an approach for ensuring is the message delivered to the server. This feature is unabled by default.\n   * @function onSentMessageCallback\n   * @memberOf CB.chat\n   * @param {Object} messageLost - The lost message model object (Fail)\n   * @param {Object} messageSent - The sent message model object (Success)\n   **/\n\n  /**\n   * Show typing status in chat or groupchat.\n   * @function onMessageTypingListener\n   * @memberOf CB.chat\n   * @param {Boolean} isTyping - Typing Status (true - typing, false - stop typing)\n   * @param {Number} userId - Typing user id\n   * @param {String} dialogId - The dialog id\n   **/\n\n  /**\n   * Receive delivery confirmations.\n   * @function onDeliveredStatusListener\n   * @memberOf CB.chat\n   * @param {String} messageId - Delivered message id\n   * @param {String} dialogId - The dialog id\n   * @param {Number} userId - User id\n   **/\n\n  /**\n   * You can manage 'read' notifications in chat.\n   * @function onReadStatusListener\n   * @memberOf CB.chat\n   * @param {String} messageId - Read message id\n   * @param {String} dialogId - The dialog id\n   * @param {Number} userId - User Id\n   **/\n\n  /**\n   * These messages work over separated channel and won't be mixed with the regular chat messages.\n   * @function onSystemMessageListener\n   * @memberOf CB.chat\n   * @param {Object} message - The system message model object. Always have type: 'headline'\n   **/\n\n  /**\n   * You will receive this callback when you are in group chat dialog(joined) and other user (chat dialog's creator) removed you from occupants.\n   * @function onKickOccupant\n   * @memberOf CB.chat\n   * @param {String} dialogId - An id of chat dialog where you was kicked from.\n   * @param {Number} initiatorUserId - An id of user who has kicked you.\n   **/\n\n  /**\n   * You will receive this callback when some user joined group chat dialog you are in.\n   * @function onJoinOccupant\n   * @memberOf CB.chat\n   * @param {String} dialogId - An id of chat dialog that user joined.\n   * @param {Number} userId - An id of user who joined chat dialog.\n   **/\n\n  /**\n   * You will receive this callback when some user left group chat dialog you are in.\n   * @function onLeaveOccupant\n   * @memberOf CB.chat\n   * @param {String} dialogId - An id of chat dialog that user left.\n   * @param {Number} userId - An id of user who left chat dialog.\n   **/\n\n  /**\n   * Receive user status (online / offline).\n   * @function onContactListListener\n   * @memberOf CB.chat\n   * @param {Number} userId - The sender ID\n   * @param {String} type - If user leave the chat, type will be 'unavailable'\n   **/\n\n  /**\n   * Receive subscription request.\n   * @function onSubscribeListener\n   * @memberOf CB.chat\n   * @param {Number} userId - The sender ID\n   **/\n\n  /**\n   * Receive confirm request.\n   * @function onConfirmSubscribeListener\n   * @memberOf CB.chat\n   * @param {Number} userId - The sender ID\n   **/\n\n  /**\n   * Receive reject request.\n   * @function onRejectSubscribeListener\n   * @memberOf CB.chat\n   * @param {Number} userId - The sender ID\n   **/\n\n  /**\n   * Receive user's last activity (time ago). {@link https://xmpp.org/extensions/xep-0012.html More info.}\n   * @function onLastUserActivityListener\n   * @memberOf CB.chat\n   * @param {Number} userId - The user's ID which last activity time we receive\n   * @param {Number} seconds - Time ago (last activity in seconds or 0 if user online or undefined if user never registered in chat)\n   */\n\n  /**\n   * Run after disconnect from chat.\n   * @function onDisconnectedListener\n   * @memberOf CB.chat\n   **/\n\n  /**\n   * By default Javascript SDK reconnects automatically when connection to server is lost.\n   * @function onReconnectListener\n   * @memberOf CB.chat\n   **/\n\n\n  this._onMessage = function (stanza) {\n    var from = ChatUtils.getAttr(stanza, 'from'),\n        type = ChatUtils.getAttr(stanza, 'type'),\n        messageId = ChatUtils.getAttr(stanza, 'id'),\n        markable = ChatUtils.getElement(stanza, 'markable'),\n        delivered = ChatUtils.getElement(stanza, 'received'),\n        read = ChatUtils.getElement(stanza, 'displayed'),\n        composing = ChatUtils.getElement(stanza, 'composing'),\n        paused = ChatUtils.getElement(stanza, 'paused'),\n        invite = ChatUtils.getElement(stanza, 'invite'),\n        delay = ChatUtils.getElement(stanza, 'delay'),\n        extraParams = ChatUtils.getElement(stanza, 'extraParams'),\n        bodyContent = ChatUtils.getElementText(stanza, 'body'),\n        forwarded = ChatUtils.getElement(stanza, 'forwarded'),\n        extraParamsParsed,\n        recipientId,\n        recipient;\n    var forwardedMessage = forwarded ? ChatUtils.getElement(forwarded, 'message') : null;\n    recipient = forwardedMessage ? ChatUtils.getAttr(forwardedMessage, 'to') : null;\n    recipientId = recipient ? self.helpers.getIdFromNode(recipient) : null;\n    var dialogId = type === 'groupchat' ? self.helpers.getDialogIdFromNode(from) : null,\n        userId = type === 'groupchat' ? self.helpers.getIdFromResource(from) : self.helpers.getIdFromNode(from),\n        marker = delivered || read || null; // ignore invite messages from MUC\n\n    if (invite) return true;\n\n    if (extraParams) {\n      extraParamsParsed = ChatUtils.parseExtraParams(extraParams);\n\n      if (extraParamsParsed.dialogId) {\n        dialogId = extraParamsParsed.dialogId;\n      }\n    }\n\n    if (composing || paused) {\n      if (typeof self.onMessageTypingListener === 'function' && (type === 'chat' || type === 'groupchat' || !delay)) {\n        Utils.safeCallbackCall(self.onMessageTypingListener, !!composing, userId, dialogId);\n      }\n\n      return true;\n    }\n\n    if (marker) {\n      if (delivered) {\n        if (typeof self.onDeliveredStatusListener === 'function' && type === 'chat') {\n          Utils.safeCallbackCall(self.onDeliveredStatusListener, ChatUtils.getAttr(delivered, 'id'), dialogId, userId);\n        }\n      } else {\n        if (typeof self.onReadStatusListener === 'function' && type === 'chat') {\n          Utils.safeCallbackCall(self.onReadStatusListener, ChatUtils.getAttr(read, 'id'), dialogId, userId);\n        }\n      }\n\n      return true;\n    } // autosend 'received' status (ignore messages from yourself)\n\n\n    if (markable && userId != self.helpers.getIdFromNode(self.helpers.userCurrentJid(self.xmppClient))) {\n      var autoSendReceiveStatusParams = {\n        messageId: messageId,\n        userId: userId,\n        dialogId: dialogId\n      };\n      self.sendDeliveredStatus(autoSendReceiveStatusParams);\n    }\n\n    var message = {\n      id: messageId,\n      dialog_id: dialogId,\n      recipient_id: recipientId,\n      type: type,\n      body: bodyContent,\n      extension: extraParamsParsed ? extraParamsParsed.extension : null,\n      delay: delay\n    };\n\n    if (markable) {\n      message.markable = 1;\n    }\n\n    if (typeof self.onMessageListener === 'function' && (type === 'chat' || type === 'groupchat')) {\n      Utils.safeCallbackCall(self.onMessageListener, userId, message);\n    } // we must return true to keep the handler alive\n    // returning false would remove it after it finishes\n\n\n    return true;\n  };\n\n  this._onPresence = function (stanza) {\n    var from = ChatUtils.getAttr(stanza, 'from'),\n        id = ChatUtils.getAttr(stanza, 'id'),\n        type = ChatUtils.getAttr(stanza, 'type'),\n        currentUserId = self.helpers.getIdFromNode(self.helpers.userCurrentJid(self.xmppClient)),\n        x = ChatUtils.getElement(stanza, 'x'),\n        xXMLNS,\n        status,\n        statusCode,\n        dialogId,\n        userId,\n        contact;\n\n    if (x) {\n      xXMLNS = ChatUtils.getAttr(x, 'xmlns');\n      status = ChatUtils.getElement(x, 'status');\n\n      if (status) {\n        statusCode = ChatUtils.getAttr(status, 'code');\n      }\n    } // MUC presences go here\n\n\n    if (xXMLNS && xXMLNS == 'http://jabber.org/protocol/muc#user') {\n      dialogId = self.helpers.getDialogIdFromNode(from);\n      userId = self.helpers.getUserIdFromRoomJid(from); // KICK from dialog event\n\n      if (status && statusCode == '301') {\n        if (typeof self.onKickOccupant === 'function') {\n          var actorElement = ChatUtils.getElement(ChatUtils.getElement(x, 'item'), 'actor');\n          var initiatorUserJid = ChatUtils.getAttr(actorElement, 'jid');\n          Utils.safeCallbackCall(self.onKickOccupant, dialogId, self.helpers.getIdFromNode(initiatorUserJid));\n        }\n\n        delete self.muc.joinedRooms[self.helpers.getRoomJidFromRoomFullJid(from)];\n        return true; // Occupants JOIN/LEAVE events\n      } else if (!status) {\n        if (userId != currentUserId) {\n          // Leave\n          if (type && type === 'unavailable') {\n            if (typeof self.onLeaveOccupant === 'function') {\n              Utils.safeCallbackCall(self.onLeaveOccupant, dialogId, parseInt(userId));\n            }\n\n            return true; // Join\n          } else {\n            if (typeof self.onJoinOccupant === 'function') {\n              Utils.safeCallbackCall(self.onJoinOccupant, dialogId, parseInt(userId));\n            }\n\n            return true;\n          }\n        }\n      }\n    }\n\n    if (!Utils.getEnv().browser) {\n      /** MUC */\n      if (xXMLNS) {\n        if (xXMLNS == 'http://jabber.org/protocol/muc#user') {\n          /**\n           * if you make 'leave' from dialog\n           * stanza will be contains type=\"unavailable\"\n           */\n          if (type && type === 'unavailable') {\n            /** LEAVE from dialog */\n            if (status && statusCode == '110') {\n              if (typeof self.nodeStanzasCallbacks['muc:leave'] === 'function') {\n                Utils.safeCallbackCall(self.nodeStanzasCallbacks['muc:leave'], null);\n              }\n            }\n\n            return true;\n          }\n          /** JOIN to dialog success */\n\n\n          if (id.endsWith(':join') && status && statusCode == '110') {\n            if (typeof self.nodeStanzasCallbacks[id] === 'function') {\n              self.nodeStanzasCallbacks[id](stanza);\n            }\n\n            return true;\n          } // an error\n\n        } else if (type && type === 'error' && xXMLNS == 'http://jabber.org/protocol/muc') {\n          /** JOIN to dialog error */\n          if (id.endsWith(':join')) {\n            if (typeof self.nodeStanzasCallbacks[id] === 'function') {\n              self.nodeStanzasCallbacks[id](stanza);\n            }\n          }\n\n          return true;\n        }\n      }\n    } // ROSTER presences go here\n\n\n    userId = self.helpers.getIdFromNode(from);\n    contact = self.contactList.contacts[userId];\n\n    if (!type) {\n      if (typeof self.onContactListListener === 'function' && contact && contact.subscription !== 'none') {\n        Utils.safeCallbackCall(self.onContactListListener, userId);\n      }\n    } else {\n      switch (type) {\n        case 'subscribe':\n          if (contact && contact.subscription === 'to') {\n            contact ? contact.ask = null : contact = {\n              ask: null\n            };\n            contact.subscription = 'both';\n\n            self.contactList._sendSubscriptionPresence({\n              jid: from,\n              type: 'subscribed'\n            });\n          } else {\n            if (typeof self.onSubscribeListener === 'function') {\n              Utils.safeCallbackCall(self.onSubscribeListener, userId);\n            }\n          }\n\n          break;\n\n        case 'subscribed':\n          if (contact && contact.subscription === 'from') {\n            contact ? contact.ask = null : contact = {\n              ask: null\n            };\n            contact.subscription = 'both';\n          } else {\n            contact ? contact.ask = null : contact = {\n              ask: null\n            };\n            contact.subscription = 'to';\n\n            if (typeof self.onConfirmSubscribeListener === 'function') {\n              Utils.safeCallbackCall(self.onConfirmSubscribeListener, userId);\n            }\n          }\n\n          break;\n\n        case 'unsubscribed':\n          contact ? contact.ask = null : contact = {\n            ask: null\n          };\n          contact.subscription = 'none';\n\n          if (typeof self.onRejectSubscribeListener === 'function') {\n            Utils.safeCallbackCall(self.onRejectSubscribeListener, userId);\n          }\n\n          break;\n\n        case 'unsubscribe':\n          contact ? contact.ask = null : contact = {\n            ask: null\n          };\n          contact.subscription = 'to';\n          break;\n\n        case 'unavailable':\n          if (typeof self.onContactListListener === 'function' && contact && contact.subscription !== 'none') {\n            Utils.safeCallbackCall(self.onContactListListener, userId, type);\n          } // send initial presence if one of client (instance) goes offline\n\n\n          if (userId === currentUserId) {\n            self.xmppClient.send(ChatUtils.createPresenceStanza());\n          }\n\n          break;\n      }\n    } // we must return true to keep the handler alive\n    // returning false would remove it after it finishes\n\n\n    return true;\n  };\n\n  this._onIQ = function (stanza) {\n    var stanzaId = ChatUtils.getAttr(stanza, 'id'),\n        isLastActivity = stanzaId.indexOf('lastActivity') > -1;\n\n    if (typeof self.onLastUserActivityListener === 'function' && isLastActivity) {\n      var from = ChatUtils.getAttr(stanza, 'from'),\n          userId = self.helpers.getIdFromNode(from),\n          query = ChatUtils.getElement(stanza, 'query'),\n          error = ChatUtils.getElement(stanza, 'error'),\n          seconds = error ? undefined : +ChatUtils.getAttr(query, 'seconds');\n      Utils.safeCallbackCall(self.onLastUserActivityListener, userId, seconds);\n    }\n\n    if (!Utils.getEnv().browser) {\n      if (self.nodeStanzasCallbacks[stanzaId]) {\n        Utils.safeCallbackCall(self.nodeStanzasCallbacks[stanzaId], stanza);\n        delete self.nodeStanzasCallbacks[stanzaId];\n      }\n    }\n\n    return true;\n  };\n\n  this._onSystemMessageListener = function (stanza) {\n    var from = ChatUtils.getAttr(stanza, 'from'),\n        to = ChatUtils.getAttr(stanza, 'to'),\n        messageId = ChatUtils.getAttr(stanza, 'id'),\n        extraParams = ChatUtils.getElement(stanza, 'extraParams'),\n        userId = self.helpers.getIdFromNode(from),\n        delay = ChatUtils.getElement(stanza, 'delay'),\n        moduleIdentifier = ChatUtils.getElementText(extraParams, 'moduleIdentifier'),\n        bodyContent = ChatUtils.getElementText(stanza, 'body'),\n        extraParamsParsed = ChatUtils.parseExtraParams(extraParams),\n        message;\n\n    if (moduleIdentifier === 'SystemNotifications' && typeof self.onSystemMessageListener === 'function') {\n      message = {\n        id: messageId,\n        userId: userId,\n        body: bodyContent,\n        extension: extraParamsParsed.extension\n      };\n      Utils.safeCallbackCall(self.onSystemMessageListener, message);\n    } else if (self.webrtcSignalingProcessor && !delay && moduleIdentifier === 'WebRTCVideoChat') {\n      self.webrtcSignalingProcessor._onMessage(from, extraParams, delay, userId, extraParamsParsed.extension);\n    }\n    /**\n     * we must return true to keep the handler alive\n     * returning false would remove it after it finishes\n     */\n\n\n    return true;\n  };\n\n  this._onMessageErrorListener = function (stanza) {\n    // <error code=\"503\" type=\"cancel\">\n    //   <service-unavailable xmlns=\"urn:ietf:params:xml:ns:xmpp-stanzas\"/>\n    //   <text xmlns=\"urn:ietf:params:xml:ns:xmpp-stanzas\" xml:lang=\"en\">Service not available.</text>\n    // </error>\n    var messageId = ChatUtils.getAttr(stanza, 'id');\n    var error = ChatUtils.getErrorFromXMLNode(stanza); // fire 'onMessageErrorListener'\n    //\n\n    if (typeof self.onMessageErrorListener === 'function') {\n      Utils.safeCallbackCall(self.onMessageErrorListener, messageId, error);\n    } // we must return true to keep the handler alive\n    // returning false would remove it after it finishes\n\n\n    return true;\n  };\n}\n/* Chat module: Core\n ----------------------------------------------------------------------------- */\n\n\nChatProxy.prototype = {\n  /**\n   * Connect to chat\n   *\n   * @memberof CB.chat\n   * @param {Object} params - Connect to the chat parameters\n   * @param {Number} params.userId - Connect to the chat by user id (use instead params.email and params.jid)\n   * @param {String} params.jid - Connect to the chat by user jid (use instead params.userId and params.email)\n   * @param {String} params.email - Connect to the chat by user's email (use instead params.userId and params.jid)\n   * @param {String} params.password - The user's password or session token\n   * @param {chatConnectCallback} callback - The chatConnectCallback callback\n   * */\n  connect: function connect(params, callback) {\n    /**\n     * This callback Returns error or contact list.\n     * @callback chatConnectCallback\n     * @param {Object} error - The error object\n     * @param {(Object|Boolean)} response - Object of subscribed users (roster) or empty body.\n     * */\n    Utils.DLog('[Chat]', 'Connect with parameters ' + JSON.stringify(params));\n    var self = this,\n        userJid = ChatUtils.buildUserJid(params),\n        isInitialConnect = typeof callback === 'function',\n        err;\n\n    if (self._isConnecting) {\n      err = Utils.getError(422, 'REJECT - The connection is still in the CONNECTING state', 'Chat');\n\n      if (isInitialConnect) {\n        callback(err, null);\n      }\n\n      return;\n    }\n\n    if (self.isConnected) {\n      Utils.DLog('[Chat]', 'CONNECTED - You are already connected');\n\n      if (isInitialConnect) {\n        callback(null, self.contactList.contacts);\n      }\n\n      return;\n    }\n\n    self._isConnecting = true;\n    self._isLogout = false; // connect for Browser\n    //\n\n    if (Utils.getEnv().browser) {\n      self.xmppClient.connect(userJid, params.password, function (status) {\n        switch (status) {\n          case Strophe.Status.ERROR:\n            self.isConnected = false;\n            self._isConnecting = false;\n            err = Utils.getError(422, 'ERROR - An error has occurred', 'Chat');\n\n            if (isInitialConnect) {\n              callback(err, null);\n            }\n\n            break;\n\n          case Strophe.Status.CONNFAIL:\n            self.isConnected = false;\n            self._isConnecting = false;\n            err = Utils.getError(422, 'CONNFAIL - The connection attempt failed', 'Chat');\n\n            if (isInitialConnect) {\n              callback(err, null);\n            }\n\n            break;\n\n          case Strophe.Status.AUTHENTICATING:\n            Utils.DLog('[Chat]', 'AUTHENTICATING');\n            break;\n\n          case Strophe.Status.AUTHFAIL:\n            self.isConnected = false;\n            self._isConnecting = false;\n            err = Utils.getError(401, 'Status.AUTHFAIL - The authentication attempt failed', 'Chat');\n\n            if (isInitialConnect) {\n              callback(err, null);\n            }\n\n            if (!self.isConnected && typeof self.onReconnectFailedListener === 'function') {\n              Utils.safeCallbackCall(self.onReconnectFailedListener, err);\n            }\n\n            break;\n\n          case Strophe.Status.CONNECTING:\n            Utils.DLog('[Chat]', 'Status.CONNECTING', '(Chat Protocol - ' + (Config.chatProtocol.active === 1 ? 'BOSH' : 'WebSocket' + ')'));\n            break;\n\n          case Strophe.Status.CONNECTED:\n            // Remove any handlers that might exist from a previous connection via\n            // extension method added to the connection on initialization in cubeMain.\n            // NOTE: streamManagement also adds handlers, so do this first.\n            self.xmppClient.XDeleteHandlers();\n            self.xmppClient.XAddTrackedHandler(self._onMessage, null, 'message', 'chat');\n            self.xmppClient.XAddTrackedHandler(self._onMessage, null, 'message', 'groupchat');\n            self.xmppClient.XAddTrackedHandler(self._onPresence, null, 'presence');\n            self.xmppClient.XAddTrackedHandler(self._onIQ, null, 'iq');\n            self.xmppClient.XAddTrackedHandler(self._onSystemMessageListener, null, 'message', 'headline');\n            self.xmppClient.XAddTrackedHandler(self._onMessageErrorListener, null, 'message', 'error');\n\n            self._postConnectActions(function (roster) {\n              callback(null, roster);\n            }, isInitialConnect);\n\n            break;\n\n          case Strophe.Status.DISCONNECTING:\n            Utils.DLog('[Chat]', 'DISCONNECTING');\n            break;\n\n          case Strophe.Status.DISCONNECTED:\n            Utils.DLog('[Chat]', 'DISCONNECTED'); // fire 'onDisconnectedListener' only once\n\n            if (self.isConnected && typeof self.onDisconnectedListener === 'function') {\n              Utils.safeCallbackCall(self.onDisconnectedListener);\n            }\n\n            self.isConnected = false;\n            self._isConnecting = false; // reconnect to chat and enable check connection\n\n            self._establishConnection(params);\n\n            break;\n\n          case Strophe.Status.ATTACHED:\n            Utils.DLog('[Chat]', 'Status.ATTACHED');\n            break;\n        }\n      }); // connect for Node.js/Native-Script\n      //\n    } else if (Utils.getEnv().node || Utils.getEnv().nativescript) {\n      // Remove all connection handlers exist from a previous connection\n      self.xmppClient.removeAllListeners();\n      self.xmppClient.on('connect', function () {\n        Utils.DLog('[Chat]', 'CONNECTING', '(Chat Protocol - ' + (Config.chatProtocol.active === 1 ? 'BOSH' : 'WebSocket' + ')'));\n      });\n      self.xmppClient.on('auth', function () {\n        Utils.DLog('[Chat]', 'AUTHENTICATING');\n      });\n      self.xmppClient.on('online', function () {\n        Utils.DLog('[Chat]', 'ONLINE');\n\n        self._postConnectActions(function (roster) {\n          callback(null, roster);\n        }, isInitialConnect);\n      });\n      self.xmppClient.on('stanza', function (stanza) {\n        Utils.DLog('[Chat] RECV:', stanza.toString());\n        /**\n         * Detect typeof incoming stanza\n         * and fire the Listener\n         */\n\n        if (stanza.is('presence')) {\n          self._onPresence(stanza);\n        } else if (stanza.is('iq')) {\n          self._onIQ(stanza);\n        } else if (stanza.is('message')) {\n          if (stanza.attrs.type === 'headline') {\n            self._onSystemMessageListener(stanza);\n          } else if (stanza.attrs.type === 'error') {\n            self._onMessageErrorListener(stanza);\n          } else {\n            self._onMessage(stanza);\n          }\n        }\n      });\n      self.xmppClient.on('disconnect', function () {\n        Utils.DLog('[Chat]', 'DISCONNECTED');\n\n        if (typeof self.onDisconnectedListener === 'function') {\n          Utils.safeCallbackCall(self.onDisconnectedListener);\n        }\n\n        self.isConnected = false;\n        self._isConnecting = false; // reconnect to chat and enable check connection\n\n        self._establishConnection(params);\n      });\n      self.xmppClient.on('error', function () {\n        Utils.DLog('[Chat]', 'ERROR');\n        err = Utils.getError(422, 'ERROR - An error has occurred', 'Chat');\n\n        if (isInitialConnect) {\n          callback(err, null);\n        }\n\n        self.isConnected = false;\n        self._isConnecting = false;\n      });\n      self.xmppClient.on('end', function () {\n        self.xmppClient.removeAllListeners();\n      });\n      self.xmppClient.options.jid = userJid;\n      self.xmppClient.options.password = params.password;\n      self.xmppClient.connect(); // connect for React-Native\n      //\n    } else if (Utils.getEnv().reactnative) {\n      var removeAllListeners = function removeAllListeners() {\n        self.xmppClientListeners.forEach(function (listener) {\n          self.xmppClient.removeListener(listener.name, listener.callback);\n        });\n        self.xmppClientListeners = [];\n      };\n\n      removeAllListeners();\n\n      var callbackConnect = function callbackConnect() {\n        Utils.DLog('[Chat]', 'CONNECTING');\n      };\n\n      self.xmppClient.on('connect', callbackConnect);\n      self.xmppClientListeners.push({\n        name: 'connect',\n        callback: callbackConnect\n      });\n\n      var callbackOnline = function callbackOnline(jid) {\n        Utils.DLog('[Chat]', 'ONLINE');\n\n        self._postConnectActions(function (roster) {\n          callback(null, roster);\n        }, isInitialConnect);\n      };\n\n      self.xmppClient.on('online', callbackOnline);\n      self.xmppClientListeners.push({\n        name: 'online',\n        callback: callbackOnline\n      });\n\n      var callbackOffline = function callbackOffline() {\n        Utils.DLog('[Chat]', 'OFFLINE');\n      };\n\n      self.xmppClient.on('offline', callbackOffline);\n      self.xmppClientListeners.push({\n        name: 'offline',\n        callback: callbackOffline\n      });\n\n      var callbackDisconnect = function callbackDisconnect(data) {\n        Utils.DLog('[Chat]', 'DISCONNECTED');\n\n        var setIsConnectedToFalse = function setIsConnectedToFalse() {\n          self.isConnected = false;\n          self._isConnecting = false;\n        }; // fire 'onDisconnectedListener' only once\n\n\n        if (self.isConnected && typeof self.onDisconnectedListener === 'function') {\n          setIsConnectedToFalse();\n          Utils.safeCallbackCall(self.onDisconnectedListener);\n        } else {\n          setIsConnectedToFalse();\n        } // reconnect to chat and enable check connection\n\n\n        self._establishConnection(params);\n      };\n\n      self.xmppClient.on('disconnect', callbackDisconnect);\n      self.xmppClientListeners.push({\n        name: 'disconnect',\n        callback: callbackDisconnect\n      });\n\n      var callbackStatus = function callbackStatus(status, value) {\n        Utils.DLog('[Chat]', 'status', status, value ? value.toString() : '');\n      };\n\n      self.xmppClient.on('status', callbackStatus);\n      self.xmppClientListeners.push({\n        name: 'status',\n        callback: callbackStatus\n      }); // self.xmppClientReconnect.on('reconnecting', function() {\n      //     Utils.DLog('[Chat]', 'RECONNECTING');\n      // });\n      //\n      // self.xmppClientReconnect.on('reconnected', function() {\n      //     Utils.DLog('[Chat]', 'RECONNECTED');\n      // });\n\n      var callbackStanza = function callbackStanza(stanza) {\n        // console.log('stanza', stanza.toString())\n        // after 'input' and 'element' (only if stanza, not nonza)\n        if (stanza.is('presence')) {\n          self._onPresence(stanza);\n        } else if (stanza.is('iq')) {\n          self._onIQ(stanza);\n        } else if (stanza.is('message')) {\n          if (stanza.attrs.type === 'headline') {\n            self._onSystemMessageListener(stanza);\n          } else if (stanza.attrs.type === 'error') {\n            self._onMessageErrorListener(stanza);\n          } else {\n            self._onMessage(stanza);\n          }\n        }\n      };\n\n      self.xmppClient.on('stanza', callbackStanza);\n      self.xmppClientListeners.push({\n        name: 'stanza',\n        callback: callbackStanza\n      });\n\n      var callbackError = function callbackError(err) {\n        Utils.DLog('[Chat]', 'ERROR:', err);\n\n        if (isInitialConnect) {\n          if (err.name == 'SASLError') {\n            err = err.condition;\n          }\n\n          callback(err, null);\n        }\n\n        self.isConnected = false;\n        self._isConnecting = false;\n      };\n\n      self.xmppClient.on('error', callbackError);\n      self.xmppClientListeners.push({\n        name: 'error',\n        callback: callbackError\n      }); // self.xmppClient.on('element', function(element) {\n      //     // console.log('element', element.toString())\n      //     // after 'input'\n      // });\n      // self.xmppClient.on('send', function(element) {\n      //     // console.log('send', element.toString())\n      //     // after write to socket\n      // });\n      // self.xmppClient.on('outgoing', function(element) {\n      //     // before send\n      //     // console.log('outgoing', element.toString())\n      // });\n\n      var callbackOutput = function callbackOutput(str) {\n        Utils.DLog('[Chat]', 'SENT:', str);\n      };\n\n      self.xmppClient.on('output', callbackOutput);\n      self.xmppClientListeners.push({\n        name: 'output',\n        callback: callbackOutput\n      });\n\n      var callbackInput = function callbackInput(str) {\n        Utils.DLog('[Chat]', 'RECV:', str);\n      };\n\n      self.xmppClient.on('input', callbackInput);\n      self.xmppClientListeners.push({\n        name: 'input',\n        callback: callbackInput\n      }); // define these properties so they will be used when authenticate (above)\n\n      Object.defineProperty(self.xmppClient, 'cbUserName', {\n        value: ChatUtils.buildUserJidLocalPart(params.userId),\n        writable: false\n      });\n      Object.defineProperty(self.xmppClient, 'cbUserPassword', {\n        value: params.password,\n        writable: false\n      }); //\n\n      self.xmppClient.start();\n    } else {\n      throw 'Unsupported platform for Chat/XMPP functionality';\n    }\n  },\n\n  /**\n   * Actions after the connection is established\n   *\n   * - enable stream management (the configuration setting);\n   * - save user's JID;\n   * - enable carbons;\n   * - get and storage the user's roster (if the initial connect);\n   * - recover the joined rooms and fire 'onReconnectListener' (if the reconnect);\n   * - send initial presence to the chat server.\n   */\n  _postConnectActions: function _postConnectActions(callback, isInitialConnect) {\n    Utils.DLog('[Chat]', 'CONNECTED');\n    var self = this,\n        presence = ChatUtils.createPresenceStanza();\n\n    if (Config.chat.streamManagement.enable && Config.chatProtocol.active === 2) {\n      self.streamManagement.enable(self.xmppClient);\n      self.streamManagement.sentMessageCallback = self._sentMessageCallback;\n    }\n\n    self.helpers.setUserCurrentJid(self.helpers.userCurrentJid(self.xmppClient));\n    self.isConnected = true;\n    self._isConnecting = false;\n\n    self._enableCarbons();\n\n    if (isInitialConnect) {\n      self.contactList.get(function (contacts) {\n        self.xmppClient.send(presence);\n        self.contactList.contacts = contacts;\n        callback(self.contactList.contacts);\n      });\n    } else {\n      var rooms = Object.keys(self.muc.joinedRooms);\n      self.xmppClient.send(presence);\n      Utils.DLog('[Chat]', 'Re-joining ' + rooms.length + ' rooms...');\n\n      for (var i = 0, len = rooms.length; i < len; i++) {\n        self.muc.join(rooms[i]);\n      }\n\n      if (typeof self.onReconnectListener === 'function') {\n        Utils.safeCallbackCall(self.onReconnectListener);\n      }\n    }\n  },\n  _establishConnection: function _establishConnection(params) {\n    var self = this;\n\n    if (self._isLogout || self._checkConnectionTimer) {\n      return;\n    }\n\n    var _connect = function _connect() {\n      if (!self.isConnected && !self._isConnecting) {\n        self.connect(params);\n      } else {\n        clearInterval(self._checkConnectionTimer);\n        self._checkConnectionTimer = undefined;\n      }\n    };\n\n    _connect();\n\n    self._checkConnectionTimer = setInterval(function () {\n      _connect();\n    }, Config.chat.reconnectionTimeInterval * 1000);\n  },\n\n  /**\n   * Send message to 1 to 1 or group dialog.\n   * @memberof CB.chat\n   * @param {String | Number} jidOrUserId - Use opponent id or jid for 1 to 1 chat, and room jid for group chat.\n   * @param {Object} message - The message object.\n   * @returns {String} messageId - The current message id (was generated by SDK)\n   * */\n  send: function send(jidOrUserId, message) {\n    var stanzaParams = {\n      from: this.helpers.getUserCurrentJid(),\n      to: this.helpers.jidOrUserId(jidOrUserId),\n      type: message.type ? message.type : 'chat',\n      id: message.id ? message.id : Utils.getBsonObjectId()\n    };\n    var messageStanza = ChatUtils.createMessageStanza(stanzaParams);\n\n    if (message.body) {\n      messageStanza.c('body', {\n        xmlns: ChatUtils.MARKERS.CLIENT\n      }).t(message.body).up();\n    }\n\n    if (message.markable) {\n      messageStanza.c('markable', {\n        xmlns: ChatUtils.MARKERS.CHAT\n      }).up();\n    }\n\n    if (message.extension) {\n      messageStanza.c('extraParams', {\n        xmlns: ChatUtils.MARKERS.CLIENT\n      });\n      messageStanza = ChatUtils.filledExtraParams(messageStanza, message.extension);\n    }\n\n    if (Config.chat.streamManagement.enable) {\n      message.id = stanzaParams.id;\n      this.xmppClient.send(messageStanza, message);\n    } else {\n      this.xmppClient.send(messageStanza);\n    }\n\n    return stanzaParams.id;\n  },\n\n  /**\n   * Send system message (system notification) to 1 to 1 or group dialog.\n   * @memberof CB.chat\n   * @param {String | Number} jidOrUserId - Use opponent id or jid for 1 to 1 chat, and room jid for group chat.\n   * @param {Object} message - The message object.\n   * @returns {String} messageId - The current message id (was generated by SDK)\n   * */\n  sendSystemMessage: function sendSystemMessage(jidOrUserId, message) {\n    var stanzaParams = {\n      type: 'headline',\n      id: message.id ? message.id : Utils.getBsonObjectId(),\n      to: this.helpers.jidOrUserId(jidOrUserId)\n    };\n    var messageStanza = ChatUtils.createMessageStanza(stanzaParams);\n\n    if (message.body) {\n      messageStanza.c('body', {\n        xmlns: ChatUtils.MARKERS.CLIENT\n      }).t(message.body).up();\n    } // custom parameters\n\n\n    if (message.extension) {\n      messageStanza.c('extraParams', {\n        xmlns: ChatUtils.MARKERS.CLIENT\n      }).c('moduleIdentifier').t('SystemNotifications').up();\n      messageStanza = ChatUtils.filledExtraParams(messageStanza, message.extension);\n    }\n\n    this.xmppClient.send(messageStanza);\n    return stanzaParams.id;\n  },\n\n  /**\n   * Send is typing status.\n   * @memberof CB.chat\n   * @param {String | Number} jidOrUserId - Use opponent id or jid for 1 to 1 chat, and room jid for group chat.\n   * */\n  sendIsTypingStatus: function sendIsTypingStatus(jidOrUserId) {\n    var stanzaParams = {\n      from: this.helpers.getUserCurrentJid(),\n      to: this.helpers.jidOrUserId(jidOrUserId),\n      type: this.helpers.typeChat(jidOrUserId)\n    };\n    var messageStanza = ChatUtils.createMessageStanza(stanzaParams);\n    messageStanza.c('composing', {\n      xmlns: ChatUtils.MARKERS.STATES\n    });\n    this.xmppClient.send(messageStanza);\n  },\n\n  /**\n   * Send is stop typing status.\n   * @memberof CB.chat\n   * @param {String | Number} jidOrUserId - Use opponent id or jid for 1 to 1 chat, and room jid for group chat.\n   * */\n  sendIsStopTypingStatus: function sendIsStopTypingStatus(jidOrUserId) {\n    var stanzaParams = {\n      from: this.helpers.getUserCurrentJid(),\n      to: this.helpers.jidOrUserId(jidOrUserId),\n      type: this.helpers.typeChat(jidOrUserId)\n    };\n    var messageStanza = ChatUtils.createMessageStanza(stanzaParams);\n    messageStanza.c('paused', {\n      xmlns: ChatUtils.MARKERS.STATES\n    });\n    this.xmppClient.send(messageStanza);\n  },\n\n  /**\n   * Send is delivered status.\n   * @memberof CB.chats\n   * @param {Object} params - Object of parameters\n   * @param {Number} params.userId - The receiver id\n   * @param {Number} params.messageId - The delivered message id\n   * @param {Number} params.dialogId - The dialog id\n   * */\n  sendDeliveredStatus: function sendDeliveredStatus(params) {\n    var stanzaParams = {\n      type: 'chat',\n      from: this.helpers.getUserCurrentJid(),\n      id: Utils.getBsonObjectId(),\n      to: this.helpers.jidOrUserId(params.userId)\n    };\n    var messageStanza = ChatUtils.createMessageStanza(stanzaParams);\n    messageStanza.c('received', {\n      xmlns: ChatUtils.MARKERS.MARKERS,\n      id: params.messageId\n    }).up();\n    messageStanza.c('extraParams', {\n      xmlns: ChatUtils.MARKERS.CLIENT\n    }).c('dialog_id').t(params.dialogId);\n    this.xmppClient.send(messageStanza);\n  },\n\n  /**\n   * Send is read status.\n   * @memberof CB.chat\n   * @param {Object} params - Object of parameters\n   * @param {Number} params.userId - The receiver id\n   * @param {Number} params.messageId - The delivered message id\n   * @param {Number} params.dialogId - The dialog id\n   * */\n  sendReadStatus: function sendReadStatus(params) {\n    var stanzaParams = {\n      type: 'chat',\n      from: this.helpers.getUserCurrentJid(),\n      to: this.helpers.jidOrUserId(params.userId),\n      id: Utils.getBsonObjectId()\n    };\n    var messageStanza = ChatUtils.createMessageStanza(stanzaParams);\n    messageStanza.c('displayed', {\n      xmlns: ChatUtils.MARKERS.MARKERS,\n      id: params.messageId\n    }).up();\n    messageStanza.c('extraParams', {\n      xmlns: ChatUtils.MARKERS.CLIENT\n    }).c('dialog_id').t(params.dialogId);\n    this.xmppClient.send(messageStanza);\n  },\n\n  /**\n   * Send query to get last user activity by CB.chat.onLastUserActivityListener(userId, seconds). {@link https://xmpp.org/extensions/xep-0012.html More info.}\n   * @memberof CB.chat\n   * @param {(Number|String)} jidOrUserId - The user id or jid, that the last activity we want to know\n   * */\n  getLastUserActivity: function getLastUserActivity(jidOrUserId) {\n    var iqParams = {\n      from: this.helpers.getUserCurrentJid(),\n      id: this.helpers.getUniqueId('lastActivity'),\n      to: this.helpers.jidOrUserId(jidOrUserId),\n      type: 'get'\n    };\n    var iqStanza = ChatUtils.createIqStanza(iqParams);\n    iqStanza.c('query', {\n      xmlns: ChatUtils.MARKERS.LAST\n    });\n    this.xmppClient.send(iqStanza);\n  },\n\n  /**\n   * Logout from the Chat.\n   * @memberof CB.chat\n   * */\n  disconnect: function disconnect() {\n    clearInterval(this._checkConnectionTimer);\n    this._checkConnectionTimer = undefined;\n    this.muc.joinedRooms = {};\n    this._isLogout = true;\n    this.helpers.setUserCurrentJid('');\n\n    if (Utils.getEnv().browser) {\n      this.xmppClient.flush();\n      this.xmppClient.disconnect();\n    } else if (Utils.getEnv().reactnative) {\n      this.xmppClient.stop();\n    } else {\n      // Node.js & Native Script\n      this.xmppClient.end();\n    }\n  },\n\n  /**\n   * Carbons XEP [http://xmpp.org/extensions/xep-0280.html]\n   */\n  _enableCarbons: function _enableCarbons() {\n    var carbonParams = {\n      type: 'set',\n      from: this.helpers.getUserCurrentJid(),\n      id: ChatUtils.getUniqueId('enableCarbons')\n    };\n    var iqStanza = ChatUtils.createIqStanza(carbonParams);\n    iqStanza.c('enable', {\n      xmlns: ChatUtils.MARKERS.CARBONS\n    });\n\n    if (Utils.getEnv().browser) {\n      this.xmppClient.sendIQ(iqStanza);\n    } else {\n      this.xmppClient.send(iqStanza);\n    }\n  }\n};\n/**\n * @namespace CB.chat\n * */\n\nmodule.exports = ChatProxy;","map":null,"metadata":{},"sourceType":"script"}