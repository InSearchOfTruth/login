{"ast":null,"code":"'use strict';\n\nvar Session = require('./session');\n\nvar core = require('node-xmpp-core');\n\nvar JID = core.JID;\nvar Stanza = core.Stanza;\nvar Element = core.Element;\nvar inherits = core.inherits;\n\nvar sasl = require('./sasl');\n\nvar Anonymous = require('./authentication/anonymous');\n\nvar Plain = require('./authentication/plain');\n\nvar DigestMD5 = require('./authentication/digestmd5');\n\nvar XOAuth2 = require('./authentication/xoauth2');\n\nvar External = require('./authentication/external');\n\nvar exec = require('child_process').exec;\n\nvar debug = require('debug')('xmpp:client');\n\nvar path = require('path');\n\nvar NS_CLIENT = 'jabber:client';\nvar NS_REGISTER = 'jabber:iq:register';\nvar NS_XMPP_SASL = 'urn:ietf:params:xml:ns:xmpp-sasl';\nvar NS_XMPP_BIND = 'urn:ietf:params:xml:ns:xmpp-bind';\nvar NS_XMPP_SESSION = 'urn:ietf:params:xml:ns:xmpp-session';\nvar STATE_PREAUTH = 0;\nvar STATE_AUTH = 1;\nvar STATE_AUTHED = 2;\nvar STATE_BIND = 3;\nvar STATE_SESSION = 4;\nvar STATE_ONLINE = 5;\nvar IQID_SESSION = 'sess';\nvar IQID_BIND = 'bind';\nvar decode64, encode64, Buffer;\n\nif (typeof btoa === 'undefined') {\n  var btoa = null;\n  var atob = null;\n}\n\nif (typeof btoa === 'function') {\n  decode64 = function decode64(encoded) {\n    return atob(encoded);\n  };\n} else {\n  Buffer = require('buffer').Buffer;\n\n  decode64 = function decode64(encoded) {\n    return new Buffer(encoded, 'base64').toString('utf8');\n  };\n}\n\nif (typeof atob === 'function') {\n  encode64 = function encode64(decoded) {\n    return btoa(decoded);\n  };\n} else {\n  Buffer = require('buffer').Buffer;\n\n  encode64 = function encode64(decoded) {\n    return new Buffer(decoded, 'utf8').toString('base64');\n  };\n}\n/**\n * params object:\n *   jid: String (required)\n *   password: String (required)\n *   host: String (optional)\n *   port: Number (optional)\n *   reconnect: Boolean (optional)\n *   autostart: Boolean (optional) - if we start connecting to a given port\n *   register: Boolean (option) - register account before authentication\n *   legacySSL: Boolean (optional) - connect to the legacy SSL port, requires at least the host to be specified\n *   credentials: Dictionary (optional) - TLS or SSL key and certificate credentials\n *   actAs: String (optional) - if admin user act on behalf of another user (just user)\n *   disallowTLS: Boolean (optional) - prevent upgrading the connection to a secure one via TLS\n *   preferred: String (optional) - Preferred SASL mechanism to use\n *   bosh.url: String (optional) - BOSH endpoint to use\n *   bosh.prebind: Function(error, data) (optional) - Just prebind a new BOSH session for browser client use\n *            error String - Result of XMPP error. Ex : [Error: XMPP authentication failure]\n *            data Object - Result of XMPP BOSH connection.\n *\n * Examples:\n *   var cl = new xmpp.Client({\n *       jid: \"me@example.com\",\n *       password: \"secret\"\n *   })\n *   var gtalk = new xmpp.Client({\n *       jid: 'me@gmail.com',\n *       oauth2_token: 'xxxx.xxxxxxxxxxx', // from OAuth2\n *       oauth2_auth: 'http://www.google.com/talk/protocol/auth',\n *       host: 'talk.google.com'\n *   })\n *   var prebind = new xmpp.Client({\n *       jid: \"me@example.com\",\n *       password: \"secret\",\n *       bosh: {\n *           url: \"http://example.com/http-bind\",\n *           prebind: function(error, data) {\n *               if (error) {}\n *               res.send({ rid: data.rid, sid: data.sid })\n *           }\n *       }\n *   })\n *\n * Example SASL EXTERNAL:\n *\n * var myCredentials = {\n *   // These are necessary only if using the client certificate authentication\n *   key: fs.readFileSync('key.pem'),\n *   cert: fs.readFileSync('cert.pem'),\n *   // passphrase: 'optional'\n * }\n * var cl = new xmppClient({\n *     jid: \"me@example.com\",\n *     credentials: myCredentials\n *     preferred: 'EXTERNAL' // not really required, but possible\n * })\n *\n */\n\n\nfunction Client(options) {\n  this.options = {};\n  if (options) this.options = options;\n  this.availableSaslMechanisms = [XOAuth2, External, DigestMD5, Plain, Anonymous];\n  if (this.options.autostart !== false) this.connect();\n}\n\ninherits(Client, Session);\nClient.NS_CLIENT = NS_CLIENT;\n\nClient.prototype.connect = function () {\n  if (this.options.bosh && this.options.bosh.prebind) {\n    return this._connectViaBosh();\n  }\n\n  this._useStandardConnect();\n};\n\nClient.prototype._useStandardConnect = function () {\n  this.options.xmlns = NS_CLIENT;\n  delete this.did_bind;\n  delete this.did_session;\n  this.state = STATE_PREAUTH;\n  this.on('end', function () {\n    this.state = STATE_PREAUTH;\n    delete this.did_bind;\n    delete this.did_session;\n  });\n  Session.call(this, this.options);\n  this.options.jid = this.jid;\n  this.connection.on('disconnect', function (error) {\n    this.state = STATE_PREAUTH;\n\n    if (!this.connection.reconnect) {\n      if (error) this.emit('error', error);\n      this.emit('offline');\n    }\n\n    delete this.did_bind;\n    delete this.did_session;\n  }.bind(this));\n  /* If server and client have multiple possible auth mechanisms\n   * we try to select the preferred one\n   */\n\n  if (this.options.preferred) {\n    this.preferredSaslMechanism = this.options.preferred;\n  } else {\n    this.preferredSaslMechanism = 'DIGEST-MD5';\n  }\n\n  var mechs = sasl.detectMechanisms(this.options, this.availableSaslMechanisms);\n  this.availableSaslMechanisms = mechs;\n};\n\nClient.prototype._connectViaBosh = function () {\n  debug('load bosh prebind');\n  var cb = this.options.bosh.prebind;\n  delete this.options.bosh.prebind;\n  var cmd = 'node ' + path.join(__dirname, 'prebind.js') + ' ' + encodeURI(JSON.stringify(this.options));\n  exec(cmd, function (error, stdout, stderr) {\n    if (error) {\n      cb(error, null);\n    } else {\n      var r = stdout.match(/rid:+[ 0-9]*/i);\n      var s = stdout.match(/sid:+[ a-z+'\"-_A-Z+0-9]*/i);\n\n      if (!r || !s) {\n        return cb(stderr);\n      }\n\n      r = r[0].split(':')[1].trim();\n      s = s[0].split(':')[1].replace(\"'\", '').replace(\"'\", '').trim();\n\n      if (r && s) {\n        return cb(null, {\n          rid: r,\n          sid: s\n        });\n      }\n\n      cb(stderr);\n    }\n  });\n};\n\nClient.prototype.onStanza = function (stanza) {\n  /* Actually, we shouldn't wait for <stream:features/> if\n   * this.streamAttrs.version is missing, but who uses pre-XMPP-1.0\n   * these days anyway?\n   */\n  if (stanza.name === 'stream:error') {\n    return this._handleStreamError(stanza);\n  }\n\n  if (this.state !== STATE_ONLINE && stanza.is('features')) {\n    this.streamFeatures = stanza;\n    return this.useFeatures();\n  }\n\n  this._handleStanza(stanza);\n};\n\nClient.prototype._handleStanza = function (stanza) {\n  switch (this.state) {\n    case STATE_ONLINE:\n      this.emit('stanza', stanza);\n      break;\n\n    case STATE_PREAUTH:\n      this.emit('stanza:preauth', stanza);\n      break;\n\n    case STATE_AUTH:\n      this._handleAuthState(stanza);\n\n      break;\n\n    case STATE_BIND:\n      if (stanza.is('iq') && stanza.attrs.id === IQID_BIND) {\n        this._handleBindState(stanza);\n      }\n\n      break;\n\n    case STATE_SESSION:\n      if (stanza.is('iq') === true && stanza.attrs.id === IQID_SESSION) {\n        this._handleSessionState(stanza);\n      }\n\n      break;\n  }\n};\n\nClient.prototype._handleStreamError = function (stanza) {\n  if (!this.reconnect) {\n    this.emit('error', stanza);\n  }\n};\n\nClient.prototype._handleSessionState = function (stanza) {\n  if (stanza.attrs.type === 'result') {\n    this.state = STATE_AUTHED;\n    this.did_session = true;\n    /* no stream restart, but next feature (most probably\n       we'll go online next) */\n\n    this.useFeatures();\n  } else {\n    this.emit('error', 'Cannot bind resource');\n  }\n};\n\nClient.prototype._handleBindState = function (stanza) {\n  if (stanza.attrs.type === 'result') {\n    this.state = STATE_AUTHED;\n    this.did_bind = true;\n    var bindEl = stanza.getChild('bind', NS_XMPP_BIND);\n\n    if (bindEl && bindEl.getChild('jid')) {\n      this.jid = new JID(bindEl.getChild('jid').getText());\n    }\n    /* no stream restart, but next feature */\n\n\n    this.useFeatures();\n  } else {\n    this.emit('error', 'Cannot bind resource');\n  }\n};\n\nClient.prototype._handleAuthState = function (stanza) {\n  if (stanza.is('challenge', NS_XMPP_SASL)) {\n    var challengeMsg = decode64(stanza.getText());\n    var responseMsg = encode64(this.mech.challenge(challengeMsg));\n    var response = new Element('response', {\n      xmlns: NS_XMPP_SASL\n    }).t(responseMsg);\n    this.send(response);\n  } else if (stanza.is('success', NS_XMPP_SASL)) {\n    this.mech = null;\n    this.state = STATE_AUTHED;\n    this.emit('auth');\n  } else {\n    this.emit('error', 'XMPP authentication failure');\n  }\n};\n\nClient.prototype._handlePreAuthState = function () {\n  this.state = STATE_AUTH;\n  var offeredMechs = this.streamFeatures.getChild('mechanisms', NS_XMPP_SASL).getChildren('mechanism', NS_XMPP_SASL).map(function (el) {\n    return el.getText();\n  });\n  this.mech = sasl.selectMechanism(offeredMechs, this.preferredSaslMechanism, this.availableSaslMechanisms);\n\n  if (this.mech) {\n    this.mech.authzid = this.jid.bare().toString();\n    this.mech.authcid = this.jid.local;\n    this.mech.password = this.password;\n    this.mech.api_key = this.api_key;\n    this.mech.access_token = this.access_token;\n    this.mech.oauth2_token = this.oauth2_token;\n    this.mech.oauth2_auth = this.oauth2_auth;\n    this.mech.realm = this.jid.domain; // anything?\n\n    if (this.actAs) this.mech.actAs = this.actAs.user;\n    this.mech.digest_uri = 'xmpp/' + this.jid.domain;\n    var authMsg = encode64(this.mech.auth());\n    var attrs = this.mech.authAttrs();\n    attrs.xmlns = NS_XMPP_SASL;\n    attrs.mechanism = this.mech.name;\n    this.send(new Element('auth', attrs).t(authMsg));\n  } else {\n    this.emit('error', new Error('No usable SASL mechanism'));\n  }\n};\n/**\n * Either we just received <stream:features/>, or we just enabled a\n * feature and are looking for the next.\n */\n\n\nClient.prototype.useFeatures = function () {\n  if (this.state === STATE_PREAUTH && this.register) {\n    delete this.register;\n    this.doRegister();\n  } else if (this.state === STATE_PREAUTH && this.streamFeatures.getChild('mechanisms', NS_XMPP_SASL)) {\n    this._handlePreAuthState();\n  } else if (this.state === STATE_AUTHED && !this.did_bind && this.streamFeatures.getChild('bind', NS_XMPP_BIND)) {\n    this.state = STATE_BIND;\n    var bindEl = new Stanza('iq', {\n      type: 'set',\n      id: IQID_BIND\n    }).c('bind', {\n      xmlns: NS_XMPP_BIND\n    });\n\n    if (this.jid.resource) {\n      bindEl.c('resource').t(this.jid.resource);\n    }\n\n    this.send(bindEl);\n  } else if (this.state === STATE_AUTHED && !this.did_session && this.streamFeatures.getChild('session', NS_XMPP_SESSION)) {\n    this.state = STATE_SESSION;\n    var stanza = new Stanza('iq', {\n      type: 'set',\n      to: this.jid.domain,\n      id: IQID_SESSION\n    }).c('session', {\n      xmlns: NS_XMPP_SESSION\n    });\n    this.send(stanza);\n  } else if (this.state === STATE_AUTHED) {\n    /* Ok, we're authenticated and all features have been\n       processed */\n    this.state = STATE_ONLINE;\n    this.emit('online', {\n      jid: this.jid\n    });\n  }\n};\n\nClient.prototype.doRegister = function () {\n  var id = 'register' + Math.ceil(Math.random() * 99999);\n  var iq = new Stanza('iq', {\n    type: 'set',\n    id: id,\n    to: this.jid.domain\n  }).c('query', {\n    xmlns: NS_REGISTER\n  }).c('username').t(this.jid.local).up().c('password').t(this.password);\n  this.send(iq);\n  var self = this;\n\n  var onReply = function onReply(reply) {\n    if (reply.is('iq') && reply.attrs.id === id) {\n      self.removeListener('stanza', onReply);\n\n      if (reply.attrs.type === 'result') {\n        /* Registration successful, proceed to auth */\n        self.useFeatures();\n      } else {\n        self.emit('error', new Error('Registration error'));\n      }\n    }\n  };\n\n  this.on('stanza:preauth', onReply);\n};\n/**\n * returns all registered sasl mechanisms\n */\n\n\nClient.prototype.getSaslMechanisms = function () {\n  return this.availableSaslMechanisms;\n};\n/**\n * removes all registered sasl mechanisms\n */\n\n\nClient.prototype.clearSaslMechanism = function () {\n  this.availableSaslMechanisms = [];\n};\n/**\n * register a new sasl mechanism\n */\n\n\nClient.prototype.registerSaslMechanism = function (method) {\n  // check if method is registered\n  if (this.availableSaslMechanisms.indexOf(method) === -1) {\n    this.availableSaslMechanisms.push(method);\n  }\n};\n/**\n * unregister an existing sasl mechanism\n */\n\n\nClient.prototype.unregisterSaslMechanism = function (method) {\n  // check if method is registered\n  var index = this.availableSaslMechanisms.indexOf(method);\n\n  if (index >= 0) {\n    this.availableSaslMechanisms = this.availableSaslMechanisms.splice(index, 1);\n  }\n};\n\nmodule.exports = Client;","map":null,"metadata":{},"sourceType":"script"}