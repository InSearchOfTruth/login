{"ast":null,"code":"'use strict';\n/*\n * User's callbacks (listener-functions):\n * - onCallListener(session, extension)\n * - onAcceptCallListener(session, userID, extension)\n * - onRejectCallListener(session, userID, extension)\n * - onStopCallListener(session, userID, extension)\n * - onUpdateCallListener(session, userID, extension)\n * - onInvalidEventsListener (state, session, userID, extension)\n * - onDevicesChangeListener()\n */\n\nvar WebRTCSession = require('./cubeWebRTCSession');\n\nvar WebRTCSignalingProcessor = require('./cubeWebRTCSignalingProcessor');\n\nvar WebRTCSignalingProvider = require('./cubeWebRTCSignalingProvider');\n\nvar Helpers = require('./cubeWebRTCHelpers');\n\nvar RTCPeerConnection = require('./cubeRTCPeerConnection');\n\nvar SignalingConstants = require('./cubeWebRTCSignalingConstants');\n\nvar Utils = require('../cubeInternalUtils');\n\nvar mediaDevices = require('../cubeDependencies').mediaDevices;\n\nfunction WebRTCClient(service, connection) {\n  if (WebRTCClient.__instance) {\n    return WebRTCClient.__instance;\n  } else if (this === window) {\n    return new WebRTCClient();\n  }\n\n  WebRTCClient.__instance = this; // Initialise all properties here\n\n  this.connection = connection;\n  this.signalingProcessor = new WebRTCSignalingProcessor(service, this, connection);\n  this.signalingProvider = new WebRTCSignalingProvider(service, connection);\n  this.SessionConnectionState = Helpers.SessionConnectionState;\n  this.CallType = Helpers.CallType;\n  this.PeerConnectionState = RTCPeerConnection.State;\n  this.sessions = {};\n\n  if (mediaDevices) {\n    mediaDevices.ondevicechange = this._onDevicesChangeListener.bind(this);\n  }\n}\n/**\n * [Return data or all active devices]\n * @param  {String} spec [specify what type of devices you wnat to get.\n *                         Possible values: audioinput, audiooutput, videoinput]\n * @returns {Array}       [array of devices]\n */\n\n\nWebRTCClient.prototype.getMediaDevices = function (spec) {\n  var specDevices = [],\n      errMsg = 'Browser does not support output device selection.';\n  return new Promise(function (resolve, reject) {\n    if (!mediaDevices || !mediaDevices.enumerateDevices) {\n      reject(errMsg);\n      Helpers.traceWarning(errMsg);\n    } else {\n      mediaDevices.enumerateDevices().then(function (devices) {\n        if (spec) {\n          devices.forEach(function (device, i) {\n            if (device.kind === spec) {\n              specDevices.push(device);\n            }\n          });\n          resolve(specDevices);\n        } else {\n          resolve(devices);\n        }\n      });\n    }\n  });\n};\n/**\n * A map with all sessions the user had/have.\n * @type {Object.<string, Object>}\n */\n\n\nWebRTCClient.prototype.sessions = {};\n/**\n * Creates the new session.\n * @param  {array} opponentsIDs      - Opponents IDs\n * @param  {number} callType          - Call type\n * @param  {object} [opts]\n * @param  {number} [opts.bandwidth=0] - Bandwidth limit (kbps)\n */\n\nWebRTCClient.prototype.createNewSession = function (opponentsIDs, callType, opts) {\n  var opponentsIdNASessions = getOpponentsIdNASessions(this.sessions),\n      callerID = Helpers.getIdFromNode(Helpers.userCurrentJid(this.connection)),\n      bandwidth = opts && opts.bandwidth && !isNaN(opts.bandwidth) ? +opts.bandwidth : 0,\n      isIdentifyOpponents = false;\n\n  if (!opponentsIDs) {\n    throw new Error('Can\\'t create a session without the opponentsIDs.');\n  }\n\n  isIdentifyOpponents = isOpponentsEqual(opponentsIdNASessions, opponentsIDs);\n\n  if (!isIdentifyOpponents) {\n    return this._createAndStoreSession(null, callerID, opponentsIDs, callType, bandwidth);\n  } else {\n    throw new Error('Can\\'t create a session with the same opponentsIDs. There is a session already in NEW or ACTIVE state.');\n  }\n};\n\nWebRTCClient.prototype._createAndStoreSession = function (sessionID, callerID, opponentsIDs, callType, bandwidth) {\n  var newSession = new WebRTCSession({\n    sessionID: sessionID,\n    initiatorID: callerID,\n    opIDs: opponentsIDs,\n    callType: callType,\n    signalingProvider: this.signalingProvider,\n    currentUserID: Helpers.getIdFromNode(Helpers.userCurrentJid(this.connection)),\n    bandwidth: bandwidth\n  });\n  /** set callbacks */\n\n  newSession.onUserNotAnswerListener = this.onUserNotAnswerListener;\n  newSession.onRemoteStreamListener = this.onRemoteStreamListener;\n  newSession.onSessionConnectionStateChangedListener = this.onSessionConnectionStateChangedListener;\n  newSession.onSessionCloseListener = this.onSessionCloseListener;\n  newSession.onCallStatsReport = this.onCallStatsReport;\n  this.sessions[newSession.ID] = newSession;\n  return newSession;\n};\n/**\n * Deletes a session\n * @param {string} Session ID\n *\n */\n\n\nWebRTCClient.prototype.clearSession = function (sessionId) {\n  delete this.sessions[sessionId];\n};\n/**\n * Check all session and find session with status 'NEW' or 'ACTIVE' which ID != provided\n * @param {string} session ID\n * @returns {boolean} if active or new session exist\n */\n\n\nWebRTCClient.prototype.isExistNewOrActiveSessionExceptSessionID = function (sessionID) {\n  var self = this;\n  var exist = false;\n\n  if (Object.keys(self.sessions).length > 0) {\n    Object.keys(self.sessions).forEach(function (key, i, arr) {\n      var session = self.sessions[key];\n\n      if (session.state === WebRTCSession.State.NEW || session.state === WebRTCSession.State.ACTIVE) {\n        if (session.ID !== sessionID) {\n          exist = true; // break; // break doesn't work in 'forEach', need to find another way\n        }\n      }\n    });\n  }\n\n  return exist;\n};\n/**\n * DELEGATE (signaling)\n */\n\n\nWebRTCClient.prototype._onCallListener = function (userID, sessionID, extension) {\n  var userInfo = extension.userInfo || {};\n  Helpers.trace(\"onCall. UserID:\" + userID + \". SessionID: \" + sessionID);\n\n  if (this.isExistNewOrActiveSessionExceptSessionID(sessionID)) {\n    Helpers.trace('User with id ' + userID + ' is busy at the moment.');\n    delete extension.sdp;\n    delete extension.platform;\n    extension.sessionID = sessionID;\n    this.signalingProvider.sendMessage(userID, extension, SignalingConstants.SignalingType.REJECT);\n\n    if (typeof this.onInvalidEventsListener === 'function') {\n      Utils.safeCallbackCall(this.onInvalidEventsListener, 'onCall', sessionID, userID, userInfo);\n    }\n  } else {\n    var session = this.sessions[sessionID];\n    var bandwidth = +userInfo.bandwidth || 0;\n\n    if (!session) {\n      session = this._createAndStoreSession(sessionID, extension.callerID, extension.opponentsIDs, extension.callType, bandwidth);\n      session.processOnCall(userID, extension);\n\n      if (typeof this.onCallListener === 'function') {\n        Utils.safeCallbackCall(this.onCallListener, session, userInfo);\n      }\n    } else {\n      session.processOnCall(userID, extension);\n    }\n  }\n};\n\nWebRTCClient.prototype._onAcceptListener = function (userID, sessionID, extension) {\n  var session = this.sessions[sessionID],\n      userInfo = extension.userInfo || {};\n  Helpers.trace(\"onAccept. UserID:\" + userID + \". SessionID: \" + sessionID);\n\n  if (session) {\n    if (session.state === WebRTCSession.State.ACTIVE) {\n      if (typeof this.onAcceptCallListener === 'function') {\n        Utils.safeCallbackCall(this.onAcceptCallListener, session, userID, userInfo);\n      }\n\n      session.processOnAccept(userID, extension);\n    } else {\n      if (typeof this.onInvalidEventsListener === 'function') {\n        Utils.safeCallbackCall(this.onInvalidEventsListener, 'onAccept', session, userID, userInfo);\n      }\n\n      Helpers.traceWarning(\"Ignore 'onAccept', the session( \" + sessionID + \" ) has invalid state.\");\n    }\n  } else {\n    Helpers.traceError(\"Ignore 'onAccept', there is no information about session \" + sessionID + \" by some reason.\");\n  }\n};\n\nWebRTCClient.prototype._onRejectListener = function (userID, sessionID, extension) {\n  var that = this,\n      session = that.sessions[sessionID];\n  Helpers.trace(\"onReject. UserID:\" + userID + \". SessionID: \" + sessionID);\n\n  if (session) {\n    var userInfo = extension.userInfo || {};\n\n    if (typeof this.onRejectCallListener === 'function') {\n      Utils.safeCallbackCall(that.onRejectCallListener, session, userID, userInfo);\n    }\n\n    session.processOnReject(userID, extension);\n  } else {\n    Helpers.traceError(\"Ignore 'onReject', there is no information about session \" + sessionID + \" by some reason.\");\n  }\n};\n\nWebRTCClient.prototype._onStopListener = function (userID, sessionID, extension) {\n  Helpers.trace(\"onStop. UserID:\" + userID + \". SessionID: \" + sessionID);\n  var session = this.sessions[sessionID],\n      userInfo = extension.userInfo || {};\n\n  if (session && (session.state === WebRTCSession.State.ACTIVE || session.state === WebRTCSession.State.NEW)) {\n    if (typeof this.onStopCallListener === 'function') {\n      Utils.safeCallbackCall(this.onStopCallListener, session, userID, userInfo);\n    } // Need to make this asynchronously, to keep the strophe handler alive\n\n\n    setTimeout(session.processOnStop.bind(session), 10, userID, extension);\n  } else {\n    if (typeof this.onInvalidEventsListener === 'function') {\n      Utils.safeCallbackCall(this.onInvalidEventsListener, 'onStop', session, userID, userInfo);\n    }\n\n    Helpers.traceError(\"Ignore 'onStop', there is no information about session \" + sessionID + \" by some reason.\");\n  }\n};\n\nWebRTCClient.prototype._onIceCandidatesListener = function (userID, sessionID, extension) {\n  var session = this.sessions[sessionID];\n  Helpers.trace(\"onIceCandidates. UserID:\" + userID + \". SessionID: \" + sessionID + \". ICE candidates count: \" + extension.iceCandidates.length);\n\n  if (session) {\n    if (session.state === WebRTCSession.State.ACTIVE) {\n      session.processOnIceCandidates(userID, extension);\n    } else {\n      Helpers.traceWarning('Ignore \\'OnIceCandidates\\', the session ( ' + sessionID + ' ) has invalid state.');\n    }\n  } else {\n    Helpers.traceError(\"Ignore 'OnIceCandidates', there is no information about session \" + sessionID + \" by some reason.\");\n  }\n};\n\nWebRTCClient.prototype._onUpdateListener = function (userID, sessionID, extension) {\n  var session = this.sessions[sessionID],\n      userInfo = extension.userInfo || {};\n  Helpers.trace(\"onUpdate. UserID:\" + userID + \". SessionID: \" + sessionID + \". Extension: \" + JSON.stringify(userInfo));\n\n  if (typeof this.onUpdateCallListener === 'function') {\n    Utils.safeCallbackCall(this.onUpdateCallListener, session, userID, userInfo);\n  }\n};\n\nWebRTCClient.prototype._onDevicesChangeListener = function () {\n  if (typeof this.onDevicesChangeListener === 'function') {\n    Utils.safeCallbackCall(this.onDevicesChangeListener);\n  }\n};\n\nmodule.exports = WebRTCClient;\n/**\n * PRIVATE FUNCTIONS\n */\n\nfunction isOpponentsEqual(exOpponents, currentOpponents) {\n  var ans = false,\n      cOpponents = currentOpponents.sort();\n\n  if (exOpponents.length) {\n    exOpponents.forEach(function (i) {\n      var array = i.sort();\n      ans = array.length == cOpponents.length && array.every(function (el, index) {\n        return el === cOpponents[index];\n      });\n    });\n  }\n\n  return ans;\n}\n\nfunction getOpponentsIdNASessions(sessions) {\n  var opponents = [];\n\n  if (Object.keys(sessions).length > 0) {\n    Object.keys(sessions).forEach(function (key, i, arr) {\n      var session = sessions[key];\n\n      if (session.state === WebRTCSession.State.NEW || session.state === WebRTCSession.State.ACTIVE) {\n        opponents.push(session.opponentsIDs);\n      }\n    });\n  }\n\n  return opponents;\n}","map":null,"metadata":{},"sourceType":"script"}