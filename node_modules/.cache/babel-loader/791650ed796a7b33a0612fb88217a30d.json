{"ast":null,"code":"'use strict';\n\nvar net = require('net');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar inherits = require('inherits');\n\nvar Element = require('@xmpp/xml').Element;\n\nvar reconnect = require('reconnect-core');\n\nvar StreamParser = require('@xmpp/streamparser');\n\nvar starttls = require('node-xmpp-tls-connect');\n\nvar debug = require('debug')('xmpp:connection');\n\nvar assign = require('lodash.assign');\n\nvar NS_XMPP_TLS = 'urn:ietf:params:xml:ns:xmpp-tls';\nvar NS_STREAM = 'http://etherx.jabber.org/streams';\nvar NS_XMPP_STREAMS = 'urn:ietf:params:xml:ns:xmpp-streams';\nvar INITIAL_RECONNECT_DELAY = 1e3;\nvar MAX_RECONNECT_DELAY = 30e3;\nvar STREAM_OPEN = 'stream:stream';\nvar STREAM_CLOSE = '</stream:stream>';\n\nfunction defaultInjection(emitter, opts) {\n  // clone opts\n  var options = assign({}, opts); // add computed options\n\n  options.initialDelay = opts && (opts.initialReconnectDelay || opts.reconnectDelay) || INITIAL_RECONNECT_DELAY;\n  options.maxDelay = opts && opts.maxReconnectDelay || MAX_RECONNECT_DELAY;\n  options.immediate = opts && opts.socket && typeof opts.socket !== 'function';\n  options.type = opts && opts.delayType;\n  options.emitter = emitter; // return calculated options\n\n  return options;\n}\n/**\n Base class for connection-based streams (TCP).\n The socket parameter is optional for incoming connections.\n*/\n\n\nfunction Connection(opts) {\n  EventEmitter.call(this);\n  this.streamAttrs = opts && opts.streamAttrs || {};\n  this.xmlns = opts && opts.xmlns || {};\n  this.xmlns.stream = NS_STREAM;\n  this.streamOpen = opts && opts.streamOpen || STREAM_OPEN;\n  this.streamClose = opts && opts.streamClose || STREAM_CLOSE;\n  this.rejectUnauthorized = !!(opts && opts.rejectUnauthorized);\n  this.serialized = !!(opts && opts.serialized);\n  this.requestCert = !!(opts && opts.requestCert);\n  this.servername = opts && opts.servername;\n  this.boundOnData = this.onData.bind(this);\n  this.boundOnClose = this.onClose.bind(this);\n  this.boundEmitData = this.emit.bind(this, 'data');\n  this.boundEmitDrain = this.emit.bind(this, 'drain');\n\n  this._setupSocket(defaultInjection(this, opts));\n\n  this.once('reconnect', function () {\n    this.reconnect = opts && opts.reconnect;\n  });\n}\n\ninherits(Connection, EventEmitter);\nConnection.prototype.NS_XMPP_TLS = NS_XMPP_TLS;\nConnection.NS_STREAM = NS_STREAM;\nConnection.prototype.NS_XMPP_STREAMS = NS_XMPP_STREAMS; // Defaults\n\nConnection.prototype.allowTLS = true;\n\nConnection.prototype._setupSocket = function (options) {\n  debug('setup socket');\n  var previousOptions = {};\n  var inject = reconnect(function (opts) {\n    var previousSocket = this.socket;\n    /* if this opts.preserve is on\n     * the previous options are stored until next time.\n     * this is needed to restore from a setSecure call.\n     */\n\n    if (opts.preserve === 'on') {\n      opts.preserve = previousOptions;\n      previousOptions = opts;\n    } else if (opts.preserve) {\n      // switch back to the preversed options\n      opts = previousOptions = opts.preserve;\n    } else {\n      // keep some state for eg SRV.connect\n      opts = previousOptions = opts || previousOptions;\n    }\n\n    if (typeof opts.socket === 'function') {\n      debug('use lazy socket');\n      /* lazy evaluation\n       * (can be retriggered by calling connection.connect()\n       *  without arguments after a previous\n       *  connection.connect({socket:function() { â€¦ }})) */\n\n      this.socket = opts.socket.call(this);\n    } else {\n      debug('use standard socket'); // only use this socket once\n\n      this.socket = opts.socket;\n      opts.socket = null;\n\n      if (this.socket) {\n        this.once('connect', function () {\n          inject.options.immediate = false;\n        });\n      }\n    }\n\n    this.socket = this.socket || new net.Socket();\n\n    if (previousSocket !== this.socket) {\n      this.setupStream();\n    }\n\n    return this.socket;\n  }.bind(this));\n  inject(inject.options = options); // wrap the end function provided by reconnect-core to trigger the stream end logic\n\n  var end = this.end;\n\n  this.end = this.disconnect = function () {\n    this.closeStream();\n    end();\n  };\n\n  this.on('connection', function () {\n    if (!this.parser) this.startParser();\n  });\n  this.on('end', function () {\n    previousOptions = {};\n  });\n};\n/**\n Used by both the constructor and by reinitialization in setSecure().\n*/\n\n\nConnection.prototype.setupStream = function () {\n  debug('setup stream');\n  this.socket.on('end', this.onEnd.bind(this));\n  this.socket.on('data', this.boundOnData);\n  this.socket.on('close', this.boundOnClose); // let them sniff unparsed XML\n\n  this.socket.on('data', this.boundEmitData);\n  this.socket.on('drain', this.boundEmitDrain); // ignore errors after disconnect\n\n  this.socket.on('error', function () {});\n\n  if (!this.socket.serializeStanza) {\n    /**\n    * This is optimized for continuous TCP streams. If your \"socket\"\n    * actually transports frames (WebSockets) and you can't have\n    * stanzas split across those, use:\n    *     cb(el.toString())\n    */\n    if (this.serialized) {\n      this.socket.serializeStanza = function (el, cb) {\n        // Continuously write out\n        el.write(function (s) {\n          cb(s);\n        });\n      };\n    } else {\n      this.socket.serializeStanza = function (el, cb) {\n        cb(el.toString());\n      };\n    }\n  }\n};\n\nConnection.prototype.pause = function () {\n  if (this.socket.pause) this.socket.pause();\n};\n\nConnection.prototype.resume = function () {\n  if (this.socket.resume) this.socket.resume();\n};\n/** Climbs the stanza up if a child was passed,\n    but you can send strings and buffers too.\n\n    Returns whether the socket flushed data.\n*/\n\n\nConnection.prototype.send = function (stanza) {\n  if (!this.socket || !this.streamOpened) return;\n\n  if (!this.socket.writable) {\n    this.socket.end();\n    return;\n  }\n\n  debug('send: ' + stanza.toString());\n  var flushed = true;\n\n  if (stanza.root) {\n    var el = this.rmXmlns(stanza.root());\n    this.socket.serializeStanza(el, function (s) {\n      flushed = this.write(s);\n    }.bind(this.socket));\n  } else {\n    flushed = this.socket.write(stanza);\n  }\n\n  return flushed;\n};\n\nConnection.prototype.startParser = function () {\n  var self = this;\n  this.parser = new StreamParser(this.maxStanzaSize);\n  this.parser.on('streamStart', function (attrs) {\n    /* We need those xmlns often, store them extra */\n    self.streamNsAttrs = {};\n\n    for (var k in attrs) {\n      if (k === 'xmlns' || k.substr(0, 6) === 'xmlns:') {\n        self.streamNsAttrs[k] = attrs[k];\n      }\n    }\n    /* Notify in case we don't wait for <stream:features/>\n       (Component or non-1.0 streams)\n     */\n\n\n    self.emit('streamStart', attrs);\n  });\n  this.parser.on('stanza', function (stanza) {\n    self.onStanza(self.addStreamNs(stanza));\n  });\n  this.parser.on('error', function (e) {\n    self.error(e.condition || 'internal-server-error', e.message);\n  });\n  this.parser.once('end', function () {\n    self.stopParser();\n\n    if (self.reconnect) {\n      self.once('reconnect', self.startParser.bind(self));\n    } else {\n      self.end();\n    }\n  });\n};\n\nConnection.prototype.stopParser = function () {\n  /* No more events, please (may happen however) */\n  if (this.parser) {\n    var parser = this.parser;\n    /* Get GC'ed */\n\n    this.parser = null;\n    parser.end();\n  }\n};\n/**\n * http://xmpp.org/rfcs/rfc6120.html#streams-open\n */\n\n\nConnection.prototype.openStream = function () {\n  var attrs = {};\n\n  for (var k in this.xmlns) {\n    if (this.xmlns.hasOwnProperty(k)) {\n      if (!k) {\n        attrs.xmlns = this.xmlns[k];\n      } else {\n        attrs['xmlns:' + k] = this.xmlns[k];\n      }\n    }\n  }\n\n  for (k in this.streamAttrs) {\n    if (this.streamAttrs.hasOwnProperty(k)) {\n      attrs[k] = this.streamAttrs[k];\n    }\n  }\n\n  if (this.streamTo) {\n    // in case of a component connecting\n    attrs.to = this.streamTo;\n  }\n\n  var el = new Element(this.streamOpen, attrs);\n  var streamOpen;\n\n  if (el.name === 'stream:stream') {\n    // make it non-empty to cut the closing tag\n    el.t(' ');\n    var s = el.toString();\n    streamOpen = s.substr(0, s.indexOf(' </stream:stream>'));\n  } else {\n    streamOpen = el.toString();\n  }\n\n  this.streamOpened = true;\n  this.send(streamOpen);\n}; // FIXME deprecate\n\n\nConnection.prototype.startStream = Connection.prototype.openStream;\n/**\n * http://xmpp.org/rfcs/rfc6120.html#streams-close\n */\n\nConnection.prototype.closeStream = function () {\n  this.send(this.streamClose);\n  this.streamOpened = false;\n}; // FIXME deprecate\n\n\nConnection.prototype.endStream = Connection.prototype.closeStream;\n\nConnection.prototype.onData = function (data) {\n  debug('receive: ' + data.toString('utf8'));\n\n  if (this.parser) {\n    this.parser.write(data);\n  }\n};\n\nConnection.prototype.setSecure = function (credentials, isServer, servername) {\n  // Remove old event listeners\n  this.socket.removeListener('data', this.boundOnData);\n  this.socket.removeListener('data', this.boundEmitData); // retain socket 'end' listeners because ssl layer doesn't support it\n\n  this.socket.removeListener('drain', this.boundEmitDrain);\n  this.socket.removeListener('close', this.boundOnClose); // remove idle_timeout\n\n  if (this.socket.clearTimer) {\n    this.socket.clearTimer();\n  }\n\n  var cleartext = starttls({\n    socket: this.socket,\n    rejectUnauthorized: this.rejectUnauthorized,\n    credentials: credentials || this.credentials,\n    requestCert: this.requestCert,\n    isServer: !!isServer,\n    servername: isServer && servername\n  }, function () {\n    this.isSecure = true;\n    this.once('disconnect', function () {\n      this.isSecure = false;\n    });\n    cleartext.emit('connect', cleartext);\n  }.bind(this));\n  cleartext.on('clientError', this.emit.bind(this, 'error'));\n\n  if (!this.reconnect) {\n    this.reconnect = true; // need this so stopParser works properly\n\n    this.once('reconnect', function () {\n      this.reconnect = false;\n    });\n  }\n\n  this.stopParser(); // if we reconnect we need to get back to the previous socket creation\n\n  this.listen({\n    socket: cleartext,\n    preserve: 'on'\n  });\n};\n\nfunction getAllText(el) {\n  return !el.children ? el : el.children.reduce(function (text, child) {\n    return text + getAllText(child);\n  }, '');\n}\n/**\n * This is not an event listener, but takes care of the TLS handshake\n * before 'stanza' events are emitted to the derived classes.\n */\n\n\nConnection.prototype.onStanza = function (stanza) {\n  if (stanza.is('error', NS_STREAM)) {\n    var error = new Error('' + getAllText(stanza));\n    error.stanza = stanza;\n    this.socket.emit('error', error);\n  } else if (stanza.is('features', this.NS_STREAM) && this.allowTLS && !this.isSecure && stanza.getChild('starttls', this.NS_XMPP_TLS)) {\n    /* Signal willingness to perform TLS handshake */\n    this.send(new Element('starttls', {\n      xmlns: this.NS_XMPP_TLS\n    }));\n  } else if (this.allowTLS && stanza.is('proceed', this.NS_XMPP_TLS)) {\n    /* Server is waiting for TLS handshake */\n    this.setSecure();\n  } else {\n    this.emit('stanza', stanza);\n  }\n};\n/**\n * Add stream xmlns to a stanza\n *\n * Does not add our default xmlns as it is different for\n * C2S/S2S/Component connections.\n */\n\n\nConnection.prototype.addStreamNs = function (stanza) {\n  for (var attr in this.streamNsAttrs) {\n    if (!stanza.attrs[attr] && !(attr === 'xmlns' && this.streamNsAttrs[attr] === this.xmlns[''])) {\n      stanza.attrs[attr] = this.streamNsAttrs[attr];\n    }\n  }\n\n  return stanza;\n};\n/**\n * Remove superfluous xmlns that were aleady declared in\n * our <stream:stream>\n */\n\n\nConnection.prototype.rmXmlns = function (stanza) {\n  for (var prefix in this.xmlns) {\n    var attr = prefix ? 'xmlns:' + prefix : 'xmlns';\n\n    if (stanza.attrs[attr] === this.xmlns[prefix]) {\n      stanza.attrs[attr] = null;\n    }\n  }\n\n  return stanza;\n};\n/**\n * XMPP-style end connection for user\n */\n\n\nConnection.prototype.onEnd = function () {\n  this.closeStream();\n\n  if (!this.reconnect) {\n    this.emit('end');\n  }\n};\n\nConnection.prototype.onClose = function () {\n  if (!this.reconnect) {\n    this.emit('close');\n  }\n};\n/**\n * End connection with stream error.\n * Emits 'error' event too.\n *\n * @param {String} condition XMPP error condition, see RFC3920 4.7.3. Defined Conditions\n * @param {String} text Optional error message\n */\n\n\nConnection.prototype.error = function (condition, message) {\n  this.emit('error', new Error(message));\n  if (!this.socket || !this.socket.writable) return;\n  /* RFC 3920, 4.7.1 stream-level errors rules */\n\n  if (!this.streamOpened) this.openStream();\n  var error = new Element('stream:error');\n  error.c(condition, {\n    xmlns: NS_XMPP_STREAMS\n  });\n\n  if (message) {\n    error.c('text', {\n      xmlns: NS_XMPP_STREAMS,\n      'xml:lang': 'en'\n    }).t(message);\n  }\n\n  this.send(error);\n  this.end();\n};\n\nmodule.exports = Connection;","map":null,"metadata":{},"sourceType":"script"}