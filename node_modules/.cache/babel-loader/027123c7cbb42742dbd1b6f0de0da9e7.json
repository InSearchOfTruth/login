{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"D:\\\\practics\\\\ConnectyCube\\\\test\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:\\\\practics\\\\ConnectyCube\\\\test\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _require = require('./lib/b64'),\n    encode = _require.encode,\n    decode = _require.decode;\n\nvar SASLError = require('./lib/SASLError');\n\nvar xml = require('@xmpp/xml');\n\nvar SASLFactory = require('saslmechanisms'); // https://xmpp.org/rfcs/rfc6120.html#sasl\n\n\nvar NS = 'urn:ietf:params:xml:ns:xmpp-sasl';\n\nfunction getMechanismNames(features) {\n  return features.getChild('mechanisms', NS).children.map(function (el) {\n    return el.text();\n  });\n}\n\nfunction getAvailableMechanisms(SASL) {\n  return SASL._mechs.map(function (_ref) {\n    var name = _ref.name;\n    return name;\n  });\n}\n\nfunction getUsableMechanisms(SASL, mechs) {\n  var supported = getAvailableMechanisms(SASL);\n  return mechs.filter(function (mech) {\n    return supported.indexOf(mech) > -1;\n  });\n}\n\nfunction getMechanism(usable) {\n  return usable[0]; // FIXME prefer SHA-1, ... maybe order usable, available, ... by preferred?\n}\n\nfunction findMechanism(SASL, name) {\n  return SASL.create([name]);\n}\n\nfunction handleMechanism(_x, _x2, _x3, _x4, _x5) {\n  return _handleMechanism.apply(this, arguments);\n}\n\nfunction _handleMechanism() {\n  _handleMechanism = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(SASL, entity, mech, features, credentials) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!(typeof credentials === 'function')) {\n              _context2.next = 5;\n              break;\n            }\n\n            _context2.next = 3;\n            return credentials(function (creds) {\n              return authenticate(SASL, entity, mech, creds, features);\n            }, mech);\n\n          case 3:\n            _context2.next = 7;\n            break;\n\n          case 5:\n            _context2.next = 7;\n            return authenticate(SASL, entity, mech, credentials, features);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _handleMechanism.apply(this, arguments);\n}\n\nfunction gotFeatures(SASL, entity, features, credentials) {\n  var offered = getMechanismNames(features);\n  var usable = getUsableMechanisms(SASL, offered);\n  var mech = getMechanism(usable);\n  return handleMechanism(SASL, entity, mech, features, credentials);\n} // eslint-disable-next-line require-await\n\n\nfunction authenticate(_x6, _x7, _x8, _x9) {\n  return _authenticate.apply(this, arguments);\n}\n\nfunction _authenticate() {\n  _authenticate = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee3(SASL, entity, mechname, credentials) {\n    var mech, domain, creds;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            mech = findMechanism(SASL, mechname);\n\n            if (mech) {\n              _context3.next = 3;\n              break;\n            }\n\n            throw new Error('No compatible mechanism');\n\n          case 3:\n            domain = entity.options.domain;\n            creds = Object.assign({\n              username: null,\n              password: null,\n              server: domain,\n              host: domain,\n              realm: domain,\n              serviceType: 'xmpp',\n              serviceName: domain\n            }, credentials);\n            return _context3.abrupt(\"return\", new Promise(function (resolve, reject) {\n              var handler = function handler(element) {\n                if (element.attrs.xmlns !== NS) {\n                  return;\n                }\n\n                if (element.name === 'challenge') {\n                  mech.challenge(decode(element.text()));\n                  var resp = mech.response(creds);\n                  entity.send(xml('response', {\n                    xmlns: NS,\n                    mechanism: mech.name\n                  }, typeof resp === 'string' ? encode(resp) : ''));\n                  return;\n                }\n\n                if (element.name === 'failure') {\n                  reject(SASLError.fromElement(element));\n                } else if (element.name === 'success') {\n                  resolve();\n                }\n\n                entity.removeListener('nonza', handler);\n              };\n\n              entity.on('nonza', handler);\n\n              if (mech.clientFirst) {\n                entity.send(xml('auth', {\n                  xmlns: NS,\n                  mechanism: mech.name\n                }, encode(mech.response(creds))));\n              }\n            }));\n\n          case 6:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _authenticate.apply(this, arguments);\n}\n\nmodule.exports = function sasl(_ref2, credentials) {\n  var streamFeatures = _ref2.streamFeatures;\n  var SASL = new SASLFactory();\n  streamFeatures.use('mechanisms', NS,\n  /*#__PURE__*/\n  function () {\n    var _ref4 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee(_ref3) {\n      var stanza, entity;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              stanza = _ref3.stanza, entity = _ref3.entity;\n              _context.prev = 1;\n              _context.next = 4;\n              return gotFeatures(SASL, entity, stanza, credentials);\n\n            case 4:\n              _context.next = 6;\n              return entity.restart();\n\n            case 6:\n              _context.next = 11;\n              break;\n\n            case 8:\n              _context.prev = 8;\n              _context.t0 = _context[\"catch\"](1);\n              throw _context.t0;\n\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[1, 8]]);\n    }));\n\n    return function (_x10) {\n      return _ref4.apply(this, arguments);\n    };\n  }());\n  return {\n    use: function use() {\n      return SASL.use.apply(SASL, arguments);\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}