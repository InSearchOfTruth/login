{"ast":null,"code":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar core = require('node-xmpp-core');\n\nvar Element = core.Element;\nvar StreamParser = core.StreamParser;\nvar Connection = core.Connection;\nvar inherits = core.inherits;\n\nvar ws = require('ws'); // we ignore ws in the browser field of package.json\n\n\nvar WebSocket = ws.Server ? ws : window.WebSocket;\n\nvar debug = require('debug')('xmpp:client:websocket');\n\nvar NS_FRAMING = 'urn:ietf:params:xml:ns:xmpp-framing';\n\nfunction WSConnection(opts) {\n  EventEmitter.call(this);\n  this.url = opts.websocket.url;\n  this.jid = opts.jid;\n  this.xmlns = {\n    '': NS_FRAMING\n  };\n  this.websocket = new WebSocket(this.url, ['xmpp'], opts.websocket.options);\n  this.websocket.onopen = this.onopen.bind(this);\n  this.websocket.onmessage = this.onmessage.bind(this);\n  this.websocket.onclose = this.onclose.bind(this);\n  this.websocket.onerror = this.onerror.bind(this);\n}\n\ninherits(WSConnection, EventEmitter);\nWSConnection.prototype.maxStanzaSize = 65535;\nWSConnection.prototype.xmppVersion = '1.0';\n\nWSConnection.prototype.onopen = function () {\n  this.startParser();\n  this.emit('connected');\n};\n\nWSConnection.prototype.startParser = function () {\n  var self = this;\n  this.parser = new StreamParser(this.maxStanzaSize);\n  this.parser.on('start', function (attrs) {\n    self.streamAttrs = attrs;\n    /* We need those xmlns often, store them extra */\n\n    self.streamNsAttrs = {};\n\n    for (var k in attrs) {\n      if (k === 'xmlns' || k.substr(0, 6) === 'xmlns:') {\n        self.streamNsAttrs[k] = attrs[k];\n      }\n    }\n    /* Notify in case we don't wait for <stream:features/>\n       (Component or non-1.0 streams)\n     */\n\n\n    self.emit('streamStart', attrs);\n  });\n  this.parser.on('stanza', function (stanza) {\n    // self.onStanza(self.addStreamNs(stanza))\n    self.onStanza(stanza);\n  });\n  this.parser.on('error', this.onerror.bind(this));\n  this.parser.on('end', function () {\n    self.stopParser();\n    self.end();\n  });\n};\n\nWSConnection.prototype.stopParser = function () {\n  /* No more events, please (may happen however) */\n  if (this.parser) {\n    /* Get GC'ed */\n    delete this.parser;\n  }\n};\n\nWSConnection.prototype.onmessage = function (msg) {\n  debug('ws msg <--', msg.data);\n\n  if (msg && msg.data && this.parser) {\n    this.parser.write(msg.data);\n  }\n};\n\nWSConnection.prototype.onStanza = function (stanza) {\n  if (stanza.is('error', Connection.NS_STREAM)) {\n    /* TODO: extract error text */\n    this.emit('error', stanza);\n  } else {\n    this.emit('stanza', stanza);\n  }\n};\n\nWSConnection.prototype.startStream = function () {\n  var attrs = {};\n\n  for (var k in this.xmlns) {\n    if (this.xmlns.hasOwnProperty(k)) {\n      if (!k) {\n        attrs.xmlns = this.xmlns[k];\n      } else {\n        attrs['xmlns:' + k] = this.xmlns[k];\n      }\n    }\n  }\n\n  if (this.xmppVersion) attrs.version = this.xmppVersion;\n  if (this.streamTo) attrs.to = this.streamTo;\n  if (this.jid) attrs.to = this.jid.domain;\n  this.send(new Element('open', attrs));\n  this.streamOpened = true;\n};\n\nWSConnection.prototype.send = function (stanza) {\n  if (stanza.root) stanza = stanza.root();\n\n  if (!stanza.attrs.xmlns && (stanza.is('iq') || stanza.is('presence') || stanza.is('message'))) {\n    stanza.attrs.xmlns = 'jabber:client';\n  }\n\n  stanza = stanza.toString();\n  debug('ws send -->', stanza);\n  this.websocket.send(stanza);\n};\n\nWSConnection.prototype.onclose = function () {\n  this.emit('disconnect');\n  this.emit('close');\n};\n\nWSConnection.prototype.end = function () {\n  this.send(new Element('close', {\n    xmlns: NS_FRAMING\n  }));\n  this.emit('disconnect');\n  this.emit('end');\n  if (this.websocket) this.websocket.close();\n};\n\nWSConnection.prototype.onerror = function (e) {\n  this.emit('error', e);\n};\n\nmodule.exports = WSConnection;","map":null,"metadata":{},"sourceType":"script"}