{"ast":null,"code":"var config = require('./cubeConfig'),\n    Utils = require('./cubeInternalUtils'),\n    sha1 = require('crypto-js/hmac-sha1'),\n    sha256 = require('crypto-js/hmac-sha256');\n\nfunction AuthProxy(service) {\n  this.service = service;\n  this.webSessionCheckInterval = null;\n}\n\nAuthProxy.prototype = {\n  getSession: function getSession(callback) {\n    var ajaxParams = {\n      url: Utils.getUrl(config.urls.session)\n    };\n    this.service.ajax(ajaxParams, function (err, res) {\n      callback(err, res && res.session);\n    });\n  },\n  createSession: function createSession(paramsOrCallback, callback) {\n    if (config.creds.appId === '' || config.creds.authKey === '' || config.creds.authSecret === '') {\n      throw new Error('Cannot create a new session without app credentials (app ID, auth key and auth secret)');\n    }\n\n    var self = this;\n    var route = config.urls.session,\n        message;\n\n    if (typeof paramsOrCallback === 'function' && typeof callback === 'undefined') {\n      callback = paramsOrCallback;\n      paramsOrCallback = {};\n    } // Changes URL if it's web session.\n\n\n    if (paramsOrCallback.hasOwnProperty('long')) {\n      route = config.urls.webSession;\n    } // Signature of message with SHA-1 or SHA-256 using secret key\n\n\n    message = generateAuthMsg(paramsOrCallback);\n    message.signature = signMessage(message, config.creds.authSecret);\n    var ajaxParams = {\n      url: Utils.getUrl(route),\n      type: 'POST',\n      data: message\n    };\n    this.service.ajax(ajaxParams, function (err, res) {\n      if (err) {\n        callback(err, null);\n      } else {\n        var response = res.qr_code ? res.qr_code : res.session;\n        self.service.setSession(res.session);\n        self.service.setCurrentUserId(res.session.user_id);\n        callback(null, response);\n      }\n    });\n  },\n  destroySession: function destroySession(callback) {\n    var self = this;\n    var ajaxParams = {\n      url: Utils.getUrl(config.urls.session),\n      type: 'DELETE',\n      dataType: 'text'\n    };\n    this.service.ajax(ajaxParams, function (err, res) {\n      if (err) {\n        callback(err, null);\n      } else {\n        self.service.setSession(null);\n        callback(null);\n      }\n\n      self.service.setCurrentUserId(null);\n    });\n  },\n  createWebSession: function createWebSession(paramsOrCallback, callback) {\n    var self = this;\n\n    if (typeof paramsOrCallback === 'function' && typeof callback === 'undefined') {\n      callback = paramsOrCallback;\n      paramsOrCallback = {\n        long: 0\n      };\n    } // the createSession method returns QR code for web session instead of session object\n\n\n    self.createSession(paramsOrCallback, function (err, qrCode) {\n      callback(err, qrCode);\n    });\n  },\n  checkWebSessionUntilUpgrade: function checkWebSessionUntilUpgrade(callback) {\n    var self = this,\n        interval = config.webSession.getSessionTimeInterval,\n        timeoutError = new Error('The web session check interval was stopped (timeout)');\n    var timeleft = config.webSession.getSessionTimeout;\n\n    _clearWebSessionCheckTimer();\n\n    self.webSessionCheckInterval = setInterval(function () {\n      self.getSession(function (error, session) {\n        if (error) {\n          _clearWebSessionCheckTimer();\n\n          callback(error, null);\n        } else if (session.user_id !== 0) {\n          _clearWebSessionCheckTimer();\n\n          self.service.setCurrentUserId(session.user_id);\n          self.service.setSession(session);\n          callback(null, session);\n        } else {\n          if (timeleft > interval) {\n            timeleft -= interval;\n          } else {\n            _clearWebSessionCheckTimer();\n\n            callback(timeoutError, null);\n            throw timeoutError;\n          }\n        }\n      });\n    }, interval * 1000);\n\n    function _clearWebSessionCheckTimer() {\n      if (self.webSessionCheckInterval) {\n        clearInterval(self.webSessionCheckInterval);\n      }\n    }\n\n    return self.webSessionCheckInterval;\n  },\n  upgradeWebSession: function upgradeWebSession(webToken, callback) {\n    var ajaxParams = {\n      url: Utils.getUrl(config.urls.webSession),\n      type: 'PATCH',\n      dataType: 'text',\n      data: {\n        web_token: webToken\n      }\n    };\n    this.service.ajax(ajaxParams, function (err) {\n      if (err) {\n        callback(err);\n      }\n    });\n  },\n  login: function login(params, callback) {\n    var self = this;\n    var ajaxParams = {\n      type: 'POST',\n      url: Utils.getUrl(config.urls.login),\n      data: params\n    };\n\n    function handleResponce(err, res) {\n      if (err) {\n        callback(err, null);\n      } else {\n        self.service.setCurrentUserId(res.user.id);\n        callback(null, res.user);\n      }\n    }\n\n    this.service.ajax(ajaxParams, handleResponce);\n  },\n  logout: function logout(callback) {\n    var ajaxParams = {\n      url: Utils.getUrl(config.urls.login),\n      type: 'DELETE',\n      dataType: 'text'\n    };\n    this.service.ajax(ajaxParams, callback);\n    this.service.setCurrentUserId(null);\n  }\n};\nmodule.exports = AuthProxy;\n/* Private\n---------------------------------------------------------------------- */\n\nfunction generateAuthMsg(params) {\n  var message = {\n    application_id: config.creds.appId,\n    auth_key: config.creds.authKey,\n    nonce: Utils.randomNonce(),\n    timestamp: Utils.unixTime()\n  }; // With user authorization\n\n  if (params.login && params.password) {\n    message.user = {\n      login: params.login,\n      password: params.password\n    };\n  } else if (params.email && params.password) {\n    message.user = {\n      email: params.email,\n      password: params.password\n    };\n  } else if (params.provider) {\n    // Via social networking provider (e.g. facebook, twitter etc.)\n    message.provider = params.provider;\n\n    if (params.scope) {\n      message.scope = params.scope;\n    }\n\n    if (params.keys && params.keys.token) {\n      message.keys = {\n        token: params.keys.token\n      };\n    }\n\n    if (params.keys && params.keys.secret) {\n      message.keys.secret = params.keys.secret;\n    }\n  } else if (params.hasOwnProperty('long')) {\n    message.long = params.long;\n  }\n\n  return message;\n}\n\nfunction signMessage(message, secret) {\n  var sessionMsg = Object.keys(message).map(function (val) {\n    if (typeof message[val] === 'object') {\n      return Object.keys(message[val]).map(function (val1) {\n        return val + '[' + val1 + ']=' + message[val][val1];\n      }).sort().join('&');\n    } else {\n      return val + '=' + message[val];\n    }\n  }).sort().join('&');\n  var cryptoSessionMsg;\n\n  if (config.hash === 'sha1') {\n    cryptoSessionMsg = sha1(sessionMsg, secret).toString();\n  } else if (config.hash === 'sha256') {\n    cryptoSessionMsg = sha256(sessionMsg, secret).toString();\n  } else {\n    throw new Error('Unknown crypto standards, available sha1 or sha256');\n  }\n\n  return cryptoSessionMsg;\n}","map":null,"metadata":{},"sourceType":"script"}