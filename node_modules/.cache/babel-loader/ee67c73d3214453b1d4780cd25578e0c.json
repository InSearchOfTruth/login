{"ast":null,"code":"'use strict';\n/**\n * User's callbacks (listener-functions):\n * - onUserNotAnswerListener(session, userID)\n * - onRemoteStreamListener(session, userID, stream)\n * - onSessionConnectionStateChangedListener(session, userID, connectionState)\n * - onSessionCloseListener(session)\n * - onCallStatsReport(session, userId, stats, error)\n */\n\nvar config = require('../cubeConfig');\n\nvar RTCPeerConnection = require('./cubeRTCPeerConnection');\n\nvar Utils = require('../cubeInternalUtils');\n\nvar Helpers = require('./cubeWebRTCHelpers');\n\nvar SignalingConstants = require('./cubeWebRTCSignalingConstants');\n\nvar MediaDevicesImpl = require('../cubeDependencies').mediaDevices;\n/**\n * State of a session\n */\n\n\nWebRTCSession.State = {\n  NEW: 1,\n  ACTIVE: 2,\n  HUNGUP: 3,\n  REJECTED: 4,\n  CLOSED: 5\n};\n/**\n * Creates a session\n * @param {number} An ID if the call's initiator\n * @param {array} An array with opponents\n * @param {enum} Type of a call\n */\n\nfunction WebRTCSession(params) {\n  this.ID = params.sessionID ? params.sessionID : generateUUID();\n  this.state = WebRTCSession.State.NEW;\n  this.initiatorID = parseInt(params.initiatorID);\n  this.opponentsIDs = params.opIDs;\n  this.callType = parseInt(params.callType);\n  this.peerConnections = {};\n  this.localStream = null;\n  this.mediaParams = null;\n  this.signalingProvider = params.signalingProvider;\n  this.currentUserID = params.currentUserID;\n  this.bandwidth = params.bandwidth;\n  /**\n   * We use this timeout to fix next issue:\n   * \"From Android/iOS make a call to Web and kill the Android/iOS app instantly. Web accept/reject popup will be still visible.\n   * We need a way to hide it if sach situation happened.\"\n   */\n\n  this.answerTimer = null;\n  this.startCallTime = 0;\n  this.acceptCallTime = 0;\n}\n/**\n * Get the user media stream\n * @param {map} A map media stream constrains\n * @param {function} A callback to get a result of the function\n */\n\n\nWebRTCSession.prototype.getUserMedia = function (params, callback) {\n  var self = this;\n  /**\n   * Additional parameters for Media Constraints\n   * http://tools.ietf.org/html/draft-alvestrand-constraints-resolution-00\n   *\n   * googEchoCancellation: true\n   * googAutoGainControl: true\n   * googNoiseSuppression: true\n   * googHighpassFilter: true\n   * minWidth: 640\n   * minHeight: 480\n   * maxWidth: 1280\n   * maxHeight: 720\n   * minFrameRate: 60\n   * maxAspectRatio: 1.333\n   */\n\n  MediaDevicesImpl.getUserMedia({\n    audio: params.audio || false,\n    video: params.video || false\n  }).then(function (stream) {\n    self.localStream = stream;\n    self.mediaParams = params;\n\n    if (params.elementId) {\n      self.attachMediaStream(params.elementId, stream, params.options);\n    }\n\n    callback(null, stream);\n  }).catch(function (err) {\n    callback(err, null);\n  });\n};\n/**\n * Get the state of connection\n * @param {number} The User Id\n */\n\n\nWebRTCSession.prototype.connectionStateForUser = function (userID) {\n  var peerConnection = this.peerConnections[userID];\n\n  if (peerConnection) {\n    return peerConnection.state;\n  }\n\n  return null;\n};\n/**\n * Attach media stream to audio/video element\n * @param {string} The Id of an ellement to attach a stream\n * @param {object} The steram to attach\n * @param {object} The additional options\n */\n\n\nWebRTCSession.prototype.attachMediaStream = function (id, stream, options) {\n  var elem = document.getElementById(id);\n\n  if (elem) {\n    if (typeof elem.srcObject === 'object') {\n      elem.srcObject = stream;\n    } else {\n      elem.src = window.URL.createObjectURL(stream);\n    }\n\n    if (options && options.muted) {\n      elem.muted = true;\n    }\n\n    if (options && options.mirror) {\n      elem.style.webkitTransform = 'scaleX(-1)';\n      elem.style.transform = 'scaleX(-1)';\n    }\n\n    elem.onloadedmetadata = function (e) {\n      elem.play();\n    };\n  } else {\n    throw new Error('Unable to attach media stream, element ' + id + ' is undefined');\n  }\n};\n/**\n * Detach media stream from audio/video element\n * @param {string} The Id of an element to detach a stream\n */\n\n\nWebRTCSession.prototype.detachMediaStream = function (id) {\n  var elem = document.getElementById(id);\n\n  if (elem) {\n    elem.pause();\n\n    if (typeof elem.srcObject === 'object') {\n      elem.srcObject = null;\n    } else {\n      elem.src = '';\n    }\n  }\n};\n/**\n * Switch media tracks in audio/video HTML's element and replace its in peers.\n * @param {object} deviceIds - the object with deviceIds of plugged devices\n * @param {string} [deviceIds.audio] - the deviceId, it can be gotten from CB.videochat.getMediaDevices('audioinput')\n * @param {string} [deviceIds.video] - the deviceId, it can be gotten from CB.videochat.getMediaDevices('videoinput')\n * @param {switchMediaTracksCallback} callback - the callback to get a result of the function\n *\n */\n\n\nWebRTCSession.prototype.switchMediaTracks = function (deviceIds, callback) {\n  /**\n   * Callback for webRTCSession.switchMediaTracks(deviceIds, callback)\n   * @callback switchMediaTracksCallback\n   * @param {object} error - The error object\n   * @param {object} stream - The stream from new media device\n   */\n  var self = this,\n      localStream = this.localStream;\n\n  if (deviceIds && deviceIds.audio) {\n    if (typeof self.mediaParams.audio === \"boolean\") {\n      self.mediaParams.audio = {};\n    }\n\n    self.mediaParams.audio.deviceId = deviceIds.audio;\n  }\n\n  if (deviceIds && deviceIds.video) {\n    if (typeof self.mediaParams.video === \"boolean\") {\n      self.mediaParams.video = {};\n    }\n\n    self.mediaParams.video.deviceId = deviceIds.video;\n  }\n\n  localStream.getTracks().forEach(function (track) {\n    track.stop();\n  });\n  MediaDevicesImpl.getUserMedia({\n    audio: self.mediaParams.audio || false,\n    video: self.mediaParams.video || false\n  }).then(function (stream) {\n    self._replaceTracks(stream);\n\n    callback(null, stream);\n  }).catch(function (error) {\n    callback(error, null);\n  });\n};\n\nWebRTCSession.prototype._replaceTracks = function (stream) {\n  var peers = this.peerConnections,\n      localStream = this.localStream,\n      elementId = this.mediaParams.elementId,\n      ops = this.mediaParams.options,\n      newStreamTracks = stream.getTracks();\n\n  if (!Utils.getEnv().reactnative) {\n    this.detachMediaStream(elementId);\n  }\n\n  newStreamTracks.forEach(function (track) {\n    localStream.addTrack(track);\n  });\n\n  if (!Utils.getEnv().reactnative) {\n    this.attachMediaStream(elementId, stream, ops);\n  }\n\n  if (!Utils.getEnv().reactnative) {\n    var _replaceTracksForPeer = function _replaceTracksForPeer(peer) {\n      peer.getSenders().map(function (sender) {\n        sender.replaceTrack(newStreamTracks.find(function (track) {\n          return track.kind === sender.track.kind;\n        }));\n      });\n    };\n\n    for (var userId in peers) {\n      _replaceTracksForPeer(peers[userId]);\n    }\n  }\n};\n/**\n * [Initiate a call]\n * @param  {object}   extension [custom parametrs]\n * @param  {Function} callback\n */\n\n\nWebRTCSession.prototype.call = function (extension, callback) {\n  var self = this,\n      ext = _prepareExtension(extension);\n\n  Helpers.trace('Call, extension: ' + JSON.stringify(ext.userInfo));\n  self.state = WebRTCSession.State.ACTIVE; // create a peer connection for each opponent\n\n  self.opponentsIDs.forEach(function (userID, i, arr) {\n    self._callInternal(userID, ext, true);\n  });\n\n  if (typeof callback === 'function') {\n    callback(null);\n  }\n};\n\nWebRTCSession.prototype._callInternal = function (userID, extension, withOnNotAnswerCallback) {\n  var self = this;\n\n  var peer = self._createPeer(userID, 'offer');\n\n  var safariVersion = Helpers.getVersionSafari();\n\n  if (safariVersion && safariVersion >= 11) {\n    self.localStream.getTracks().forEach(function (track) {\n      peer.addTrack(track, self.localStream);\n    });\n  } else {\n    peer.addLocalStream(self.localStream);\n  }\n\n  this.peerConnections[userID] = peer;\n  peer.getAndSetLocalSessionDescription(this.callType, function (err) {\n    if (err) {\n      Helpers.trace(\"getAndSessionDescription error: \" + err);\n    } else {\n      Helpers.trace(\"getAndSessionDescription success\");\n      /** let's send call requests to user */\n\n      peer._startDialingTimer(extension, withOnNotAnswerCallback);\n    }\n  });\n};\n/**\n * Accept a call\n * @param {array} A map with custom parameters\n */\n\n\nWebRTCSession.prototype.accept = function (extension) {\n  var self = this,\n      ext = _prepareExtension(extension);\n\n  Helpers.trace('Accept, extension: ' + JSON.stringify(ext.userInfo));\n\n  if (self.state === WebRTCSession.State.ACTIVE) {\n    Helpers.traceError(\"Can't accept, the session is already active, return.\");\n    return;\n  }\n\n  if (self.state === WebRTCSession.State.CLOSED) {\n    Helpers.traceError(\"Can't accept, the session is already closed, return.\");\n    self.stop({});\n    return;\n  }\n\n  self.state = WebRTCSession.State.ACTIVE;\n  self.acceptCallTime = new Date();\n\n  self._clearAnswerTimer();\n\n  self._acceptInternal(self.initiatorID, ext);\n  /** The group call logic starts here */\n\n\n  var oppIDs = self._uniqueOpponentsIDsWithoutInitiator();\n  /** in a case of group video chat */\n\n\n  if (oppIDs.length > 0) {\n    var offerTime = (self.acceptCallTime - self.startCallTime) / 1000;\n\n    self._startWaitingOfferOrAnswerTimer(offerTime);\n    /**\n     * here we have to decide to which users the user should call.\n     * We have a rule: If a userID1 > userID2 then a userID1 should call to userID2.\n     */\n\n\n    oppIDs.forEach(function (opID, i, arr) {\n      if (self.currentUserID > opID) {\n        /** call to the user */\n        self._callInternal(opID, {}, true);\n      }\n    });\n  }\n};\n\nWebRTCSession.prototype._acceptInternal = function (userID, extension) {\n  var self = this;\n  /** create a peer connection */\n\n  var peerConnection = this.peerConnections[userID];\n\n  if (peerConnection) {\n    var safariVersion = Helpers.getVersionSafari();\n\n    if (safariVersion && safariVersion >= 11) {\n      self.localStream.getTracks().forEach(function (track) {\n        peerConnection.addTrack(track, self.localStream);\n      });\n    } else {\n      peerConnection.addLocalStream(self.localStream);\n    }\n\n    peerConnection.setRemoteSessionDescription('offer', peerConnection.getRemoteSDP(), function (error) {\n      if (error) {\n        Helpers.traceError(\"'setRemoteSessionDescription' error: \" + error);\n      } else {\n        Helpers.trace(\"'setRemoteSessionDescription' success\");\n        peerConnection.getAndSetLocalSessionDescription(self.callType, function (err) {\n          if (err) {\n            Helpers.trace(\"getAndSetLocalSessionDescription error: \" + err);\n          } else {\n            extension.sessionID = self.ID;\n            extension.callType = self.callType;\n            extension.callerID = self.initiatorID;\n            extension.opponentsIDs = self.opponentsIDs;\n            extension.sdp = peerConnection.localDescription.sdp;\n            self.signalingProvider.sendMessage(userID, extension, SignalingConstants.SignalingType.ACCEPT);\n          }\n        });\n      }\n    });\n  } else {\n    Helpers.traceError(\"Can't accept the call, there is no information about peer connection by some reason.\");\n  }\n};\n/**\n * Reject a call\n * @param {array} A map with custom parameters\n */\n\n\nWebRTCSession.prototype.reject = function (extension) {\n  var self = this,\n      ext = _prepareExtension(extension);\n\n  var peersLen = Object.keys(self.peerConnections).length;\n  Helpers.trace('Reject, extension: ' + JSON.stringify(ext.userInfo));\n  self.state = WebRTCSession.State.REJECTED;\n\n  self._clearAnswerTimer();\n\n  ext.sessionID = self.ID;\n  ext.callType = self.callType;\n  ext.callerID = self.initiatorID;\n  ext.opponentsIDs = self.opponentsIDs;\n\n  if (peersLen > 0) {\n    for (var key in self.peerConnections) {\n      var peerConnection = self.peerConnections[key];\n      self.signalingProvider.sendMessage(peerConnection.userID, ext, SignalingConstants.SignalingType.REJECT);\n    }\n  }\n\n  self._close();\n};\n/**\n * Stop a call\n * @param {array} A map with custom parameters\n */\n\n\nWebRTCSession.prototype.stop = function (extension) {\n  var self = this,\n      ext = _prepareExtension(extension),\n      peersLen = Object.keys(self.peerConnections).length;\n\n  Helpers.trace('Stop, extension: ' + JSON.stringify(ext.userInfo));\n  self.state = WebRTCSession.State.HUNGUP;\n\n  if (self.answerTimer) {\n    self._clearAnswerTimer();\n  }\n\n  ext.sessionID = self.ID;\n  ext.callType = self.callType;\n  ext.callerID = self.initiatorID;\n  ext.opponentsIDs = self.opponentsIDs;\n\n  if (peersLen > 0) {\n    for (var key in self.peerConnections) {\n      var peerConnection = self.peerConnections[key];\n      self.signalingProvider.sendMessage(peerConnection.userID, ext, SignalingConstants.SignalingType.STOP);\n    }\n  }\n\n  self._close();\n};\n/**\n * [function close connection with user]\n * @param  {Number} userId [id of user]\n */\n\n\nWebRTCSession.prototype.closeConnection = function (userId) {\n  var self = this,\n      peer = this.peerConnections[userId];\n\n  if (!peer) {\n    Helpers.traceWarn('Not found connection with user (' + userId + ')');\n    return false;\n  }\n\n  try {\n    peer.release();\n  } catch (e) {\n    Helpers.traceError(e);\n  } finally {\n    self._closeSessionIfAllConnectionsClosed();\n  }\n};\n/**\n * Update a call\n * @param {array} A map with custom parameters\n */\n\n\nWebRTCSession.prototype.update = function (extension) {\n  var self = this,\n      ext = {};\n  Helpers.trace('Update, extension: ' + JSON.stringify(extension));\n\n  if (extension === null) {\n    Helpers.trace(\"extension is null, no parameters to update\");\n    return;\n  }\n\n  ext = _prepareExtension(extension);\n  ext.sessionID = this.ID;\n\n  for (var key in self.peerConnections) {\n    var peerConnection = self.peerConnections[key];\n    self.signalingProvider.sendMessage(peerConnection.userID, ext, SignalingConstants.SignalingType.PARAMETERS_CHANGED);\n  }\n};\n/**\n * Mutes the stream\n * @param {string} what to mute: 'audio' or 'video'\n */\n\n\nWebRTCSession.prototype.mute = function (type) {\n  this._muteStream(0, type);\n};\n/**\n * Unmutes the stream\n * @param {string} what to unmute: 'audio' or 'video'\n */\n\n\nWebRTCSession.prototype.unmute = function (type) {\n  this._muteStream(1, type);\n};\n/**\n * DELEGATES (rtc client)\n */\n\n\nWebRTCSession.prototype.processOnCall = function (callerID, extension) {\n  var self = this,\n      oppIDs = self._uniqueOpponentsIDs();\n\n  oppIDs.forEach(function (opID, i, arr) {\n    var pConn = self.peerConnections[opID];\n\n    if (pConn) {\n      if (opID == callerID) {\n        pConn.updateRemoteSDP(extension.sdp);\n        /** The group call logic starts here */\n\n        if (callerID != self.initiatorID && self.state === WebRTCSession.State.ACTIVE) {\n          self._acceptInternal(callerID, {});\n        }\n      }\n    } else {\n      /** create peer connections for each opponent */\n      var peerConnection;\n\n      if (opID != callerID && self.currentUserID > opID) {\n        peerConnection = self._createPeer(opID, 'offer');\n      } else {\n        peerConnection = self._createPeer(opID, 'answer');\n      }\n\n      self.peerConnections[opID] = peerConnection;\n\n      if (opID == callerID) {\n        peerConnection.updateRemoteSDP(extension.sdp);\n\n        self._startAnswerTimer();\n      }\n    }\n  });\n};\n\nWebRTCSession.prototype.processOnAccept = function (userID, extension) {\n  var peerConnection = this.peerConnections[userID];\n\n  if (peerConnection) {\n    peerConnection._clearDialingTimer();\n\n    peerConnection.setRemoteSessionDescription('answer', extension.sdp, function (error) {\n      if (error) {\n        Helpers.traceError(\"'setRemoteSessionDescription' error: \" + error);\n      } else {\n        Helpers.trace(\"'setRemoteSessionDescription' success\");\n      }\n    });\n  } else {\n    Helpers.traceError(\"Ignore 'OnAccept', there is no information about peer connection by some reason.\");\n  }\n};\n\nWebRTCSession.prototype.processOnReject = function (userID, extension) {\n  var peerConnection = this.peerConnections[userID];\n\n  this._clearWaitingOfferOrAnswerTimer();\n\n  if (peerConnection) {\n    peerConnection.release();\n  } else {\n    Helpers.traceError(\"Ignore 'OnReject', there is no information about peer connection by some reason.\");\n  }\n\n  this._closeSessionIfAllConnectionsClosed();\n};\n\nWebRTCSession.prototype.processOnStop = function (userID, extension) {\n  var self = this;\n\n  this._clearAnswerTimer();\n  /** drop the call if the initiator did it */\n\n\n  if (userID === self.initiatorID) {\n    if (Object.keys(self.peerConnections).length) {\n      Object.keys(self.peerConnections).forEach(function (key) {\n        self.peerConnections[key].release();\n      });\n    } else {\n      Helpers.traceError(\"Ignore 'OnStop', there is no information about peer connections by some reason.\");\n    }\n  } else {\n    var pc = self.peerConnections[userID];\n\n    if (pc) {\n      pc.release();\n    } else {\n      Helpers.traceError(\"Ignore 'OnStop', there is no information about peer connection by some reason.\");\n    }\n  }\n\n  this._closeSessionIfAllConnectionsClosed();\n};\n\nWebRTCSession.prototype.processOnIceCandidates = function (userID, extension) {\n  var peerConnection = this.peerConnections[userID];\n\n  if (peerConnection) {\n    peerConnection.addCandidates(extension.iceCandidates);\n  } else {\n    Helpers.traceError(\"Ignore 'OnIceCandidates', there is no information about peer connection by some reason.\");\n  }\n};\n\nWebRTCSession.prototype.processCall = function (peerConnection, ext) {\n  var extension = ext || {};\n  extension.sessionID = this.ID;\n  extension.callType = this.callType;\n  extension.callerID = this.initiatorID;\n  extension.opponentsIDs = this.opponentsIDs;\n  extension.sdp = peerConnection.localDescription.sdp; //TODO: set bandwidth to the userInfo object\n\n  extension.userInfo = ext.userInfo || {};\n  extension.userInfo.bandwidth = this.bandwidth;\n  this.signalingProvider.sendMessage(peerConnection.userID, extension, SignalingConstants.SignalingType.CALL);\n};\n\nWebRTCSession.prototype.processIceCandidates = function (peerConnection, iceCandidates) {\n  var extension = {};\n  extension.sessionID = this.ID;\n  extension.callType = this.callType;\n  extension.callerID = this.initiatorID;\n  extension.opponentsIDs = this.opponentsIDs;\n  this.signalingProvider.sendCandidate(peerConnection.userID, iceCandidates, extension);\n};\n\nWebRTCSession.prototype.processOnNotAnswer = function (peerConnection) {\n  Helpers.trace(\"Answer timeout callback for session \" + this.ID + \" for user \" + peerConnection.userID);\n\n  this._clearWaitingOfferOrAnswerTimer();\n\n  peerConnection.release();\n\n  if (typeof this.onUserNotAnswerListener === 'function') {\n    Utils.safeCallbackCall(this.onUserNotAnswerListener, this, peerConnection.userID);\n  }\n\n  this._closeSessionIfAllConnectionsClosed();\n};\n/**\n * DELEGATES (peer connection)\n */\n\n\nWebRTCSession.prototype._onRemoteStreamListener = function (userID, stream) {\n  if (typeof this.onRemoteStreamListener === 'function') {\n    Utils.safeCallbackCall(this.onRemoteStreamListener, this, userID, stream);\n  }\n};\n/**\n * [_onCallStatsReport return statistics about the peer]\n * @param  {number} userId [id of user (callee)]\n * @param  {array} stats  [array of statistics]\n *\n * Fire onCallStatsReport callbacks with parameters(userId, stats, error).\n * If stats will be invalid callback return null and error\n */\n\n\nWebRTCSession.prototype._onCallStatsReport = function (userId, stats, error) {\n  if (typeof this.onCallStatsReport === 'function') {\n    Utils.safeCallbackCall(this.onCallStatsReport, this, userId, stats, error);\n  }\n};\n\nWebRTCSession.prototype._onSessionConnectionStateChangedListener = function (userID, connectionState) {\n  if (typeof this.onSessionConnectionStateChangedListener === 'function') {\n    Utils.safeCallbackCall(this.onSessionConnectionStateChangedListener, this, userID, connectionState);\n  }\n};\n/**\n * Private\n */\n\n\nWebRTCSession.prototype._createPeer = function (userID, peerConnectionType) {\n  if (!RTCPeerConnection) throw new Error('_createPeer error: RTCPeerConnection() is not supported in your browser');\n  this.startCallTime = new Date();\n  /**\n   * Additional parameters for RTCPeerConnection options\n   * new RTCPeerConnection(pcConfig, options)\n   *\n   * DtlsSrtpKeyAgreement: true\n   * RtpDataChannels: true\n   */\n\n  var pcConfig = {\n    iceServers: _prepareIceServers(config.videochat.iceServers)\n  };\n  Helpers.trace(\"_createPeer, iceServers: \" + JSON.stringify(pcConfig));\n  var peer = new RTCPeerConnection(pcConfig);\n\n  peer._init(this, userID, this.ID, peerConnectionType);\n\n  return peer;\n};\n/** close peer connection and local stream */\n\n\nWebRTCSession.prototype._close = function () {\n  Helpers.trace('_close');\n\n  for (var key in this.peerConnections) {\n    var peer = this.peerConnections[key];\n\n    try {\n      peer.release();\n    } catch (e) {\n      console.warn('Peer close error:', e);\n    }\n  }\n\n  this._closeLocalMediaStream();\n\n  this.state = WebRTCSession.State.CLOSED;\n\n  if (typeof this.onSessionCloseListener === 'function') {\n    Utils.safeCallbackCall(this.onSessionCloseListener, this);\n  }\n};\n\nWebRTCSession.prototype._closeSessionIfAllConnectionsClosed = function () {\n  var isAllConnectionsClosed = true;\n\n  for (var key in this.peerConnections) {\n    var peerCon = this.peerConnections[key],\n        peerState;\n\n    try {\n      /*\n      TODO:\n      Uses RTCPeerConnection.signalingState instead RTCPeerConnection.iceConnectionState,\n      because state 'closed' comes after few time from Safari, but signaling state comes instantly\n      */\n      peerState = peerCon.iceConnectionState === 'closed' ? 'closed' : peerCon.signalingState;\n    } catch (err) {\n      Helpers.traceError(err); // need to set peerState to 'closed' on error. FF will crashed without this part.\n\n      peerState = 'closed';\n    }\n\n    if (peerState !== 'closed') {\n      isAllConnectionsClosed = false;\n      break;\n    }\n  }\n\n  Helpers.trace(\"All peer connections closed: \" + isAllConnectionsClosed);\n\n  if (isAllConnectionsClosed) {\n    this._closeLocalMediaStream();\n\n    if (typeof this.onSessionCloseListener === 'function') {\n      this.onSessionCloseListener(this);\n    }\n\n    this.state = WebRTCSession.State.CLOSED;\n  }\n};\n\nWebRTCSession.prototype._closeLocalMediaStream = function () {\n  /**\n   * https://developers.google.com/web/updates/2015/07/mediastream-deprecations?hl=en\n   */\n  if (this.localStream) {\n    this.localStream.getAudioTracks().forEach(function (audioTrack) {\n      audioTrack.stop();\n    });\n    this.localStream.getVideoTracks().forEach(function (videoTrack) {\n      videoTrack.stop();\n    });\n    this.localStream = null;\n  }\n};\n\nWebRTCSession.prototype._muteStream = function (bool, type) {\n  if (type === 'audio' && this.localStream.getAudioTracks().length > 0) {\n    this.localStream.getAudioTracks().forEach(function (track) {\n      track.enabled = !!bool;\n    });\n    return;\n  }\n\n  if (type === 'video' && this.localStream.getVideoTracks().length > 0) {\n    this.localStream.getVideoTracks().forEach(function (track) {\n      track.enabled = !!bool;\n    });\n    return;\n  }\n};\n\nWebRTCSession.prototype._clearAnswerTimer = function () {\n  if (this.answerTimer) {\n    Helpers.trace(\"_clearAnswerTimer\");\n    clearTimeout(this.answerTimer);\n    this.answerTimer = null;\n  }\n};\n\nWebRTCSession.prototype._startAnswerTimer = function () {\n  Helpers.trace(\"_startAnswerTimer\");\n  var self = this;\n\n  var answerTimeoutCallback = function answerTimeoutCallback() {\n    Helpers.trace(\"_answerTimeoutCallback\");\n\n    if (typeof self.onSessionCloseListener === 'function') {\n      self._close();\n    }\n\n    self.answerTimer = null;\n  };\n\n  var answerTimeInterval = config.videochat.answerTimeInterval * 1000;\n  this.answerTimer = setTimeout(answerTimeoutCallback, answerTimeInterval);\n};\n\nWebRTCSession.prototype._clearWaitingOfferOrAnswerTimer = function () {\n  if (this.waitingOfferOrAnswerTimer) {\n    Helpers.trace(\"_clearWaitingOfferOrAnswerTimer\");\n    clearTimeout(this.waitingOfferOrAnswerTimer);\n    this.waitingOfferOrAnswerTimer = null;\n  }\n};\n\nWebRTCSession.prototype._startWaitingOfferOrAnswerTimer = function (time) {\n  var self = this,\n      timeout = config.videochat.answerTimeInterval - time < 0 ? 1 : config.videochat.answerTimeInterval - time,\n      waitingOfferOrAnswerTimeoutCallback = function waitingOfferOrAnswerTimeoutCallback() {\n    Helpers.trace(\"waitingOfferOrAnswerTimeoutCallback\");\n\n    if (Object.keys(self.peerConnections).length > 0) {\n      Object.keys(self.peerConnections).forEach(function (key) {\n        var peerConnection = self.peerConnections[key];\n\n        if (peerConnection.state === RTCPeerConnection.State.CONNECTING || peerConnection.state === RTCPeerConnection.State.NEW) {\n          self.processOnNotAnswer(peerConnection);\n        }\n      });\n    }\n\n    self.waitingOfferOrAnswerTimer = null;\n  };\n\n  Helpers.trace(\"_startWaitingOfferOrAnswerTimer, timeout: \" + timeout);\n  this.waitingOfferOrAnswerTimer = setTimeout(waitingOfferOrAnswerTimeoutCallback, timeout * 1000);\n};\n\nWebRTCSession.prototype._uniqueOpponentsIDs = function () {\n  var self = this;\n  var opponents = [];\n\n  if (this.initiatorID !== this.currentUserID) {\n    opponents.push(this.initiatorID);\n  }\n\n  this.opponentsIDs.forEach(function (userID, i, arr) {\n    if (userID != self.currentUserID) {\n      opponents.push(parseInt(userID));\n    }\n  });\n  return opponents;\n};\n\nWebRTCSession.prototype._uniqueOpponentsIDsWithoutInitiator = function () {\n  var self = this;\n  var opponents = [];\n  this.opponentsIDs.forEach(function (userID, i, arr) {\n    if (userID != self.currentUserID) {\n      opponents.push(parseInt(userID));\n    }\n  });\n  return opponents;\n};\n\nWebRTCSession.prototype.toString = function sessionToString() {\n  return 'ID: ' + this.ID + ', initiatorID:  ' + this.initiatorID + ', opponentsIDs: ' + this.opponentsIDs + ', state: ' + this.state + ', callType: ' + this.callType;\n};\n\nfunction generateUUID() {\n  var d = new Date().getTime();\n  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n  });\n  return uuid;\n}\n/**\n * private _prepareExtension - replace property null to empty string\n * return object with property or empty if extension didn't set\n */\n\n\nfunction _prepareExtension(extension) {\n  var ext = {};\n\n  try {\n    if ({}.toString.call(extension) === '[object Object]') {\n      ext.userInfo = extension;\n      ext = JSON.parse(JSON.stringify(ext).replace(/null/g, \"\\\"\\\"\"));\n    } else {\n      throw new Error('Invalid type of \"extension\" object.');\n    }\n  } catch (err) {\n    Helpers.traceWarning(err.message);\n  }\n\n  return ext;\n}\n\nfunction _prepareIceServers(iceServers) {\n  var iceServersCopy = JSON.parse(JSON.stringify(iceServers));\n  Object.keys(iceServersCopy).forEach(function (c, i, a) {\n    if (iceServersCopy[i].hasOwnProperty('url')) {\n      iceServersCopy[i].urls = iceServersCopy[i].url;\n    } else {\n      iceServersCopy[i].url = iceServersCopy[i].urls;\n    }\n  });\n  return iceServersCopy;\n}\n\nmodule.exports = WebRTCSession;","map":null,"metadata":{},"sourceType":"script"}