{"ast":null,"code":"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\nvar events = require('events');\n\nvar util = require('util');\n\nvar Backoff = require('./backoff');\n\nvar FibonacciBackoffStrategy = require('./strategy/fibonacci');\n/**\n * Returns true if the specified value is a function\n * @param val Variable to test.\n * @return Whether variable is a function.\n */\n\n\nfunction isFunction(val) {\n  return typeof val == 'function';\n}\n/**\n * Manages the calling of a function in a backoff loop.\n * @param fn Function to wrap in a backoff handler.\n * @param args Array of function's arguments.\n * @param callback Function's callback.\n * @constructor\n */\n\n\nfunction FunctionCall(fn, args, callback) {\n  events.EventEmitter.call(this);\n\n  if (!isFunction(fn)) {\n    throw new Error('fn should be a function.' + 'Actual: ' + typeof fn);\n  }\n\n  if (!isFunction(callback)) {\n    throw new Error('callback should be a function.' + 'Actual: ' + typeof fn);\n  }\n\n  this.function_ = fn;\n  this.arguments_ = args;\n  this.callback_ = callback;\n  this.results_ = [];\n  this.backoff_ = null;\n  this.strategy_ = null;\n  this.failAfter_ = -1;\n  this.state_ = FunctionCall.State_.PENDING;\n}\n\nutil.inherits(FunctionCall, events.EventEmitter);\n/**\n * Enum of states in which the FunctionCall can be.\n * @private\n */\n\nFunctionCall.State_ = {\n  PENDING: 0,\n  RUNNING: 1,\n  COMPLETED: 2,\n  ABORTED: 3\n};\n/**\n * @return Whether the call is pending.\n */\n\nFunctionCall.prototype.isPending = function () {\n  return this.state_ == FunctionCall.State_.PENDING;\n};\n/**\n * @return Whether the call is in progress.\n */\n\n\nFunctionCall.prototype.isRunning = function () {\n  return this.state_ == FunctionCall.State_.RUNNING;\n};\n/**\n * @return Whether the call is completed.\n */\n\n\nFunctionCall.prototype.isCompleted = function () {\n  return this.state_ == FunctionCall.State_.COMPLETED;\n};\n/**\n * @return Whether the call is aborted.\n */\n\n\nFunctionCall.prototype.isAborted = function () {\n  return this.state_ == FunctionCall.State_.ABORTED;\n};\n/**\n * Sets the backoff strategy.\n * @param strategy The backoff strategy to use.\n * @return Itself for chaining.\n */\n\n\nFunctionCall.prototype.setStrategy = function (strategy) {\n  if (!this.isPending()) {\n    throw new Error('FunctionCall in progress.');\n  }\n\n  this.strategy_ = strategy;\n  return this;\n};\n/**\n * Returns all intermediary results returned by the wrapped function since\n * the initial call.\n * @return An array of intermediary results.\n */\n\n\nFunctionCall.prototype.getResults = function () {\n  return this.results_.concat();\n};\n/**\n * Sets the backoff limit.\n * @param maxNumberOfRetry The maximum number of backoffs.\n * @return Itself for chaining.\n */\n\n\nFunctionCall.prototype.failAfter = function (maxNumberOfRetry) {\n  if (!this.isPending()) {\n    throw new Error('FunctionCall in progress.');\n  }\n\n  this.failAfter_ = maxNumberOfRetry;\n  return this;\n};\n/**\n * Aborts the call.\n */\n\n\nFunctionCall.prototype.abort = function () {\n  if (this.isCompleted()) {\n    throw new Error('FunctionCall already completed.');\n  }\n\n  if (this.isRunning()) {\n    this.backoff_.reset();\n  }\n\n  this.state_ = FunctionCall.State_.ABORTED;\n};\n/**\n * Initiates the call to the wrapped function.\n * @param backoffFactory Optional factory function used to create the backoff\n *     instance.\n */\n\n\nFunctionCall.prototype.start = function (backoffFactory) {\n  if (this.isAborted()) {\n    throw new Error('FunctionCall aborted.');\n  } else if (!this.isPending()) {\n    throw new Error('FunctionCall already started.');\n  }\n\n  var strategy = this.strategy_ || new FibonacciBackoffStrategy();\n  this.backoff_ = backoffFactory ? backoffFactory(strategy) : new Backoff(strategy);\n  this.backoff_.on('ready', this.doCall_.bind(this));\n  this.backoff_.on('fail', this.doCallback_.bind(this));\n  this.backoff_.on('backoff', this.handleBackoff_.bind(this));\n\n  if (this.failAfter_ > 0) {\n    this.backoff_.failAfter(this.failAfter_);\n  }\n\n  this.state_ = FunctionCall.State_.RUNNING;\n  this.doCall_();\n};\n/**\n * Calls the wrapped function.\n * @private\n */\n\n\nFunctionCall.prototype.doCall_ = function () {\n  var eventArgs = ['call'].concat(this.arguments_);\n  events.EventEmitter.prototype.emit.apply(this, eventArgs);\n  var callback = this.handleFunctionCallback_.bind(this);\n  this.function_.apply(null, this.arguments_.concat(callback));\n};\n/**\n * Calls the wrapped function's callback with the last result returned by the\n * wrapped function.\n * @private\n */\n\n\nFunctionCall.prototype.doCallback_ = function () {\n  var args = this.results_[this.results_.length - 1];\n  this.callback_.apply(null, args);\n};\n/**\n * Handles wrapped function's completion. This method acts as a replacement\n * for the original callback function.\n * @private\n */\n\n\nFunctionCall.prototype.handleFunctionCallback_ = function () {\n  if (this.isAborted()) {\n    return;\n  }\n\n  var args = Array.prototype.slice.call(arguments);\n  this.results_.push(args); // Save callback arguments.\n\n  events.EventEmitter.prototype.emit.apply(this, ['callback'].concat(args));\n\n  if (args[0]) {\n    this.backoff_.backoff(args[0]);\n  } else {\n    this.state_ = FunctionCall.State_.COMPLETED;\n    this.doCallback_();\n  }\n};\n/**\n * Handles backoff event.\n * @param number Backoff number.\n * @param delay Backoff delay.\n * @param err The error that caused the backoff.\n * @private\n */\n\n\nFunctionCall.prototype.handleBackoff_ = function (number, delay, err) {\n  this.emit('backoff', number, delay, err);\n};\n\nmodule.exports = FunctionCall;","map":null,"metadata":{},"sourceType":"script"}