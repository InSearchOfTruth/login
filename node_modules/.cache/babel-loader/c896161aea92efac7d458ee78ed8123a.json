{"ast":null,"code":"'use strict';\n\nvar inherits = require('inherits');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar LtxParser = require('ltx/lib/parsers/ltx');\n\nvar xml = require('@xmpp/xml');\n\nvar Stanza = xml.Stanza;\nvar Element = xml.Element;\n/**\n * Recognizes <stream:stream> and collects stanzas used for ordinary\n * TCP streams and Websockets.\n *\n * API: write(data) & end(data)\n * Events: streamStart, stanza, end, error\n */\n\nfunction StreamParser(options) {\n  EventEmitter.call(this);\n  var self = this;\n  var ElementInterface = options && options.Element || Element;\n  var ParserInterface = options && options.Parser || LtxParser;\n  this.maxStanzaSize = options && options.maxStanzaSize;\n  this.parser = new ParserInterface();\n  /* Count traffic for entire life-time */\n\n  this.bytesParsed = 0;\n  /* Will be reset upon first stanza, but enforce maxStanzaSize until it is parsed */\n\n  this.bytesParsedOnStanzaBegin = 0;\n  this.parser.on('startElement', function (name, attrs) {\n    if (!self.element) {\n      self.emit('startElement', name, attrs);\n      self.emit('start', new Element(name, attrs));\n    } // TODO: refuse anything but <stream:stream>\n\n\n    if (!self.element && name === 'stream:stream') {\n      self.emit('streamStart', attrs);\n    } else {\n      var child;\n\n      if (!self.element) {\n        /* A new stanza */\n        child = new Stanza(name, attrs);\n        self.element = child;\n        /* For maxStanzaSize enforcement */\n\n        self.bytesParsedOnStanzaBegin = self.bytesParsed;\n      } else {\n        /* A child element of a stanza */\n        child = new ElementInterface(name, attrs);\n        self.element = self.element.cnode(child);\n      }\n    }\n  });\n  this.parser.on('endElement', function (name) {\n    if (!self.element) {\n      self.emit('endElement', name);\n    }\n\n    if (!self.element && name === 'stream:stream') {\n      self.end();\n    } else if (self.element && name === self.element.name) {\n      if (self.element.parent) {\n        self.element = self.element.parent;\n      } else {\n        /* element complete */\n        self.emit('element', self.element);\n        self.emit('stanza', self.element); // FIXME deprecate\n\n        delete self.element;\n        /* maxStanzaSize doesn't apply until next startElement */\n\n        delete self.bytesParsedOnStanzaBegin;\n      }\n    } else {\n      self.error('xml-not-well-formed', 'XML parse error');\n    }\n  });\n  this.parser.on('text', function (str) {\n    if (self.element) self.element.t(str);\n  });\n  this.parser.on('entityDecl', function () {\n    /* Entity declarations are forbidden in XMPP. We must abort to\n     * avoid a billion laughs.\n     */\n    self.error('xml-not-well-formed', 'No entity declarations allowed');\n    self.end();\n  });\n  this.parser.on('error', this.emit.bind(this, 'error'));\n}\n\ninherits(StreamParser, EventEmitter);\n/*\n * hack for most usecases, do we have a better idea?\n *   catch the following:\n *   <?xml version=\"1.0\"?>\n *   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n *   <?xml version=\"1.0\" encoding=\"UTF-16\" standalone=\"yes\"?>\n */\n\nStreamParser.prototype.checkXMLHeader = function (data) {\n  // check for xml tag\n  var index = data.indexOf('<?xml');\n\n  if (index !== -1) {\n    var end = data.indexOf('?>');\n\n    if (index >= 0 && end >= 0 && index < end + 2) {\n      var search = data.substring(index, end + 2);\n      data = data.replace(search, '');\n    }\n  }\n\n  return data;\n};\n\nStreamParser.prototype.write = function (data) {\n  // if (/^<stream:stream [^>]+\\/>$/.test(data)) {\n  //   data = data.replace(/\\/>$/, \">\")\n  // }\n  if (this.parser) {\n    data = data.toString('utf8');\n    data = this.checkXMLHeader(data);\n    /* If a maxStanzaSize is configured, the current stanza must consist only of this many bytes */\n\n    if (this.bytesParsedOnStanzaBegin && this.maxStanzaSize && this.bytesParsed > this.bytesParsedOnStanzaBegin + this.maxStanzaSize) {\n      this.error('policy-violation', 'Maximum stanza size exceeded');\n      return;\n    }\n\n    this.bytesParsed += data.length;\n    this.parser.write(data);\n  }\n};\n\nStreamParser.prototype.end = function (data) {\n  if (data) {\n    this.write(data);\n  }\n  /* Get GC'ed */\n\n\n  delete this.parser;\n  this.emit('end');\n};\n\nStreamParser.prototype.error = function (condition, message) {\n  var e = new Error(message);\n  e.condition = condition;\n  this.emit('error', e);\n};\n\nmodule.exports = StreamParser;","map":null,"metadata":{},"sourceType":"script"}