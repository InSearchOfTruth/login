{"ast":null,"code":"'use strict';\n\nvar escape = require('./escape');\n\nvar escapeXML = escape.escapeXML;\nvar escapeXMLText = escape.escapeXMLText;\n\nvar equality = require('./equal');\n\nvar equal = equality.equal;\nvar nameEqual = equality.name;\nvar attrsEqual = equality.attrs;\nvar childrenEqual = equality.children;\n\nvar clone = require('./clone');\n/**\n * Element\n *\n * Attributes are in the element.attrs object. Children is a list of\n * either other Elements or Strings for text content.\n **/\n\n\nfunction Element(name, attrs) {\n  this.name = name;\n  this.parent = null;\n  this.children = [];\n  this.attrs = {};\n  this.setAttrs(attrs);\n}\n/* Accessors */\n\n/**\n * if (element.is('message', 'jabber:client')) ...\n **/\n\n\nElement.prototype.is = function (name, xmlns) {\n  return this.getName() === name && (!xmlns || this.getNS() === xmlns);\n};\n/* without prefix */\n\n\nElement.prototype.getName = function () {\n  if (this.name.indexOf(':') >= 0) {\n    return this.name.substr(this.name.indexOf(':') + 1);\n  } else {\n    return this.name;\n  }\n};\n/**\n * retrieves the namespace of the current element, upwards recursively\n **/\n\n\nElement.prototype.getNS = function () {\n  if (this.name.indexOf(':') >= 0) {\n    var prefix = this.name.substr(0, this.name.indexOf(':'));\n    return this.findNS(prefix);\n  }\n\n  return this.findNS();\n};\n/**\n * find the namespace to the given prefix, upwards recursively\n **/\n\n\nElement.prototype.findNS = function (prefix) {\n  if (!prefix) {\n    /* default namespace */\n    if (this.attrs.xmlns) {\n      return this.attrs.xmlns;\n    } else if (this.parent) {\n      return this.parent.findNS();\n    }\n  } else {\n    /* prefixed namespace */\n    var attr = 'xmlns:' + prefix;\n\n    if (this.attrs[attr]) {\n      return this.attrs[attr];\n    } else if (this.parent) {\n      return this.parent.findNS(prefix);\n    }\n  }\n};\n/**\n * Recursiverly gets all xmlns defined, in the form of {url:prefix}\n **/\n\n\nElement.prototype.getXmlns = function () {\n  var namespaces = {};\n\n  if (this.parent) {\n    namespaces = this.parent.getXmlns();\n  }\n\n  for (var attr in this.attrs) {\n    var m = attr.match('xmlns:?(.*)');\n\n    if (this.attrs.hasOwnProperty(attr) && m) {\n      namespaces[this.attrs[attr]] = m[1];\n    }\n  }\n\n  return namespaces;\n};\n\nElement.prototype.setAttrs = function (attrs) {\n  if (typeof attrs === 'string') {\n    this.attrs.xmlns = attrs;\n  } else if (attrs) {\n    Object.keys(attrs).forEach(function (key) {\n      this.attrs[key] = attrs[key];\n    }, this);\n  }\n};\n/**\n * xmlns can be null, returns the matching attribute.\n **/\n\n\nElement.prototype.getAttr = function (name, xmlns) {\n  if (!xmlns) {\n    return this.attrs[name];\n  }\n\n  var namespaces = this.getXmlns();\n\n  if (!namespaces[xmlns]) {\n    return null;\n  }\n\n  return this.attrs[[namespaces[xmlns], name].join(':')];\n};\n/**\n * xmlns can be null\n **/\n\n\nElement.prototype.getChild = function (name, xmlns) {\n  return this.getChildren(name, xmlns)[0];\n};\n/**\n * xmlns can be null\n **/\n\n\nElement.prototype.getChildren = function (name, xmlns) {\n  var result = [];\n\n  for (var i = 0; i < this.children.length; i++) {\n    var child = this.children[i];\n\n    if (child.getName && child.getName() === name && (!xmlns || child.getNS() === xmlns)) {\n      result.push(child);\n    }\n  }\n\n  return result;\n};\n/**\n * xmlns and recursive can be null\n **/\n\n\nElement.prototype.getChildByAttr = function (attr, val, xmlns, recursive) {\n  return this.getChildrenByAttr(attr, val, xmlns, recursive)[0];\n};\n/**\n * xmlns and recursive can be null\n **/\n\n\nElement.prototype.getChildrenByAttr = function (attr, val, xmlns, recursive) {\n  var result = [];\n\n  for (var i = 0; i < this.children.length; i++) {\n    var child = this.children[i];\n\n    if (child.attrs && child.attrs[attr] === val && (!xmlns || child.getNS() === xmlns)) {\n      result.push(child);\n    }\n\n    if (recursive && child.getChildrenByAttr) {\n      result.push(child.getChildrenByAttr(attr, val, xmlns, true));\n    }\n  }\n\n  if (recursive) {\n    result = [].concat.apply([], result);\n  }\n\n  return result;\n};\n\nElement.prototype.getChildrenByFilter = function (filter, recursive) {\n  var result = [];\n\n  for (var i = 0; i < this.children.length; i++) {\n    var child = this.children[i];\n\n    if (filter(child)) {\n      result.push(child);\n    }\n\n    if (recursive && child.getChildrenByFilter) {\n      result.push(child.getChildrenByFilter(filter, true));\n    }\n  }\n\n  if (recursive) {\n    result = [].concat.apply([], result);\n  }\n\n  return result;\n};\n\nElement.prototype.getText = function () {\n  var text = '';\n\n  for (var i = 0; i < this.children.length; i++) {\n    var child = this.children[i];\n\n    if (typeof child === 'string' || typeof child === 'number') {\n      text += child;\n    }\n  }\n\n  return text;\n};\n\nElement.prototype.getChildText = function (name, xmlns) {\n  var child = this.getChild(name, xmlns);\n  return child ? child.getText() : null;\n};\n/**\n * Return all direct descendents that are Elements.\n * This differs from `getChildren` in that it will exclude text nodes,\n * processing instructions, etc.\n */\n\n\nElement.prototype.getChildElements = function () {\n  return this.getChildrenByFilter(function (child) {\n    return child instanceof Element;\n  });\n};\n/* Builder */\n\n/** returns uppermost parent */\n\n\nElement.prototype.root = function () {\n  if (this.parent) {\n    return this.parent.root();\n  }\n\n  return this;\n};\n\nElement.prototype.tree = Element.prototype.root;\n/** just parent or itself */\n\nElement.prototype.up = function () {\n  if (this.parent) {\n    return this.parent;\n  }\n\n  return this;\n};\n/** create child node and return it */\n\n\nElement.prototype.c = function (name, attrs) {\n  return this.cnode(new Element(name, attrs));\n};\n\nElement.prototype.cnode = function (child) {\n  this.children.push(child);\n\n  if (typeof child === 'object') {\n    child.parent = this;\n  }\n\n  return child;\n};\n/** add text node and return element */\n\n\nElement.prototype.t = function (text) {\n  this.children.push(text);\n  return this;\n};\n/* Manipulation */\n\n/**\n * Either:\n *   el.remove(childEl)\n *   el.remove('author', 'urn:...')\n */\n\n\nElement.prototype.remove = function (el, xmlns) {\n  var filter;\n\n  if (typeof el === 'string') {\n    /* 1st parameter is tag name */\n    filter = function filter(child) {\n      return !(child.is && child.is(el, xmlns));\n    };\n  } else {\n    /* 1st parameter is element */\n    filter = function filter(child) {\n      return child !== el;\n    };\n  }\n\n  this.children = this.children.filter(filter);\n  return this;\n};\n\nElement.prototype.clone = function () {\n  return clone(this);\n};\n\nElement.prototype.text = function (val) {\n  if (val && this.children.length === 1) {\n    this.children[0] = val;\n    return this;\n  }\n\n  return this.getText();\n};\n\nElement.prototype.attr = function (attr, val) {\n  if (typeof val !== 'undefined' || val === null) {\n    if (!this.attrs) {\n      this.attrs = {};\n    }\n\n    this.attrs[attr] = val;\n    return this;\n  }\n\n  return this.attrs[attr];\n};\n/* Serialization */\n\n\nElement.prototype.toString = function () {\n  var s = '';\n  this.write(function (c) {\n    s += c;\n  });\n  return s;\n};\n\nElement.prototype.toJSON = function () {\n  return {\n    name: this.name,\n    attrs: this.attrs,\n    children: this.children.map(function (child) {\n      return child && child.toJSON ? child.toJSON() : child;\n    })\n  };\n};\n\nElement.prototype._addChildren = function (writer) {\n  writer('>');\n\n  for (var i = 0; i < this.children.length; i++) {\n    var child = this.children[i];\n    /* Skip null/undefined */\n\n    if (child || child === 0) {\n      if (child.write) {\n        child.write(writer);\n      } else if (typeof child === 'string') {\n        writer(escapeXMLText(child));\n      } else if (child.toString) {\n        writer(escapeXMLText(child.toString(10)));\n      }\n    }\n  }\n\n  writer('</');\n  writer(this.name);\n  writer('>');\n};\n\nElement.prototype.write = function (writer) {\n  writer('<');\n  writer(this.name);\n\n  for (var k in this.attrs) {\n    var v = this.attrs[k];\n\n    if (v != null) {\n      // === null || undefined\n      writer(' ');\n      writer(k);\n      writer('=\"');\n\n      if (typeof v !== 'string') {\n        v = v.toString();\n      }\n\n      writer(escapeXML(v));\n      writer('\"');\n    }\n  }\n\n  if (this.children.length === 0) {\n    writer('/>');\n  } else {\n    this._addChildren(writer);\n  }\n};\n\nElement.prototype.nameEquals = function (el) {\n  return nameEqual(this, el);\n};\n\nElement.prototype.attrsEquals = function (el) {\n  return attrsEqual(this, el);\n};\n\nElement.prototype.childrenEquals = function (el) {\n  return childrenEqual(this, el);\n};\n\nElement.prototype.equals = function (el) {\n  return equal(this, el);\n};\n\nmodule.exports = Element;","map":null,"metadata":{},"sourceType":"script"}