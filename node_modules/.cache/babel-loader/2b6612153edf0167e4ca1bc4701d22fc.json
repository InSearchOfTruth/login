{"ast":null,"code":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar core = require('node-xmpp-core');\n\nvar inherits = core.inherits;\nvar ltx = core.ltx;\n\nvar request = require('request');\n\nvar debug = require('debug')('xmpp:client:bosh');\n\nfunction BOSHConnection(opts) {\n  var that = this;\n  EventEmitter.call(this);\n  this.boshURL = opts.bosh.url;\n  this.jid = opts.jid;\n  this.wait = opts.bosh.wait || 60;\n  this.xmlnsAttrs = {\n    xmlns: 'http://jabber.org/protocol/httpbind',\n    'xmlns:xmpp': 'urn:xmpp:xbosh',\n    'xmlns:stream': 'http://etherx.jabber.org/streams'\n  };\n\n  if (opts.xmlns) {\n    for (var prefix in opts.xmlns) {\n      if (prefix) {\n        this.xmlnsAttrs['xmlns:' + prefix] = opts.xmlns[prefix];\n      } else {\n        this.xmlnsAttrs.xmlns = opts.xmlns[prefix];\n      }\n    }\n  }\n\n  this.currentRequests = 0;\n  this.queue = [];\n  this.rid = Math.ceil(Math.random() * 9999999999);\n  this.request({\n    to: this.jid.domain,\n    ver: '1.6',\n    wait: this.wait,\n    hold: '1',\n    content: this.contentType,\n    'xmpp:version': '1.0'\n  }, [], function (err, bodyEl) {\n    if (err) {\n      that.emit('error', err);\n    } else if (bodyEl && bodyEl.attrs) {\n      that.sid = bodyEl.attrs.sid;\n      that.maxRequests = parseInt(bodyEl.attrs.requests, 10) || 2;\n\n      if (that.sid && that.maxRequests > 0) {\n        that.emit('connect');\n        that.processResponse(bodyEl);\n        process.nextTick(that.mayRequest.bind(that));\n      } else {\n        that.emit('error', 'Invalid parameters');\n      }\n    }\n  });\n}\n\ninherits(BOSHConnection, EventEmitter);\nBOSHConnection.prototype.contentType = 'text/xml; charset=utf-8';\n\nBOSHConnection.prototype.send = function (stanza) {\n  this.queue.push(stanza.root());\n  process.nextTick(this.mayRequest.bind(this));\n};\n\nBOSHConnection.prototype.startStream = function () {\n  var that = this;\n  this.rid++;\n  this.request({\n    to: this.jid.domain,\n    'xmpp:restart': 'true'\n  }, [], function (err, bodyEl) {\n    if (err) {\n      that.emit('error', err);\n      that.emit('disconnect');\n      that.emit('end');\n      delete that.sid;\n      that.emit('close');\n    } else {\n      that.streamOpened = true;\n      if (bodyEl) that.processResponse(bodyEl);\n      process.nextTick(that.mayRequest.bind(that));\n    }\n  });\n};\n\nBOSHConnection.prototype.processResponse = function (bodyEl) {\n  debug('process bosh server response ' + bodyEl.toString());\n\n  if (bodyEl && bodyEl.children) {\n    for (var i = 0; i < bodyEl.children.length; i++) {\n      var child = bodyEl.children[i];\n\n      if (child.name && child.attrs && child.children) {\n        this.emit('stanza', child);\n      }\n    }\n  }\n\n  if (bodyEl && bodyEl.attrs.type === 'terminate') {\n    if (!this.shutdown || bodyEl.attrs.condition) {\n      this.emit('error', new Error(bodyEl.attrs.condition || 'Session terminated'));\n    }\n\n    this.emit('disconnect');\n    this.emit('end');\n    this.emit('close');\n  }\n};\n\nBOSHConnection.prototype.mayRequest = function () {\n  var canRequest =\n  /* Must have a session already */\n  this.sid && (\n  /* We can only receive when one request is in flight */\n  this.currentRequests === 0 ||\n  /* Is there something to send, and are we allowed? */\n  this.queue.length > 0 && this.currentRequests < this.maxRequests);\n  if (!canRequest) return;\n  var stanzas = this.queue;\n  this.queue = [];\n  this.rid++;\n  this.request({}, stanzas, function (err, bodyEl) {\n    if (err) {\n      this.emit('error', err);\n      this.emit('disconnect');\n      this.emit('end');\n      delete this.sid;\n      this.emit('close');\n    } else {\n      if (bodyEl) this.processResponse(bodyEl);\n      process.nextTick(this.mayRequest.bind(this));\n    }\n  }.bind(this));\n};\n\nBOSHConnection.prototype.end = function (stanzas) {\n  stanzas = stanzas || [];\n  if (typeof stanzas !== Array) stanzas = [stanzas];\n  stanzas = this.queue.concat(stanzas);\n  this.shutdown = true;\n  this.queue = [];\n  this.rid++;\n  this.request({\n    type: 'terminate'\n  }, stanzas, function (err, bodyEl) {\n    if (err) {} else if (bodyEl) {\n      this.processResponse(bodyEl);\n    }\n\n    this.emit('disconnect');\n    this.emit('end');\n    delete this.sid;\n    this.emit('close');\n  }.bind(this));\n};\n\nBOSHConnection.prototype.maxHTTPRetries = 5;\n\nBOSHConnection.prototype.request = function (attrs, children, cb, retry) {\n  var that = this;\n  retry = retry || 0;\n  attrs.rid = this.rid.toString();\n  if (this.sid) attrs.sid = this.sid;\n\n  for (var k in this.xmlnsAttrs) {\n    attrs[k] = this.xmlnsAttrs[k];\n  }\n\n  var boshEl = new ltx.Element('body', attrs);\n\n  for (var i = 0; i < children.length; i++) {\n    boshEl.cnode(children[i]);\n  }\n\n  debug('send bosh request:' + boshEl.toString());\n  request({\n    uri: this.boshURL,\n    method: 'POST',\n    headers: {\n      'Content-Type': this.contentType\n    },\n    body: boshEl.toString()\n  }, function (err, res, body) {\n    that.currentRequests--;\n\n    if (err) {\n      if (retry < that.maxHTTPRetries) {\n        return that.request(attrs, children, cb, retry + 1);\n      } else {\n        return cb(err);\n      }\n    }\n\n    if (res.statusCode < 200 || res.statusCode >= 400) {\n      return cb(new Error('HTTP status ' + res.statusCode));\n    }\n\n    var bodyEl;\n\n    try {\n      bodyEl = ltx.parse(body);\n    } catch (e) {\n      return cb(e);\n    }\n\n    if (bodyEl && bodyEl.attrs.type === 'terminate' && bodyEl.attrs.condition) {\n      cb(new Error(bodyEl.attrs.condition));\n    } else if (bodyEl) {\n      cb(null, bodyEl);\n    } else {\n      cb(new Error('no <body/>'));\n    }\n  });\n  this.currentRequests++;\n};\n\nmodule.exports = BOSHConnection;","map":null,"metadata":{},"sourceType":"script"}