{"ast":null,"code":"'use strict';\n/** Modules */\n\nvar config = require('../cubeConfig');\n\nvar Helpers = require('./cubeWebRTCHelpers');\n\nvar sdptransform = require('../cubeDependencies').SDPTransform;\n\nvar RTCPeerConnection = require('../cubeDependencies').RTCPeerConnection;\n\nvar RTCSessionDescription = require('../cubeDependencies').RTCSessionDescription;\n\nvar RTCIceCandidate = require('../cubeDependencies').RTCIceCandidate;\n\nvar MediaStream = require('../cubeDependencies').MediaStream;\n\nRTCPeerConnection.State = {\n  NEW: 1,\n  CONNECTING: 2,\n  CHECKING: 3,\n  CONNECTED: 4,\n  DISCONNECTED: 5,\n  FAILED: 6,\n  CLOSED: 7,\n  COMPLETED: 8\n};\n\nRTCPeerConnection.prototype._init = function (delegate, userID, sessionID, type) {\n  Helpers.trace('RTCPeerConnection init. userID: ' + userID + ', sessionID: ' + sessionID + ', type: ' + type);\n  this.delegate = delegate;\n  this.sessionID = sessionID;\n  this.userID = userID;\n  this.type = type;\n  this.remoteSDP = null;\n  this.state = RTCPeerConnection.State.NEW;\n  this.onicecandidate = this.onIceCandidateCallback.bind(this);\n  this.onsignalingstatechange = this.onSignalingStateCallback.bind(this);\n  this.oniceconnectionstatechange = this.onIceConnectionStateCallback.bind(this);\n\n  if (Helpers.getVersionSafari() >= 11) {\n    this.remoteStream = new MediaStream();\n    this.ontrack = this.onAddRemoteMediaCallback.bind(this);\n    this.onStatusClosedChecker = undefined;\n  } else {\n    this.remoteStream = null;\n    this.onaddstream = this.onAddRemoteMediaCallback.bind(this);\n  }\n  /** We use this timer interval to dial a user - produce the call requests each N seconds. */\n\n\n  this.dialingTimer = null;\n  this.answerTimeInterval = 0;\n  this.statsReportTimer = null;\n  this.iceCandidates = [];\n};\n\nRTCPeerConnection.prototype.release = function () {\n  this._clearDialingTimer();\n\n  this._clearStatsReportTimer();\n\n  if (this.connectionState !== 'closed') {\n    this.close();\n  } // TODO: 'closed' state doesn't fires on Safari 11 (do it manually)\n\n\n  if (Helpers.getVersionSafari() >= 11) {\n    this.onIceConnectionStateCallback();\n  }\n};\n\nRTCPeerConnection.prototype.updateRemoteSDP = function (newSDP) {\n  if (!newSDP) {\n    throw new Error(\"sdp string can't be empty.\");\n  } else {\n    this.remoteSDP = newSDP;\n  }\n};\n\nRTCPeerConnection.prototype.getRemoteSDP = function () {\n  return this.remoteSDP;\n};\n\nRTCPeerConnection.prototype.setRemoteSessionDescription = function (type, remoteSessionDescription, callback) {\n  var self = this,\n      desc = new RTCSessionDescription({\n    sdp: remoteSessionDescription,\n    type: type\n  }),\n      ffVersion = Helpers.getVersionFirefox();\n\n  if (ffVersion !== null && (ffVersion === 56 || ffVersion === 57) && !self.delegate.bandwidth) {\n    desc.sdp = _modifySDPforFixIssueFFAndFreezes(desc.sdp);\n  } else {\n    desc.sdp = setMediaBitrate(desc.sdp, 'video', self.delegate.bandwidth);\n  }\n\n  function successCallback(desc) {\n    callback(null);\n  }\n\n  function errorCallback(error) {\n    callback(error);\n  }\n\n  self.setRemoteDescription(desc).then(successCallback, errorCallback);\n};\n\nRTCPeerConnection.prototype.addLocalStream = function (localStream) {\n  if (localStream) {\n    this.addStream(localStream);\n  } else {\n    throw new Error(\"'RTCPeerConnection.addStream' error: stream is 'null'.\");\n  }\n};\n\nRTCPeerConnection.prototype.getAndSetLocalSessionDescription = function (callType, callback) {\n  var self = this;\n  self.state = RTCPeerConnection.State.CONNECTING;\n\n  if (self.type === 'offer') {\n    // Additional parameters for SDP Constraints\n    // http://www.w3.org/TR/webrtc/#h-offer-answer-options\n    self.createOffer().then(function (offer) {\n      offer.sdp = setMediaBitrate(offer.sdp, 'video', self.delegate.bandwidth);\n      successCallback(offer);\n    }).catch(function (reason) {\n      errorCallback(reason);\n    });\n  } else {\n    self.createAnswer().then(function (answer) {\n      answer.sdp = setMediaBitrate(answer.sdp, 'video', self.delegate.bandwidth);\n      successCallback(answer);\n    }).catch(function (reason) {\n      errorCallback(reason);\n    });\n  }\n\n  function successCallback(desc) {\n    /**\n     * It's to fixed issue\n     * https://bugzilla.mozilla.org/show_bug.cgi?id=1377434\n     * callType === 2 is audio only\n     */\n    var ffVersion = Helpers.getVersionFirefox();\n\n    if (ffVersion !== null && ffVersion < 55 && callType === 2 && self.type === 'offer') {\n      desc.sdp = _modifySDPforFixIssue(desc.sdp);\n    }\n\n    self.setLocalDescription(desc).then(function () {\n      callback(null);\n    }).catch(function (error) {\n      errorCallback(error);\n    });\n  }\n\n  function errorCallback(error) {\n    callback(error);\n  }\n};\n\nRTCPeerConnection.prototype.addCandidates = function (iceCandidates) {\n  var candidate;\n\n  for (var i = 0, len = iceCandidates.length; i < len; i++) {\n    candidate = {\n      sdpMLineIndex: iceCandidates[i].sdpMLineIndex,\n      sdpMid: iceCandidates[i].sdpMid,\n      candidate: iceCandidates[i].candidate\n    };\n    this.addIceCandidate(new RTCIceCandidate(candidate), function () {}, function (error) {\n      Helpers.traceError(\"Error on 'addIceCandidate': \" + error);\n    });\n  }\n};\n\nRTCPeerConnection.prototype.toString = function sessionToString() {\n  return 'sessionID: ' + this.sessionID + ', userID:  ' + this.userID + ', type: ' + this.type + ', state: ' + this.state;\n};\n/**\n * CALLBACKS\n */\n\n\nRTCPeerConnection.prototype.onSignalingStateCallback = function () {\n  if (this.signalingState === 'stable' && this.iceCandidates.length > 0) {\n    this.delegate.processIceCandidates(this, this.iceCandidates);\n    this.iceCandidates.length = 0;\n  }\n};\n\nRTCPeerConnection.prototype.onIceCandidateCallback = function (event) {\n  var candidate = event.candidate;\n\n  if (candidate) {\n    /**\n     * collecting internally the ice candidates\n     * will send a bit later\n     */\n    var ICECandidate = {\n      sdpMLineIndex: candidate.sdpMLineIndex,\n      sdpMid: candidate.sdpMid,\n      candidate: candidate.candidate\n    };\n\n    if (this.signalingState === 'stable') {\n      this.delegate.processIceCandidates(this, [ICECandidate]);\n    } else {\n      this.iceCandidates.push(ICECandidate);\n    }\n  }\n};\n/** handler of remote media stream */\n\n\nRTCPeerConnection.prototype.onAddRemoteMediaCallback = function (event) {\n  var self = this;\n\n  if (typeof self.delegate._onRemoteStreamListener === 'function') {\n    if (event.type === 'addstream') {\n      self.remoteStream = event.stream;\n    } else {\n      self.remoteStream.addTrack(event.track);\n    }\n\n    if (self.delegate.callType == 1 && self.remoteStream.getVideoTracks().length || self.delegate.callType == 2 && self.remoteStream.getAudioTracks().length) {\n      this.delegate._onRemoteStreamListener(self.userID, self.remoteStream);\n    }\n\n    self._getStatsWrap();\n  }\n};\n\nRTCPeerConnection.prototype.onIceConnectionStateCallback = function () {\n  Helpers.trace(\"onIceConnectionStateCallback: \" + this.iceConnectionState);\n  var self = this;\n  /**\n   * read more about all states:\n   * http://w3c.github.io/webrtc-pc/#idl-def-RTCIceConnectionState\n   * 'disconnected' happens in a case when a user has killed an application (for example, on iOS/Android via task manager).\n   * So we should notify our user about it.\n   */\n\n  if (typeof this.delegate._onSessionConnectionStateChangedListener === 'function') {\n    var connectionState = null;\n\n    if (Helpers.getVersionSafari() >= 11) {\n      clearTimeout(this.onStatusClosedChecker);\n    }\n\n    switch (this.iceConnectionState) {\n      case 'checking':\n        this.state = RTCPeerConnection.State.CHECKING;\n        connectionState = Helpers.SessionConnectionState.CONNECTING;\n        break;\n\n      case 'connected':\n        this._clearWaitingReconnectTimer();\n\n        this.state = RTCPeerConnection.State.CONNECTED;\n        connectionState = Helpers.SessionConnectionState.CONNECTED;\n        break;\n\n      case 'completed':\n        this._clearWaitingReconnectTimer();\n\n        this.state = RTCPeerConnection.State.COMPLETED;\n        connectionState = Helpers.SessionConnectionState.COMPLETED;\n        break;\n\n      case 'failed':\n        this.state = RTCPeerConnection.State.FAILED;\n        connectionState = Helpers.SessionConnectionState.FAILED;\n        break;\n\n      case 'disconnected':\n        this._startWaitingReconnectTimer();\n\n        this.state = RTCPeerConnection.State.DISCONNECTED;\n        connectionState = Helpers.SessionConnectionState.DISCONNECTED; // repeat to call onIceConnectionStateCallback to get status \"closed\"\n\n        if (Helpers.getVersionSafari() >= 11) {\n          this.onStatusClosedChecker = setTimeout(function () {\n            self.onIceConnectionStateCallback();\n          }, 500);\n        }\n\n        break;\n      // TODO: this state doesn't fires on Safari 11\n\n      case 'closed':\n        this._clearWaitingReconnectTimer();\n\n        this.state = RTCPeerConnection.State.CLOSED;\n        connectionState = Helpers.SessionConnectionState.CLOSED;\n        break;\n\n      default:\n        break;\n    }\n\n    if (connectionState) {\n      self.delegate._onSessionConnectionStateChangedListener(this.userID, connectionState);\n    }\n  }\n};\n/**\n * PRIVATE\n */\n\n\nRTCPeerConnection.prototype._clearStatsReportTimer = function () {\n  if (this.statsReportTimer) {\n    clearInterval(this.statsReportTimer);\n    this.statsReportTimer = null;\n  }\n};\n\nRTCPeerConnection.prototype._getStatsWrap = function () {\n  var self = this,\n      statsReportInterval,\n      lastResult;\n\n  if (config.videochat && config.videochat.statsReportTimeInterval) {\n    if (isNaN(+config.videochat.statsReportTimeInterval)) {\n      Helpers.traceError('statsReportTimeInterval (' + config.videochat.statsReportTimeInterval + ') must be integer.');\n      return;\n    }\n\n    statsReportInterval = config.videochat.statsReportTimeInterval * 1000;\n\n    var _statsReportCallback = function _statsReportCallback() {\n      _getStats(self, lastResult, function (results, lastResults) {\n        lastResult = lastResults;\n\n        self.delegate._onCallStatsReport(self.userID, results, null);\n      }, function errorLog(err) {\n        Helpers.traceError('_getStats error. ' + err.name + ': ' + err.message);\n\n        self.delegate._onCallStatsReport(self.userID, null, err);\n      });\n    };\n\n    Helpers.trace('Stats tracker has been started.');\n    self.statsReportTimer = setInterval(_statsReportCallback, statsReportInterval);\n  }\n};\n\nRTCPeerConnection.prototype._clearWaitingReconnectTimer = function () {\n  if (this.waitingReconnectTimeoutCallback) {\n    Helpers.trace('_clearWaitingReconnectTimer');\n    clearTimeout(this.waitingReconnectTimeoutCallback);\n    this.waitingReconnectTimeoutCallback = null;\n  }\n};\n\nRTCPeerConnection.prototype._startWaitingReconnectTimer = function () {\n  var self = this,\n      timeout = config.videochat.disconnectTimeInterval * 1000,\n      waitingReconnectTimeoutCallback = function waitingReconnectTimeoutCallback() {\n    Helpers.trace('waitingReconnectTimeoutCallback');\n    clearTimeout(self.waitingReconnectTimeoutCallback);\n    self.release();\n\n    self.delegate._closeSessionIfAllConnectionsClosed();\n  };\n\n  Helpers.trace('_startWaitingReconnectTimer, timeout: ' + timeout);\n  self.waitingReconnectTimeoutCallback = setTimeout(waitingReconnectTimeoutCallback, timeout);\n};\n\nRTCPeerConnection.prototype._clearDialingTimer = function () {\n  if (this.dialingTimer) {\n    Helpers.trace('_clearDialingTimer');\n    clearInterval(this.dialingTimer);\n    this.dialingTimer = null;\n    this.answerTimeInterval = 0;\n  }\n};\n\nRTCPeerConnection.prototype._startDialingTimer = function (extension, withOnNotAnswerCallback) {\n  var self = this;\n  var dialingTimeInterval = config.videochat.dialingTimeInterval * 1000;\n  Helpers.trace('_startDialingTimer, dialingTimeInterval: ' + dialingTimeInterval);\n\n  var _dialingCallback = function _dialingCallback(extension, withOnNotAnswerCallback, skipIncrement) {\n    if (!skipIncrement) {\n      self.answerTimeInterval += config.videochat.dialingTimeInterval * 1000;\n    }\n\n    Helpers.trace('_dialingCallback, answerTimeInterval: ' + self.answerTimeInterval);\n\n    if (self.answerTimeInterval >= config.videochat.answerTimeInterval * 1000) {\n      self._clearDialingTimer();\n\n      if (withOnNotAnswerCallback) {\n        self.delegate.processOnNotAnswer(self);\n      }\n    } else {\n      self.delegate.processCall(self, extension);\n    }\n  };\n\n  self.dialingTimer = setInterval(_dialingCallback, dialingTimeInterval, extension, withOnNotAnswerCallback, false); // call for the 1st time\n\n  _dialingCallback(extension, withOnNotAnswerCallback, true);\n};\n/**\n * PRIVATE\n */\n\n\nfunction _getStats(peer, lastResults, successCallback, errorCallback) {\n  var statistic = {\n    'local': {\n      'audio': {},\n      'video': {},\n      'candidate': {}\n    },\n    'remote': {\n      'audio': {},\n      'video': {},\n      'candidate': {}\n    }\n  };\n\n  if (Helpers.getVersionFirefox()) {\n    var localStream = peer.getLocalStreams().length ? peer.getLocalStreams()[0] : peer.delegate.localStream,\n        localVideoSettings = localStream.getVideoTracks().length ? localStream.getVideoTracks()[0].getSettings() : null;\n    statistic.local.video.frameHeight = localVideoSettings && localVideoSettings.height;\n    statistic.local.video.frameWidth = localVideoSettings && localVideoSettings.width;\n  }\n\n  peer.getStats(null).then(function (results) {\n    results.forEach(function (result) {\n      var item;\n\n      if (result.bytesReceived && result.type === 'inbound-rtp') {\n        item = statistic.remote[result.mediaType];\n        item.bitrate = _getBitratePerSecond(result, lastResults, false);\n        item.bytesReceived = result.bytesReceived;\n        item.packetsReceived = result.packetsReceived;\n        item.timestamp = result.timestamp;\n\n        if (result.mediaType === 'video' && result.framerateMean) {\n          item.framesPerSecond = Math.round(result.framerateMean * 10) / 10;\n        }\n      } else if (result.bytesSent && result.type === 'outbound-rtp') {\n        item = statistic.local[result.mediaType];\n        item.bitrate = _getBitratePerSecond(result, lastResults, true);\n        item.bytesSent = result.bytesSent;\n        item.packetsSent = result.packetsSent;\n        item.timestamp = result.timestamp;\n\n        if (result.mediaType === 'video' && result.framerateMean) {\n          item.framesPerSecond = Math.round(result.framerateMean * 10) / 10;\n        }\n      } else if (result.type === 'local-candidate') {\n        item = statistic.local.candidate;\n\n        if (result.candidateType === 'host' && result.mozLocalTransport === 'udp' && result.transport === 'udp') {\n          item.protocol = result.transport;\n          item.ip = result.ipAddress;\n          item.port = result.portNumber;\n        } else if (!Helpers.getVersionFirefox()) {\n          item.protocol = result.protocol;\n          item.ip = result.ip;\n          item.port = result.port;\n        }\n      } else if (result.type === 'remote-candidate') {\n        item = statistic.remote.candidate;\n        item.protocol = result.protocol || result.transport;\n        item.ip = result.ip || result.ipAddress;\n        item.port = result.port || result.portNumber;\n      } else if (result.type === 'track' && result.kind === 'video' && !Helpers.getVersionFirefox()) {\n        if (result.remoteSource) {\n          item = statistic.remote.video;\n          item.frameHeight = result.frameHeight;\n          item.frameWidth = result.frameWidth;\n          item.framesPerSecond = _getFramesPerSecond(result, lastResults, false);\n        } else {\n          item = statistic.local.video;\n          item.frameHeight = result.frameHeight;\n          item.frameWidth = result.frameWidth;\n          item.framesPerSecond = _getFramesPerSecond(result, lastResults, true);\n        }\n      }\n    });\n    successCallback(statistic, results);\n  }, errorCallback);\n\n  function _getBitratePerSecond(result, lastResults, isLocal) {\n    var lastResult = lastResults && lastResults.get(result.id),\n        seconds = lastResult ? (result.timestamp - lastResult.timestamp) / 1000 : 5,\n        kilo = 1024,\n        bit = 8,\n        bitrate;\n\n    if (!lastResult) {\n      bitrate = 0;\n    } else if (isLocal) {\n      bitrate = bit * (result.bytesSent - lastResult.bytesSent) / (kilo * seconds);\n    } else {\n      bitrate = bit * (result.bytesReceived - lastResult.bytesReceived) / (kilo * seconds);\n    }\n\n    return Math.round(bitrate);\n  }\n\n  function _getFramesPerSecond(result, lastResults, isLocal) {\n    var lastResult = lastResults && lastResults.get(result.id),\n        seconds = lastResult ? (result.timestamp - lastResult.timestamp) / 1000 : 5,\n        framesPerSecond;\n\n    if (!lastResult) {\n      framesPerSecond = 0;\n    } else if (isLocal) {\n      framesPerSecond = (result.framesSent - lastResult.framesSent) / seconds;\n    } else {\n      framesPerSecond = (result.framesReceived - lastResult.framesReceived) / seconds;\n    }\n\n    return Math.round(framesPerSecond * 10) / 10;\n  }\n}\n/**\n * It's functions to fixed issue\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1377434\n */\n\n\nfunction _modifySDPforFixIssue(sdp) {\n  var parsedSDP = sdptransform.parse(sdp);\n  parsedSDP.groups = parsedSDP.groups ? parsedSDP.groups : [];\n  parsedSDP.groups.push({\n    mids: 'sdparta_0',\n    type: 'BUNDLE'\n  });\n  return sdptransform.write(parsedSDP);\n}\n/**\n * It's functions to fixed issue\n * https://blog.mozilla.org/webrtc/when-your-video-freezes/\n */\n\n\nfunction _modifySDPforFixIssueFFAndFreezes(sdp) {\n  return setMediaBitrate(sdp, 'video', 12288);\n}\n\nfunction setMediaBitrate(sdp, media, bitrate) {\n  if (!bitrate) {\n    return sdp.replace(/b=AS:.*\\r\\n/, '').replace(/b=TIAS:.*\\r\\n/, '');\n  }\n\n  var lines = sdp.split('\\n'),\n      line = -1,\n      modifier = Helpers.getVersionFirefox() ? 'TIAS' : 'AS',\n      amount = Helpers.getVersionFirefox() ? bitrate * 1024 : bitrate;\n\n  for (var i = 0; i < lines.length; i++) {\n    if (lines[i].indexOf(\"m=\" + media) === 0) {\n      line = i;\n      break;\n    }\n  }\n\n  if (line === -1) {\n    return sdp;\n  }\n\n  line++;\n\n  while (lines[line].indexOf('i=') === 0 || lines[line].indexOf('c=') === 0) {\n    line++;\n  }\n\n  if (lines[line].indexOf('b') === 0) {\n    lines[line] = 'b=' + modifier + ':' + amount;\n    return lines.join('\\n');\n  }\n\n  var newLines = lines.slice(0, line);\n  newLines.push('b=' + modifier + ':' + amount);\n  newLines = newLines.concat(lines.slice(line, lines.length));\n  return newLines.join('\\n');\n}\n\nmodule.exports = RTCPeerConnection;","map":null,"metadata":{},"sourceType":"script"}