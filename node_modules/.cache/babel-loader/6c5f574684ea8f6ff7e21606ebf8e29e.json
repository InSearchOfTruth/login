{"ast":null,"code":"/* Chat module: Privacy list\n *\n * Privacy list\n * http://xmpp.org/extensions/xep-0016.html\n * by default 'mutualBlock' is work in one side\n----------------------------------------------------------------------------- */\nvar ChatUtils = require('./cubeChatInternalUtils'),\n    Utils = require('../cubeInternalUtils');\n\nfunction PrivacyListProxy(options) {\n  this.helpers = options.helpers;\n  this.xmppClient = options.xmppClient;\n  this.nodeStanzasCallbacks = options.nodeStanzasCallbacks;\n}\n/**\n * @namespace CB.chat.privacylist\n **/\n\n\nPrivacyListProxy.prototype = {\n  /**\n   * Create a privacy list.\n   * @memberof CB.chat.privacylist\n   * @param {Object} list - privacy list object.\n   * @param {createPrivacylistCallback} callback - The callback function.\n   * */\n  create: function create(list, callback) {\n    /**\n     * Callback for CB.chat.privacylist.create().\n     * @param {Object} error - The error object\n     * @callback createPrivacylistCallback\n     * */\n    var self = this;\n    var userId,\n        userJid,\n        userMuc,\n        userAction,\n        mutualBlock,\n        listPrivacy = {},\n        listUserId = [];\n    /** Filled listPrivacys */\n\n    for (var i = list.items.length - 1; i >= 0; i--) {\n      var user = list.items[i];\n      listPrivacy[user.user_id] = {\n        action: user.action,\n        mutualBlock: user.mutualBlock === true ? true : false\n      };\n    }\n    /** Filled listUserId */\n\n\n    listUserId = Object.keys(listPrivacy);\n    var iqParams = {\n      type: 'set',\n      from: self.helpers.getUserCurrentJid(),\n      id: ChatUtils.getUniqueId('edit')\n    };\n    var iq = ChatUtils.createIqStanza(iqParams);\n    iq.c('query', {\n      xmlns: ChatUtils.MARKERS.PRIVACY\n    }).c('list', {\n      name: list.name\n    });\n\n    function createPrivacyItem(iq, params) {\n      if (Utils.getEnv().browser) {\n        iq.c('item', {\n          type: 'jid',\n          value: params.jidOrMuc,\n          action: params.userAction,\n          order: params.order\n        }).c('message', {}).up().c('presence-in', {}).up().c('presence-out', {}).up().c('iq', {}).up().up();\n      } else {\n        var _list = iq.getChild('query').getChild('list');\n\n        _list.c('item', {\n          type: 'jid',\n          value: params.jidOrMuc,\n          action: params.userAction,\n          order: params.order\n        }).c('message', {}).up().c('presence-in', {}).up().c('presence-out', {}).up().c('iq', {}).up().up();\n      }\n\n      return iq;\n    }\n\n    function createPrivacyItemMutal(iq, params) {\n      if (Utils.getEnv().browser) {\n        iq.c('item', {\n          type: 'jid',\n          value: params.jidOrMuc,\n          action: params.userAction,\n          order: params.order\n        }).up();\n      } else {\n        var _list2 = iq.getChild('query').getChild('list');\n\n        _list2.c('item', {\n          type: 'jid',\n          value: params.jidOrMuc,\n          action: params.userAction,\n          order: params.order\n        }).up();\n      }\n\n      return iq;\n    }\n\n    for (var index = 0, j = 0, len = listUserId.length; index < len; index++, j = j + 2) {\n      userId = listUserId[index];\n      mutualBlock = listPrivacy[userId].mutualBlock;\n      userAction = listPrivacy[userId].action;\n      userJid = self.helpers.jidOrUserId(parseInt(userId, 10));\n      userMuc = self.helpers.getUserNickWithMucDomain(userId);\n\n      if (mutualBlock && userAction === 'deny') {\n        iq = createPrivacyItemMutal(iq, {\n          order: j + 1,\n          jidOrMuc: userJid,\n          userAction: userAction\n        });\n        iq = createPrivacyItemMutal(iq, {\n          order: j + 2,\n          jidOrMuc: userMuc,\n          userAction: userAction\n        }).up().up();\n      } else {\n        iq = createPrivacyItem(iq, {\n          order: j + 1,\n          jidOrMuc: userJid,\n          userAction: userAction\n        });\n        iq = createPrivacyItem(iq, {\n          order: j + 2,\n          jidOrMuc: userMuc,\n          userAction: userAction\n        });\n      }\n    }\n\n    if (Utils.getEnv().browser) {\n      self.xmppClient.sendIQ(iq, function (stanzaResult) {\n        callback(null);\n      }, function (stanzaError) {\n        if (stanzaError) {\n          callback(ChatUtils.getErrorFromXMLNode(stanzaError));\n        } else {\n          callback(Utils.getError(408));\n        }\n      });\n    } else {\n      self.xmppClient.send(iq);\n\n      self.nodeStanzasCallbacks[iqParams.id] = function (stanza) {\n        if (!stanza.getChildElements('error').length) {\n          callback(null);\n        } else {\n          callback(Utils.getError(408));\n        }\n      };\n    }\n  },\n\n  /**\n   * Get the privacy list.\n   * @memberof CB.chat.privacylist\n   * @param {String} name - The name of the list.\n   * @param {getListPrivacylistCallback} callback - The callback function.\n   * */\n  getList: function getList(name, callback) {\n    /**\n     * Callback for CB.chat.privacylist.getList().\n     * @param {Object} error - The error object\n     * @param {Object} response - The privacy list object\n     * @callback getListPrivacylistCallback\n     * */\n    var self = this;\n    var items,\n        userJid,\n        userId,\n        usersList = [],\n        list = {};\n    var iqParams = {\n      type: 'get',\n      from: self.helpers.getUserCurrentJid(),\n      id: ChatUtils.getUniqueId('getlist')\n    };\n    var iq = ChatUtils.createIqStanza(iqParams);\n    iq.c('query', {\n      xmlns: ChatUtils.MARKERS.PRIVACY\n    }).c('list', {\n      name: name\n    });\n\n    if (Utils.getEnv().browser) {\n      self.xmppClient.sendIQ(iq, function (stanzaResult) {\n        items = stanzaResult.getElementsByTagName('item');\n\n        for (var i = 0, len = items.length; i < len; i = i + 2) {\n          userJid = items[i].getAttribute('value');\n          userId = self.helpers.getIdFromNode(userJid);\n          usersList.push({\n            user_id: userId,\n            action: items[i].getAttribute('action')\n          });\n        }\n\n        list = {\n          name: name,\n          items: usersList\n        };\n        callback(null, list);\n      }, function (stanzaError) {\n        if (stanzaError) {\n          callback(ChatUtils.getErrorFromXMLNode(stanzaError), null);\n        } else {\n          callback(Utils.getError(408), null);\n        }\n      });\n    } else {\n      self.nodeStanzasCallbacks[iqParams.id] = function (stanza) {\n        var stanzaQuery = stanza.getChild('query');\n        list = stanzaQuery ? stanzaQuery.getChild('list') : null;\n        items = list ? list.getChildElements('item') : null;\n\n        for (var i = 0, len = items.length; i < len; i = i + 2) {\n          userJid = items[i].attrs.value;\n          userId = self.helpers.getIdFromNode(userJid);\n          usersList.push({\n            user_id: userId,\n            action: items[i].attrs.action\n          });\n        }\n\n        list = {\n          name: list.attrs.name,\n          items: usersList\n        };\n        callback(null, list);\n        delete self.nodeStanzasCallbacks[iqParams.id];\n      };\n\n      self.xmppClient.send(iq);\n    }\n  },\n\n  /**\n   * Update the privacy list.\n   * @memberof CB.chat.privacylist\n   * @param {String} name - The name of the list.\n   * @param {updatePrivacylistCallback} callback - The callback function.\n   * */\n  update: function update(listWithUpdates, callback) {\n    /**\n     * Callback for CB.chat.privacylist.update().\n     * @param {Object} error - The error object\n     * @param {Object} response - The privacy list object\n     * @callback updatePrivacylistCallback\n     * */\n    var self = this;\n    self.getList(listWithUpdates.name, function (error, existentList) {\n      if (error) {\n        callback(error, null);\n      } else {\n        var updatedList = {\n          items: Utils.MergeArrayOfObjects(existentList.items, listWithUpdates.items),\n          name: listWithUpdates.name\n        };\n        self.create(updatedList, function (err, result) {\n          if (error) {\n            callback(err, null);\n          } else {\n            callback(null, result);\n          }\n        });\n      }\n    });\n  },\n\n  /**\n   * Get names of privacy lists.\n   * Run without parameters\n   * @memberof CB.chat.privacylist\n   * @param {getNamesPrivacylistCallback} callback - The callback function.\n   * */\n  getNames: function getNames(callback) {\n    /**\n     * Callback for CB.chat.privacylist.getNames().\n     * @param {Object} error - The error object\n     * @param {Object} response - The privacy list object (let names = response.names;)\n     * @callback getNamesPrivacylistCallback\n     * */\n    var self = this,\n        iqParams = {\n      'type': 'get',\n      'from': self.helpers.getUserCurrentJid(),\n      'id': ChatUtils.getUniqueId('getNames')\n    };\n    var iq = ChatUtils.createIqStanza(iqParams);\n    iq.c('query', {\n      xmlns: ChatUtils.MARKERS.PRIVACY\n    });\n\n    if (Utils.getEnv().browser) {\n      self.xmppClient.sendIQ(iq, function (stanzaResult) {\n        var defaultList = stanzaResult.getElementsByTagName('default'),\n            activeList = stanzaResult.getElementsByTagName('active'),\n            allLists = stanzaResult.getElementsByTagName('list');\n        var defaultName = defaultList && defaultList.length > 0 ? defaultList[0].getAttribute('name') : null,\n            activeName = activeList && activeList.length > 0 ? activeList[0].getAttribute('name') : null;\n        var allNames = [];\n\n        for (var i = 0, len = allLists.length; i < len; i++) {\n          allNames.push(allLists[i].getAttribute('name'));\n        }\n\n        var namesList = {\n          default: defaultName,\n          active: activeName,\n          names: allNames\n        };\n        callback(null, namesList);\n      }, function (stanzaError) {\n        if (stanzaError) {\n          callback(ChatUtils.getErrorFromXMLNode(stanzaError), null);\n        } else {\n          callback(Utils.getError(408), null);\n        }\n      });\n    } else {\n      self.nodeStanzasCallbacks[iq.attrs.id] = function (stanza) {\n        if (stanza.attrs.type !== 'error') {\n          var query = stanza.getChild('query'),\n              defaultList = query.getChild('default'),\n              activeList = query.getChild('active'),\n              allLists = query.getChildElements('list');\n          var defaultName = defaultList ? defaultList.attrs.name : null,\n              activeName = activeList ? activeList.attrs.name : null;\n          var allNames = [];\n\n          for (var i = 0, len = allLists.length; i < len; i++) {\n            allNames.push(allLists[i].attrs.name);\n          }\n\n          var namesList = {\n            default: defaultName,\n            active: activeName,\n            names: allNames\n          };\n          callback(null, namesList);\n        } else {\n          callback(Utils.getError(408));\n        }\n      };\n\n      self.xmppClient.send(iq);\n    }\n  },\n\n  /**\n   * Delete privacy list.\n   * @param {String} name - The name of privacy list.\n   * @memberof CB.chat.privacylist\n   * @param {deletePrivacylistCallback} callback - The callback function.\n   * */\n  delete: function _delete(name, callback) {\n    /**\n     * Callback for CB.chat.privacylist.delete().\n     * @param {Object} error - The error object\n     * @callback deletePrivacylistCallback\n     * */\n    var iqParams = {\n      from: this.xmppClient.jid || this.xmppClient.jid.user,\n      type: 'set',\n      id: ChatUtils.getUniqueId('remove')\n    };\n    var iq = ChatUtils.createIqStanza(iqParams);\n    iq.c('query', {\n      xmlns: ChatUtils.MARKERS.PRIVACY\n    }).c('list', {\n      name: name ? name : ''\n    });\n\n    if (Utils.getEnv().browser) {\n      this.xmppClient.sendIQ(iq, function (stanzaResult) {\n        callback(null);\n      }, function (stanzaError) {\n        if (stanzaError) {\n          callback(ChatUtils.getErrorFromXMLNode(stanzaError));\n        } else {\n          callback(Utils.getError(408));\n        }\n      });\n    } else {\n      this.nodeStanzasCallbacks[iq.attrs.id] = function (stanza) {\n        if (!stanza.getChildElements('error').length) {\n          callback(null);\n        } else {\n          callback(Utils.getError(408));\n        }\n      };\n\n      this.xmppClient.send(iq);\n    }\n  },\n\n  /**\n   * Set as default privacy list.\n   * @param {String} name - The name of privacy list.\n   * @memberof CB.chat.privacylist\n   * @param {setAsDefaultPrivacylistCallback} callback - The callback function.\n   * */\n  setAsDefault: function setAsDefault(name, callback) {\n    /**\n     * Callback for CB.chat.privacylist.setAsDefault().\n     * @param {Object} error - The error object\n     * @callback setAsDefaultPrivacylistCallback\n     * */\n    var iqParams = {\n      from: this.xmppClient.jid || this.xmppClient.jid.user,\n      type: 'set',\n      id: ChatUtils.getUniqueId('default')\n    };\n    var iq = ChatUtils.createIqStanza(iqParams);\n    iq.c('query', {\n      xmlns: ChatUtils.MARKERS.PRIVACY\n    }).c('default', name && name.length > 0 ? {\n      name: name\n    } : {});\n\n    if (Utils.getEnv().browser) {\n      this.xmppClient.sendIQ(iq, function (stanzaResult) {\n        callback(null);\n      }, function (stanzaError) {\n        if (stanzaError) {\n          callback(ChatUtils.getErrorFromXMLNode(stanzaError));\n        } else {\n          callback(Utils.getError(408));\n        }\n      });\n    } else {\n      this.nodeStanzasCallbacks[iq.attrs.id] = function (stanza) {\n        if (!stanza.getChildElements('error').length) {\n          callback(null);\n        } else {\n          callback(Utils.getError(408));\n        }\n      };\n\n      this.xmppClient.send(iq);\n    }\n  }\n};\nmodule.exports = PrivacyListProxy;","map":null,"metadata":{},"sourceType":"script"}