{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"D:\\\\practics\\\\ConnectyCube\\\\test\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"D:\\\\practics\\\\ConnectyCube\\\\test\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:\\\\practics\\\\ConnectyCube\\\\test\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"D:\\\\practics\\\\ConnectyCube\\\\test\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:\\\\practics\\\\ConnectyCube\\\\test\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"D:\\\\practics\\\\ConnectyCube\\\\test\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"D:\\\\practics\\\\ConnectyCube\\\\test\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"D:\\\\practics\\\\ConnectyCube\\\\test\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _require = require('@xmpp/events'),\n    timeout = _require.timeout,\n    EventEmitter = _require.EventEmitter,\n    promise = _require.promise;\n\nvar jid = require('@xmpp/jid');\n\nvar xml = require('@xmpp/xml');\n\nvar StreamError = require('./lib/StreamError');\n\nvar NS_STREAM = 'urn:ietf:params:xml:ns:xmpp-streams';\n\nfunction socketConnect(socket) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n\n  return new Promise(function (resolve, reject) {\n    function onError(err) {\n      socket.removeListener('connect', onConnect);\n      reject(err);\n    }\n\n    function onConnect(value) {\n      socket.removeListener('error', onError);\n      resolve(value);\n    }\n\n    socket.once('error', onError);\n    socket.once('connect', onConnect);\n    socket.connect.apply(socket, params);\n  });\n}\n\nvar Connection =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(Connection, _EventEmitter);\n\n  function Connection() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Connection);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Connection).call(this));\n    _this.domain = '';\n    _this.lang = '';\n    _this.jid = null;\n    _this.timeout = 2000;\n    _this.options = options;\n    _this.socketListeners = Object.create(null);\n    _this.parserListeners = Object.create(null);\n    _this.status = 'offline';\n    _this.socket = null;\n    _this.parser = null;\n    return _this;\n  }\n\n  _createClass(Connection, [{\n    key: \"_reset\",\n    value: function _reset() {\n      this.domain = '';\n      this.lang = '';\n      this.jid = null;\n      this.status = 'offline';\n\n      this._detachSocket();\n\n      this._detachParser();\n    }\n  }, {\n    key: \"_streamError\",\n    value: function () {\n      var _streamError2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(condition) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return this.send( // prettier-ignore\n                xml('stream:error', {}, [xml(condition, {\n                  xmlns: NS_STREAM\n                })]));\n\n              case 3:\n                _context.next = 7;\n                break;\n\n              case 5:\n                _context.prev = 5;\n                _context.t0 = _context[\"catch\"](0);\n\n              case 7:\n                return _context.abrupt(\"return\", this._end());\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 5]]);\n      }));\n\n      function _streamError(_x) {\n        return _streamError2.apply(this, arguments);\n      }\n\n      return _streamError;\n    }()\n  }, {\n    key: \"_onData\",\n    value: function () {\n      var _onData2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(data) {\n        var str;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                str = data.toString('utf8');\n                this.emit('input', str);\n                _context2.prev = 2;\n                _context2.next = 5;\n                return this.parser.write(str);\n\n              case 5:\n                _context2.next = 10;\n                break;\n\n              case 7:\n                _context2.prev = 7;\n                _context2.t0 = _context2[\"catch\"](2);\n\n                // https://xmpp.org/rfcs/rfc6120.html#streams-error-conditions-bad-format\n                // \"This error can be used instead of the more specific XML-related errors,\n                // such as <bad-namespace-prefix/>, <invalid-xml/>, <not-well-formed/>, <restricted-xml/>,\n                // and <unsupported-encoding/>. However, the more specific errors are RECOMMENDED.\"\n                try {\n                  this._streamError('bad-format');\n                } catch (err) {}\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[2, 7]]);\n      }));\n\n      function _onData(_x2) {\n        return _onData2.apply(this, arguments);\n      }\n\n      return _onData;\n    }()\n  }, {\n    key: \"_attachSocket\",\n    value: function _attachSocket(socket) {\n      var _this2 = this;\n\n      var sock = this.socket = socket;\n      var listeners = this.socketListeners;\n\n      listeners.data = function (data) {\n        _this2._onData(data);\n      };\n\n      listeners.close = function (dirty, event) {\n        _this2._reset();\n\n        _this2._status('disconnect', {\n          clean: !dirty,\n          event: event\n        });\n      };\n\n      listeners.connect = function () {\n        _this2._status('connect');\n      };\n\n      listeners.error = function (error) {\n        _this2.emit('error', error);\n      };\n\n      sock.on('close', listeners.close);\n      sock.on('data', listeners.data);\n      sock.on('error', listeners.error);\n      sock.on('connect', listeners.connect);\n    }\n  }, {\n    key: \"_detachSocket\",\n    value: function _detachSocket() {\n      var socketListeners = this.socketListeners,\n          socket = this.socket;\n      Object.getOwnPropertyNames(socketListeners).forEach(function (k) {\n        socket.removeListener(k, socketListeners[k]);\n        delete socketListeners[k];\n      });\n      this.socket = null;\n      return socket;\n    }\n  }, {\n    key: \"_onElement\",\n    value: function _onElement(element) {\n      this.emit('element', element);\n      this.emit(this.isStanza(element) ? 'stanza' : 'nonza', element); // https://xmpp.org/rfcs/rfc6120.html#streams-error\n\n      if (element.name !== 'stream:error') return;\n      this.emit('error', StreamError.fromElement(element)); // \"Stream Errors Are Unrecoverable\"\n      // \"The entity that receives the stream error then SHALL close the stream\"\n\n      this._end();\n    }\n  }, {\n    key: \"_attachParser\",\n    value: function _attachParser(p) {\n      var _this3 = this;\n\n      var parser = this.parser = p;\n      var listeners = this.parserListeners;\n\n      listeners.element = function (element) {\n        _this3._onElement(element);\n      };\n\n      listeners.error = function (error) {\n        _this3._detachParser();\n\n        _this3.emit('error', error);\n      };\n\n      listeners.end = function (element) {\n        _this3._detachParser();\n\n        _this3._status('close', element);\n      };\n\n      parser.on('error', listeners.error);\n      parser.on('element', listeners.element);\n      parser.on('end', listeners.end);\n    }\n  }, {\n    key: \"_detachParser\",\n    value: function _detachParser() {\n      var _this4 = this;\n\n      var listeners = this.parserListeners;\n      Object.getOwnPropertyNames(listeners).forEach(function (k) {\n        _this4.parser.removeListener(k, listeners[k]);\n\n        delete listeners[k];\n      });\n      this.parser = null;\n    }\n  }, {\n    key: \"_jid\",\n    value: function _jid(id) {\n      this.jid = jid(id);\n      return this.jid;\n    }\n  }, {\n    key: \"_status\",\n    value: function _status(status) {\n      this.status = status;\n\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      this.emit.apply(this, ['status', status].concat(args));\n      this.emit.apply(this, [status].concat(args));\n    }\n  }, {\n    key: \"_end\",\n    value: function () {\n      var _end2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3() {\n        var el;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return this.close();\n\n              case 3:\n                el = _context3.sent;\n                _context3.next = 8;\n                break;\n\n              case 6:\n                _context3.prev = 6;\n                _context3.t0 = _context3[\"catch\"](0);\n\n              case 8:\n                _context3.prev = 8;\n                _context3.next = 11;\n                return this.disconnect();\n\n              case 11:\n                _context3.next = 15;\n                break;\n\n              case 13:\n                _context3.prev = 13;\n                _context3.t1 = _context3[\"catch\"](8);\n\n              case 15:\n                return _context3.abrupt(\"return\", el);\n\n              case 16:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 6], [8, 13]]);\n      }));\n\n      function _end() {\n        return _end2.apply(this, arguments);\n      }\n\n      return _end;\n    }()\n    /**\n     * Opens the socket then opens the stream\n     */\n\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4() {\n        var _this$options, service, domain, lang, promiseOnline;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(this.status !== 'offline')) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new Error('Connection is not offline');\n\n              case 2:\n                _this$options = this.options, service = _this$options.service, domain = _this$options.domain, lang = _this$options.lang;\n                _context4.next = 5;\n                return this.connect(service);\n\n              case 5:\n                promiseOnline = promise(this, 'online');\n                _context4.next = 8;\n                return this.open({\n                  domain: domain,\n                  lang: lang\n                });\n\n              case 8:\n                return _context4.abrupt(\"return\", promiseOnline);\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function start() {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n    /**\n     * Connects the socket\n     */\n    // eslint-disable-next-line require-await\n\n  }, {\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(service) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                this._status('connecting');\n\n                this._attachSocket(new this.Socket()); // The 'connect' status is set by the socket 'connect' listener\n\n\n                return _context5.abrupt(\"return\", socketConnect(this.socket, this.socketParameters(service)));\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function connect(_x3) {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n    /**\n     * Disconnects the socket\n     * https://xmpp.org/rfcs/rfc6120.html#streams-close\n     * https://tools.ietf.org/html/rfc7395#section-3.6\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function () {\n      var _disconnect = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6() {\n        var ms,\n            _args6 = arguments;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                ms = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : this.timeout;\n                if (this.socket) this._status('disconnecting');\n                this.socket.end(); // The 'disconnect' status is set by the socket 'close' listener\n\n                _context6.next = 5;\n                return timeout(promise(this.socket, 'close'), ms);\n\n              case 5:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function disconnect() {\n        return _disconnect.apply(this, arguments);\n      }\n\n      return disconnect;\n    }()\n    /**\n     * Opens the stream\n     */\n\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee8(options) {\n        var _this5 = this;\n\n        var _options, domain, lang, headerElement, promiseStart;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                this._status('opening');\n\n                if (typeof options === 'string') {\n                  options = {\n                    domain: options\n                  };\n                }\n\n                _options = options, domain = _options.domain, lang = _options.lang;\n                headerElement = this.headerElement();\n                headerElement.attrs.to = domain;\n                headerElement.attrs['xml:lang'] = lang;\n\n                this._attachParser(new this.Parser());\n\n                _context8.next = 9;\n                return this.write(this.header(headerElement));\n\n              case 9:\n                promiseStart =\n                /*#__PURE__*/\n                function () {\n                  var _ref = _asyncToGenerator(\n                  /*#__PURE__*/\n                  _regeneratorRuntime.mark(function _callee7() {\n                    var el;\n                    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n                      while (1) {\n                        switch (_context7.prev = _context7.next) {\n                          case 0:\n                            _context7.next = 2;\n                            return promise(_this5.parser, 'start');\n\n                          case 2:\n                            el = _context7.sent;\n\n                            if (!(el.name !== headerElement.name || el.attrs.xmlns !== headerElement.attrs.xmlns || el.attrs.from !== headerElement.attrs.to || !el.attrs.id)) {\n                              _context7.next = 5;\n                              break;\n                            }\n\n                            return _context7.abrupt(\"return\", promise(_this5, 'error'));\n\n                          case 5:\n                            _this5.domain = domain;\n                            _this5.lang = el.attrs['xml:lang'];\n\n                            _this5._status('open', el);\n\n                            return _context7.abrupt(\"return\", el);\n\n                          case 9:\n                          case \"end\":\n                            return _context7.stop();\n                        }\n                      }\n                    }, _callee7);\n                  }));\n\n                  return function promiseStart() {\n                    return _ref.apply(this, arguments);\n                  };\n                }();\n\n                return _context8.abrupt(\"return\", timeout(promiseStart(), options.timeout || this.timeout));\n\n              case 11:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function open(_x4) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n    /**\n     * Closes the stream then closes the socket\n     * https://xmpp.org/rfcs/rfc6120.html#streams-close\n     * https://tools.ietf.org/html/rfc7395#section-3.6\n     */\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee9() {\n        var el;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this._end();\n\n              case 2:\n                el = _context9.sent;\n                if (this.status !== 'offline') this._status('offline', el);\n                return _context9.abrupt(\"return\", el);\n\n              case 5:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n    /**\n     * Closes the stream and wait for the server to close it\n     * https://xmpp.org/rfcs/rfc6120.html#streams-close\n     * https://tools.ietf.org/html/rfc7395#section-3.6\n     */\n\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee10() {\n        var ms,\n            p,\n            _ref2,\n            _ref3,\n            el,\n            _args10 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                ms = _args10.length > 0 && _args10[0] !== undefined ? _args10[0] : this.timeout;\n                p = Promise.all([timeout(promise(this.parser, 'end'), ms), this.write(this.footer(this.footerElement()))]);\n                if (this.parser && this.socket) this._status('closing');\n                _context10.next = 5;\n                return p;\n\n              case 5:\n                _ref2 = _context10.sent;\n                _ref3 = _slicedToArray(_ref2, 1);\n                el = _ref3[0];\n                return _context10.abrupt(\"return\", el);\n\n              case 9:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n    /**\n     * Restart the stream\n     * https://xmpp.org/rfcs/rfc6120.html#streams-negotiation-restart\n     */\n    // eslint-disable-next-line require-await\n\n  }, {\n    key: \"restart\",\n    value: function () {\n      var _restart = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee11() {\n        var _this$options2, domain, lang;\n\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                this._detachParser();\n\n                this._attachParser(new this.Parser());\n\n                _this$options2 = this.options, domain = _this$options2.domain, lang = _this$options2.lang;\n                return _context11.abrupt(\"return\", this.open({\n                  domain: domain,\n                  lang: lang\n                }));\n\n              case 4:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function restart() {\n        return _restart.apply(this, arguments);\n      }\n\n      return restart;\n    }() // eslint-disable-next-line require-await\n\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee12(element) {\n        var _this6 = this;\n\n        var proceed;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                this.emit('outgoing', element);\n\n                proceed = function proceed() {\n                  return _this6.write(element).then(function () {\n                    _this6.emit('send', element);\n                  });\n                };\n\n                return _context12.abrupt(\"return\", this.hookOutgoing ? this.hookOutgoing(element).then(proceed) : proceed());\n\n              case 3:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function send(_x5) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n  }, {\n    key: \"sendReceive\",\n    value: function sendReceive(element) {\n      var ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.timeout;\n      return Promise.all([this.send(element), timeout(promise(this, 'element'), ms)]).then(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n            el = _ref5[1];\n\n        return el;\n      });\n    }\n  }, {\n    key: \"write\",\n    value: function write(data) {\n      var _this7 = this;\n\n      return new Promise(function (resolve, reject) {\n        // https://xmpp.org/rfcs/rfc6120.html#streams-close\n        // \"Refrain from sending any further data over its outbound stream to the other entity\"\n        if (_this7.status === 'closing') {\n          reject(new Error('Connection is closing'));\n          return;\n        }\n\n        var str = data.toString('utf8');\n\n        _this7.socket.write(str, function (err) {\n          if (err) {\n            return reject(err);\n          }\n\n          _this7.emit('output', str);\n\n          resolve();\n        });\n      });\n    }\n  }, {\n    key: \"isStanza\",\n    value: function isStanza(element) {\n      var name = element.name;\n      var NS = element.attrs.xmlns;\n      return (// This.online && FIXME\n        (NS ? NS === this.NS : true) && (name === 'iq' || name === 'message' || name === 'presence')\n      );\n    }\n  }, {\n    key: \"isNonza\",\n    value: function isNonza(element) {\n      return !this.isStanza(element);\n    } // Override\n\n  }, {\n    key: \"header\",\n    value: function header(el) {\n      return el.toString();\n    } // Override\n\n  }, {\n    key: \"headerElement\",\n    value: function headerElement() {\n      return new xml.Element('', {\n        version: '1.0',\n        xmlns: this.NS\n      });\n    } // Override\n\n  }, {\n    key: \"footer\",\n    value: function footer(el) {\n      return el.toString();\n    } // Override\n\n  }, {\n    key: \"footerElement\",\n    value: function footerElement() {} // Override\n\n  }, {\n    key: \"socketParameters\",\n    value: function socketParameters() {}\n  }]);\n\n  return Connection;\n}(EventEmitter); // Overrirde\n\n\nConnection.prototype.NS = '';\nConnection.prototype.Socket = null;\nConnection.prototype.Parser = null;\nmodule.exports = Connection;\nmodule.exports.socketConnect = socketConnect;","map":null,"metadata":{},"sourceType":"script"}