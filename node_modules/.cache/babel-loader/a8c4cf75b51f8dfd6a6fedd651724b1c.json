{"ast":null,"code":"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\nvar events = require('events');\n\nvar util = require('util');\n\nfunction isDef(value) {\n  return value !== undefined && value !== null;\n}\n/**\n * Abstract class defining the skeleton for all backoff strategies.\n * @param options Backoff strategy options.\n * @param options.randomisationFactor The randomisation factor, must be between\n * 0 and 1.\n * @param options.initialDelay The backoff initial delay, in milliseconds.\n * @param options.maxDelay The backoff maximal delay, in milliseconds.\n * @constructor\n */\n\n\nfunction BackoffStrategy(options) {\n  options = options || {};\n\n  if (isDef(options.initialDelay) && options.initialDelay < 1) {\n    throw new Error('The initial timeout must be greater than 0.');\n  } else if (isDef(options.maxDelay) && options.maxDelay < 1) {\n    throw new Error('The maximal timeout must be greater than 0.');\n  }\n\n  this.initialDelay_ = options.initialDelay || 100;\n  this.maxDelay_ = options.maxDelay || 10000;\n\n  if (this.maxDelay_ <= this.initialDelay_) {\n    throw new Error('The maximal backoff delay must be ' + 'greater than the initial backoff delay.');\n  }\n\n  if (isDef(options.randomisationFactor) && (options.randomisationFactor < 0 || options.randomisationFactor > 1)) {\n    throw new Error('The randomisation factor must be between 0 and 1.');\n  }\n\n  this.randomisationFactor_ = options.randomisationFactor || 0;\n}\n/**\n * Retrieves the maximal backoff delay.\n * @return The maximal backoff delay, in milliseconds.\n */\n\n\nBackoffStrategy.prototype.getMaxDelay = function () {\n  return this.maxDelay_;\n};\n/**\n * Retrieves the initial backoff delay.\n * @return The initial backoff delay, in milliseconds.\n */\n\n\nBackoffStrategy.prototype.getInitialDelay = function () {\n  return this.initialDelay_;\n};\n/**\n * Template method that computes the next backoff delay.\n * @return The backoff delay, in milliseconds.\n */\n\n\nBackoffStrategy.prototype.next = function () {\n  var backoffDelay = this.next_();\n  var randomisationMultiple = 1 + Math.random() * this.randomisationFactor_;\n  var randomizedDelay = Math.round(backoffDelay * randomisationMultiple);\n  return randomizedDelay;\n};\n/**\n * Computes the next backoff delay.\n * @return The backoff delay, in milliseconds.\n * @protected\n */\n\n\nBackoffStrategy.prototype.next_ = function () {\n  throw new Error('BackoffStrategy.next_() unimplemented.');\n};\n/**\n * Template method that resets the backoff delay to its initial value.\n */\n\n\nBackoffStrategy.prototype.reset = function () {\n  this.reset_();\n};\n/**\n * Resets the backoff delay to its initial value.\n * @protected\n */\n\n\nBackoffStrategy.prototype.reset_ = function () {\n  throw new Error('BackoffStrategy.reset_() unimplemented.');\n};\n\nmodule.exports = BackoffStrategy;","map":null,"metadata":{},"sourceType":"script"}